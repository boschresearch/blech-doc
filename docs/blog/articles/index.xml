<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blech – Articles about the Blech language, tools, and releated topics</title>
    <link>https://www.blech-lang.org/blog/articles/</link>
    <description>Recent content in Articles about the Blech language, tools, and releated topics on Blech</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://www.blech-lang.org/blog/articles/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Blog: A module system for Blech</title>
      <link>https://www.blech-lang.org/blog/2020/11/23/a-module-system-for-blech/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/blog/2020/11/23/a-module-system-for-blech/</guid>
      <description>
        
        
        &lt;p&gt;The Blech module system supports modular programming for reactive, embedded, safety-critical applications. 
With the languages used in this domain today, we rely on coding conventions, programming idioms and the physical code structure to organize software in a modular way. 
This is difficult and error prone. 
As a consequence today&amp;rsquo;s systems are often more monolithic than modular.&lt;/p&gt;
&lt;p&gt;Blech&amp;rsquo;s synchronous paradigm together with the upcoming module system enables and supports modular programming.
It has the following properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Module implementations encapsulate code.&lt;/li&gt;
&lt;li&gt;Modules are namespaces for code entities.&lt;/li&gt;
&lt;li&gt;Module interfaces are automatically generated from implementations and their import/export declarations.&lt;/li&gt;
&lt;li&gt;Module interfaces hide implementation details.&lt;/li&gt;
&lt;li&gt;The import hierarchy is always a directed acyclic graph, supporting a layered modular software structure.&lt;/li&gt;
&lt;li&gt;Every layer is separately testable and reusable.&lt;/li&gt;
&lt;li&gt;The compiler recursively compiles programs and modules along the dependency hierarchy.&lt;/li&gt;
&lt;li&gt;Optionally importing all implementation details allows for white-box testing.&lt;/li&gt;
&lt;li&gt;Modules can be packaged to libraries - called &lt;em&gt;boxes&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Boxes are namespaces for modules.&lt;/li&gt;
&lt;li&gt;Boxes can hide internal implementation modules.&lt;/li&gt;
&lt;li&gt;The syntax for modules is light-weight.&lt;/li&gt;
&lt;li&gt;Reasoning about the modular structure is easy.&lt;/li&gt;
&lt;li&gt;Modules and boxes map to files and directories.&lt;/li&gt;
&lt;li&gt;All static analysis is designed to work with separate compilation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The details follow now.&lt;/p&gt;
&lt;p&gt;In order to motivate the design of the Blech module system, we will refer to the wikipedia article on &lt;a href=&#34;https://en.wikipedia.org/wiki/Modular_programming&#34; target=&#34;_blank&#34;&gt;Modular Programming&lt;/a&gt;
 &lt;a href=&#34;#ModularProgramming&#34;&gt;[1]&lt;/a&gt;
 and a blog post on &lt;a href=&#34;https://medium.com/@olegalexander/how-to-write-large-programs-628c90a70615&#34; target=&#34;_blank&#34;&gt;How to write Large Programs&lt;/a&gt;
 &lt;a href=&#34;#LargePrograms&#34;&gt;[2]&lt;/a&gt;
 .&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start with the definition of modular programming:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains [&amp;hellip;] only one aspect of the desired functionality. &lt;a href=&#34;#ModularProgramming&#34;&gt;[1]&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Blech supports this design technique by grouping code into modules.&lt;/p&gt;
&lt;h2 id=&#34;module-implementation&#34;&gt;Module implementation&lt;/h2&gt;
&lt;p&gt;To keep things simple, every Blech file can be compiled separately and is either a program or a module.
A module file groups closely related Blech entities - constants, types, functions, activities, etc. - into a compilation unit, that can be used (imported) by other modules or programs.
The keyword &lt;code&gt;module&lt;/code&gt; classifies the content of a Blech file as a module.
Different to modules, a program file requires an &lt;code&gt;@[EntryPoint]&lt;/code&gt; activity which serves as the main activity of a Blech program. 
A program file cannot be imported by other modules or programs.&lt;/p&gt;
&lt;p&gt;Assume the following module implementation in file &lt;code&gt;ringbuffer.blc&lt;/code&gt;.
In order to make an entity accessible it needs to be exposed.
Here, functions &lt;code&gt;initialise&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; are exposed for usage, in any importing module or program.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;module exposes initialise, push, average

const Size: nat8 = 10

struct RingBuffer
    var buffer: [Size]nat32
    var nextIndex: nat8
    var count: nat8
end

/// returns an initialisation value for a ring buffer
function initialise () returns RingBuffer
    return { nextIndex = 0, count = 0 }
end

/// pushes a new value to the ring buffer
/// displaces the &amp;#34;oldest&amp;#34; value if the ring buffer is full
function push (value: nat32) (rb: RingBuffer)
    rb.buffer[rb.nextIndex] = value
    rb.nextIndex = rb.nextIndex + 1
    if rb.count = Size then // ringbuffer ist completely filled
        rb.nextIndex = rb.nextIndex % Size
    else
        rb.count = rb.count + 1
    end
end

/// calculates the average value of all values stored in the ring buffer
function average (rb: RingBuffer) returns nat32
    var idx: nat8 = 0
    var avg: nat32 = 0
    while idx &amp;lt; rb.count do
        avg = avg + rb.buffer[idx]
    end
    return avg / rb.count
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;module-interface&#34;&gt;Module interface&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A module interface expresses the elements that are provided and required by the module. The elements defined in the interface are detectable by other modules. The implementation contains the working code that corresponds to the elements declared in the interface. &lt;a href=&#34;#ModularProgramming&#34;&gt;[1]&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A module interface in Blech is called a &lt;code&gt;signature&lt;/code&gt;.
The signature is generated by the compiler from the module implementation and the &lt;code&gt;exposes&lt;/code&gt; declaration.
A Blech programmer never writes a signature file.
After compilation of file &lt;code&gt;ringbuffer.blc&lt;/code&gt; you will find the following module interface in file &lt;code&gt;ringbuffer.blh&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;signature

type RingBuffer

/// returns an initialisation value for a ring buffer
function initialise () returns RingBuffer

/// pushes a new value to the ring buffer
/// replaces the &amp;#34;oldest&amp;#34; value if the ring buffer is completely filled
function push (value: nat32) (rb: RingBuffer)

/// calculates the average value of all values stored in the ring buffer
function average (rb: RingBuffer) returns nat32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The exposed functions additionally need the type &lt;code&gt;RingBuffer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;struct RingBuffer&lt;/code&gt; is not exposed in the module it is made available as an opaque &lt;code&gt;type RingBuffer&lt;/code&gt; in the signature.
While the implementation remains hidden, the opaque type can be used to define variables and assign values of this type.
This allows to change the internal representation, while any code the uses the module remains unchanged. 
Opaque types are sometimes also called abstract types, and are a simple form of the theoretical concept of existential types.&lt;/p&gt;
&lt;p&gt;Signatures carry all information necessary to compile any code that uses this module. 
This enables to package Blech modules into libraries. 
There is no need to deliver module implementations.
It is enough to deliver compiled libraries with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;signatures, .h- and .c-files, using the Blech compiler or&lt;/li&gt;
&lt;li&gt;signatures, .h-files and target-specific object files, additionally using the target&amp;rsquo;s C compiler.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;using-modules&#34;&gt;Using modules&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;When creating a modular system, instead of creating a monolithic application (where the smallest component is the whole), several smaller modules are written separately so when they are composed together, they construct the executable application program. &lt;a href=&#34;#ModularProgramming&#34;&gt;[1]&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In order to use a module it gets imported by another module or program.
Assume the following use of the &lt;code&gt;ringbuffer&lt;/code&gt; module from a module implementation in file &lt;code&gt;slidingaverage.blc&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import rb &amp;#34;ringbuffer&amp;#34;

module exposes SlidingAverage 

param Threshold: nat32 = 10000 // Application parameter, can be modified in the binary 

/// Calculates the average of the latest values in every tick
/// Values outside a fixed threshold are ignored.
activity SlidingAverage (value: nat32) (average: nat32)
    var buf: rb.RingBuffer = rb.initialise() 
    repeat
        if value &amp;lt;= Threshold then
            rb.push(value)(buf)
        end
        average = rb.average(buf)
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This module imports a module from file &lt;code&gt;ringbuffer.blc&lt;/code&gt; with the local name &lt;code&gt;rb&lt;/code&gt;.
It implements and exposes a single activity &lt;code&gt;SlidingAverage&lt;/code&gt;, with a local variable of type &lt;code&gt;rb.RingBuffer&lt;/code&gt;.
The module completely hides its internal implementation, which uses the abstract type &lt;code&gt;RingBuffer&lt;/code&gt; and functions &lt;code&gt;initialise&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;average&lt;/code&gt; from module &lt;code&gt;rb&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The generated signature in file &lt;code&gt;slidingaverage.blh&lt;/code&gt; is simple. 
The implementations details are completely hidden.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;signature

/// Calculates the average of the latest values in every tick
activity SlidingAverage (value: nat32) (average: nat32)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Using this module in a Blech program file &lt;code&gt;main.blc&lt;/code&gt; is straight forward.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import sa &amp;#34;slidingaverage&amp;#34;

@[EntryPoint]
activity SlidingAverage (sensor: nat32) (sensorAverage: nat32)
    run sa.SlidingAverage(sensor)(sensorAverage)    
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;compiling-a-program&#34;&gt;Compiling a program&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Often modules form a directed acyclic graph (DAG); in this case a cyclic dependency between modules is seen as indicating that these should be a single module. In the case where modules do form a DAG they can be arranged as a hierarchy, where the lowest-level modules are independent, depending on no other modules, and higher-level modules depend on lower-level ones. &lt;a href=&#34;#ModularProgramming&#34;&gt;[1]&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;No dependency cycles between modules&lt;/em&gt; is an important rule for a good system design:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This design rule will prevent your code from turning into a big ball of mud. 
[&amp;hellip;] Dependency cycles are bad because they increase coupling [&amp;hellip;] and [&amp;hellip;] can’t be tested in isolation. &lt;a href=&#34;#LargePrograms&#34;&gt;[2]&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In Blech, programs as top-level compilation units and imported modules always form a directed acyclic graph.
This enables automatic dependency management in the compiler.&lt;/p&gt;
&lt;p&gt;In the above example, the compilation of program file &lt;code&gt;main.blc&lt;/code&gt; automatically compiles imported module &lt;code&gt;slidingaverage&lt;/code&gt; which in turn compiles imported module &lt;code&gt;ringbuffer&lt;/code&gt;.
Any cycles in the import dependencies will be flagged as an error.&lt;/p&gt;
&lt;p&gt;In general the compilation of any program and any module triggers the compilation of imported modules, if necessary.
A layered and cylce-free module hierarchy is always guaranteed.&lt;/p&gt;
&lt;h2 id=&#34;testing-a-module&#34;&gt;Testing a module&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A module interface expresses the elements that are provided and required by the module. The elements defined in the interface are detectable by other modules. &lt;a href=&#34;#ModularProgramming&#34;&gt;[1]&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This an advantage for loosely coupled system design. But it is a disadvantage for white-box testing.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;White-box testing (also known as clear box testing, glass box testing, transparent box testing, and structural testing) is a method of software testing that tests internal structures or workings of an application, as opposed to its functionality (i.e. black-box testing). &lt;a href=&#34;#WhiteBoxTesting&#34;&gt;[3]&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In order to enable white-box testing, Blech allows to import all the implementation details of a module by using keyword &lt;code&gt;internal&lt;/code&gt;.
An &lt;code&gt;internal import&lt;/code&gt; makes all elements in a module detectable - nothing is hidden.&lt;/p&gt;
&lt;p&gt;In the following example, it is not enough to use the signature &lt;code&gt;ringbuffer.blh&lt;/code&gt; to compile the white-box test program.
In fact the compiler needs the source code of the module implementation &lt;code&gt;ringbuffer.blc&lt;/code&gt; in order to detect the hidden implementation details.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import n8 &amp;#34;box:base/nat8&amp;#34;  // base library for nat8-related stuff

internal import rb &amp;#34;ringbuffer&amp;#34;

@[EntryPoint]
activity TestPush ()
    var buf: rb.RingBuffer = rb.initialise()
    var i: nat8 = 0
    repeat
        assert buf.nextIndex &amp;lt; rb.Size
        assert buf.nextIndex == i % rb.Size
        assert buf.count &amp;gt;= 0 
        assert buf.count &amp;lt;= rb.Size
        
        rb.push(42)(buf) // the value is irrelevant
        i = i + 1
        
        if i &amp;lt; rb.Size then
            assert buf.count == i
        else
            assert buf.count == rb.Size
        end
        await true
    until i == n8.Max end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The modules provided by a library cannot be white-box tested, because a packaged library usually does not contain module implementation files.&lt;/p&gt;
&lt;h2 id=&#34;packaging-modules-into-a-library&#34;&gt;Packaging modules into a library&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A particular library is a [&amp;hellip;] collection of modules of its own hierarchy, but can in turn be seen as a lower-level module collection [&amp;hellip;] to be used by a higher-level program, library, or system. &lt;a href=&#34;#ModularProgramming&#34;&gt;[1]&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In Blech we call a library a &lt;em&gt;Blech box&lt;/em&gt; or a &lt;em&gt;box&lt;/em&gt; for short. 
A box is a collection of modules and programs.
Typically some modules of a box are supposed to be used from those higher levels, while others remain internally hidden and only serve implementation purposes.&lt;/p&gt;
&lt;p&gt;By default every module in a box can be imported from a higher-level program or module.
In order to hide a module in a box it can be declared as an &lt;code&gt;internal module&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In our running example, we could decide to make the module &lt;code&gt;ringbuffer&lt;/code&gt; an internal module.
This can be done by declaring the module as &lt;code&gt;internal module&lt;/code&gt; - the rest remains unchanged.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;internal module exposes initialise, push, average

const Size ...
struct RingBuffer  ...
function initialise () returns RingBuffer ...
function push (value: nat32) (rb: RingBuffer) ...
function average (rb: RingBuffer) returns nat32 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The signature becomes &lt;code&gt;internal&lt;/code&gt; as well.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;internal signature

type RingBuffer
function initialise () returns RingBuffer
function push (value: nat32) (rb: RingBuffer)
function average (rb: RingBuffer) returns nat32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If we package this module together with module &lt;code&gt;slidingaverage&lt;/code&gt; from above into a box, 
only the signature for &lt;code&gt;slidingaverage&lt;/code&gt; should be detectable, the signatures of internal modules are hidden.&lt;/p&gt;
&lt;p&gt;In order to write a non-internal module that imports an &lt;code&gt;internal module&lt;/code&gt;, the details of those imports must not leak through its interface.
For example, the following module &lt;code&gt;ringbufferaverage&lt;/code&gt; implicitly exposes the opaque type &lt;code&gt;RingBuffer&lt;/code&gt; from the imported internal module &lt;code&gt;ringbuffer&lt;/code&gt;.
The internal implementation leaks through its interface and therefore the module becomes itself an &lt;code&gt;internal module&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import rb &amp;#34;ringbuffer&amp;#34;

internal module exposes RingBufferAverage

activity RingBufferAverage (buf: rb.RingBuffer) (average: nat32)
    repeat
        average = rb.average(buf)
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This means, module &lt;code&gt;ringbufferaverage&lt;/code&gt; is not accessible outside of its box.
The compiler checks this, and it is an error to omit the the classification &lt;code&gt;internal&lt;/code&gt; for the module.&lt;/p&gt;
&lt;p&gt;The signature of module &lt;code&gt;ringbufferaverage&lt;/code&gt; looks as follows.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import rb &amp;#34;ringbuffer&amp;#34;

internal signature

activity RingBufferAverage (buf: rb.RingBuffer) (average: nat32)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For pragmatic reasons it might be necessary to circumvent the black-box interface of a module and use a white-box import instead.
This can only be done within the same box, since it requires the source of the module implementation.
As an example, we would like to use &lt;code&gt;param Threshold&lt;/code&gt; from module &lt;code&gt;slidingaverage&lt;/code&gt; - which is not exposed - in a new module &lt;code&gt;slidingaveragewithreset&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;internal import sa &amp;#34;slidingaverage&amp;#34;

module exposes SlidingAverageWithReset

activity SlidingAverageWithReset (sensor: nat32) (sensorAverage: nat32)
    when sensor &amp;gt; sa.Treshold reset
        run sa.SlidingAverage(sensor)(sensorAverage)
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since the interface does not leak any implementation details from the white-box import it can be made detectable (non-internal) in the box.&lt;/p&gt;
&lt;p&gt;There are two simple rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a module that leaks details of an imported &lt;code&gt;internal module&lt;/code&gt; in its signature becomes an &lt;code&gt;internal module&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;a module that leaks details of an &lt;code&gt;internal import&lt;/code&gt; in its signature becomes an &lt;code&gt;internal module&lt;/code&gt;, too.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;importing-inside-and-outside-a-box&#34;&gt;Importing inside and outside a box&lt;/h2&gt;
&lt;p&gt;In order to distinguish between imports inside a box and imports from other boxes, Blech uses an URL-like import path.&lt;/p&gt;
&lt;p&gt;Imports inside a box just adress the imported file.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import m &amp;#34;localmodule&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The compiler searches for file &lt;code&gt;localmodule.blc&lt;/code&gt; to compile it, or uses &lt;code&gt;localmodule.blh&lt;/code&gt; if nothing has changed and &lt;code&gt;localmodule.blc&lt;/code&gt; has been compiled before.
Note, that a recompilation of &lt;code&gt;localmodule.blc&lt;/code&gt; is also necessary, if any of &lt;code&gt;localmodule&lt;/code&gt;&#39;s imports have changed.&lt;/p&gt;
&lt;p&gt;In general, the imported file name for an import inside a box, can be adressed&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;relatively to the importing module, or&lt;/li&gt;
&lt;li&gt;absolutely from the top of the box.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here are some examples for an import inside a box:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import ma &amp;#34;../module_A&amp;#34;            // relative path, one directory up
import mb &amp;#34;./sub_dir/module_B&amp;#34;     // relative path one directory down
import mb2 &amp;#34;sub_dir/module_B&amp;#34;      // as before with a different local name 
import mc  &amp;#34;/top_level/module_C&amp;#34;   // absolute path inside the box
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In order to import a module from another box, we need a prefix to address a box, the name of the box and the module inside the box.
The import declaration has the following form&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import m &amp;#34;box:library/module&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This tells the compiler to import a module &lt;code&gt;module&lt;/code&gt; from box &lt;code&gt;box:library&lt;/code&gt; and name it &lt;code&gt;m&lt;/code&gt; locally. 
The compiler searches for the signature file &lt;code&gt;module.blh&lt;/code&gt; in the box named &lt;code&gt;library&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When importing from another box, the compiler prevents:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the import of an &lt;code&gt;internal module&lt;/code&gt; from the box, and&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;internal import&lt;/code&gt; of a detectable module from the box.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Such imports are flagged as an error, even if module implementations and &lt;code&gt;internal signature&lt;/code&gt;s are part of the box.
This is helpful, when developing different boxes at the same time.
The detectability between boxes is the same during development and after deployment.&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;internal imports&lt;/code&gt; from other boxes are not allowed, there is no need to deliver the module&amp;rsquo;s implementation file &lt;code&gt;module.blc&lt;/code&gt; with the box &lt;code&gt;library&lt;/code&gt;.
Since imports of &lt;code&gt;internal modules&lt;/code&gt; of a box are also forbidden, there is also no need to deliver &lt;code&gt;internal signature&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;This brings us to the last question: How are Blech files organized on the file system?&lt;/p&gt;
&lt;h2 id=&#34;organizing-blech-files&#34;&gt;Organizing Blech files&lt;/h2&gt;
&lt;p&gt;Blech programs, libraries and systems are organized in boxes.&lt;/p&gt;
&lt;p&gt;When developing a box, the program and module implementation files are placed beneath a top-level directory - the Blech project.
The top-level directory can have sub-directories that contain further implementation files.
The file structure corresponds to the import paths used in the import declaration.&lt;/p&gt;
&lt;p&gt;Note, that the choice of directory and file names is restricted for simpler name mangling. 
The compiler checks this.&lt;/p&gt;
&lt;p&gt;The file structure of the Blech source code translates to the file structure of compilation artefacts: signatures, .h-files and .c-files.
It is possible to work on more than one box at a time, you just need 2 or more Blech projects in independent directories.&lt;/p&gt;
&lt;h2 id=&#34;tricks-of-trade&#34;&gt;Tricks of trade&lt;/h2&gt;
&lt;p&gt;As you might have noticed, every imported entity is qualified by the local module name in the examples.
Sometimes you don&amp;rsquo;t want qualification and address an entity directly. 
The &lt;code&gt;import&lt;/code&gt; declaration optionally &lt;code&gt;exposes&lt;/code&gt; selected entities for this purpose.&lt;/p&gt;
&lt;p&gt;In rare cases, you might want to &lt;code&gt;expose&lt;/code&gt; everything in a module, or import everything without qualification.&lt;/p&gt;
&lt;p&gt;There are shortcuts for these purposes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Make selected entities directly accessible&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import rb &amp;#34;ringbuffer&amp;#34; exposes initialise, push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Make all entities directly accessible&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import rb &amp;#34;ringbuffer&amp;#34; exposes ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Create an import dependency but do not use it right now in the current status of development&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import _ &amp;#34;ringbuffer&amp;#34; // no name for qualified access
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Omit the local module name&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import _ &amp;#34;ringbuffer&amp;#34; exposes RingBuffer, initialise, push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Expose everything in a module&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;module exposes ...  // no information hiding
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Use these &amp;ldquo;tricks of trade&amp;rdquo; wisely, and only if necessary. Keep in mind, Blech implements a rigid no-shadowing strategy.
If two imports expose the same name, the second will create an error because it shadows the first.&lt;/p&gt;
&lt;h2 id=&#34;modules-are-not-generic&#34;&gt;Modules are not generic&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Modules lie on a spectrum from high-level (specific) to low-level (generic). The highest level module contains the entry point of the program, whereas the lowest level modules are usually generic libraries. [&amp;hellip;] Stability increases at lower levels. [&amp;hellip;] Reusability increases at lower levels. Low-level modules should be generic libraries so that they can be reused in other projects. &lt;a href=&#34;#LargePrograms&#34;&gt;[2]&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Of course it is a natural wish, to have the &lt;code&gt;ringbuffer&lt;/code&gt; module parameterized by its size (here: &lt;code&gt;const Size&lt;/code&gt;) and its element type (here: &lt;code&gt;nat32&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;But, in Blech we keep the module system simple. 
Instead of having generic modules and generating code for every monomorphised instance, we decided to cope with generics on another language level, similar to interfaces or traits in other languages.
Then, modules also might contain generic types and generic interface implementations.&lt;/p&gt;
&lt;p&gt;The concept of type-safe generics is in an early stage, and different to other languages follows our embedded requirements.
It will definitely need some more Blech releases before we can adress generics.&lt;/p&gt;
&lt;h2 id=&#34;better-software-through-modules&#34;&gt;Better software through modules&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;[&amp;hellip;] Modular designed systems, if built correctly, [are] far more reusable than a traditional monolithic design, since all (or many) of these modules may then be reused (without change) in other projects. This also facilitates the &amp;ldquo;breaking down&amp;rdquo; of projects into several smaller projects. Theoretically, a modularized software project will be more easily assembled by large teams, since no team members are creating the whole system, or even need to know about the system as a whole. They can focus just on the assigned smaller task (this, it is claimed, counters the key assumption of The Mythical Man Month, making it actually possible to add more developers to a late software project without making it later still). &lt;a href=&#34;#ModularProgramming&#34;&gt;[1]&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Blech module system supports better software design and improved software qualities:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;It allows to organize code by using different files for different aspects without reverting to the archaic method of &lt;code&gt;include&lt;/code&gt;d header files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Modules and programs are the units of separate compilation. All static analysis in the compiler is designed to work with separate compilation. To our knowledge Blech is the first imperative, synchronous language to support separate compilation for causality analysis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It allows to package compilation units to libraries - boxes of modules and programs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It is designed with a minimal set of syntactic overhead. All import and export information is visible in the head of a module implementation. External visibility is not scattered all over the file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It prevents the pollution of a single global name spaces. Actually there is no global name space that would force the programmer to carefully choose names that are visible everywhere. Modules are namespaces for types and code, boxes are namespaces for modules.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is no need to separate source code into an interface and an implementation part. The source code of module implementations contains all necessary information, interfaces are generated by the compiler.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Modules simplify the design of components that are self-contained: independent, and with a single, well-defined purpose. A major enabler to do this are Blech&amp;rsquo;s &lt;code&gt;activity&lt;/code&gt;s which hold state between time steps locally instead of using global variables. The famous qualities &lt;em&gt;high cohesion&lt;/em&gt; and &lt;em&gt;low coupling&lt;/em&gt; are actively supported by the language.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Module interfaces support API-orientation. Modules can be developed, tested and even verified in parallel. Implementation changes are easily possible if interfaces are kept small. Especially opaque types enable this.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The compiler enforces a directed acyclic dependency graph. This supports the design of layered architecture without dependency cycles between modules and boxes. Upcalls can be realized with callbacks without introducing cyclic dependencies. Unfortunately, you will have to wait for a later Blech release to support callback references.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Because of the directed acyclic graph structure, modules can be &amp;ldquo;cut off&amp;rdquo; and tested in isolation. To test a given module you only need all of its &amp;ldquo;upstream&amp;rdquo; dependencies.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The module dependency graph can easily be visualized and is independent from the code organisation on the file system.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The ability to white-box test a given module allows to separate test code from the module implementation although a module might have an interface that hides many of the implementation details. In many languages white-box testing requires reflection which is not appropriate for embedded code. To our knowledge this feature is unique to Blech.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We hope to release Blech with modules before the end of the year. Stay tuned.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;p&gt;[1] &lt;a name=&#34;ModularProgramming&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Modular_programming&#34; target=&#34;_blank&#34;&gt;Modular Programming&lt;/a&gt;
, en.wikipedia.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a name=LargePrograms&gt; &lt;a href=&#34;https://medium.com/@olegalexander/how-to-write-large-programs-628c90a70615&#34; target=&#34;_blank&#34;&gt;How to write large programs&lt;/a&gt;
, Oleg Alexander &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a name=WhiteBoxTesting&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/White-box_testing&#34; target=&#34;_blank&#34;&gt;White-box Testing&lt;/a&gt;
, en.wikipedia.org &lt;/a&gt;&lt;/p&gt;
&lt;!-- # Relevant links

[C++ Modules Might Be Dead-on-Arrival](https://vector-of-bool.github.io/2019/01/27/modules-doa.html)
[C++20: The advantages of modules](https://www.modernescpp.com/index.php/cpp20-modules)
[Low Coupling, High Cohesion](https://medium.com/clarityhub/low-coupling-high-cohesion-3610e35ac4a6)
[How To Write Large Programs](https://medium.com/@olegalexander/how-to-write-large-programs-628c90a70615)
# Steinbruch


&gt; Often modules form a directed acyclic graph (DAG); in this case a cyclic dependency between modules is seen as indicating that these should be a single module. In the case where modules do form a DAG they can be arranged as a hierarchy, where the lowest-level modules are independent, depending on no other modules, and higher-level modules depend on lower-level ones. A particular program or library is a top-level module of its own hierarchy, but can in turn be seen as a lower-level module of a higher-level program, library, or system. 

```blech
module exposes initialise, push, average

const Size: nat8 = 10

struct RingBuffer
    var buffer: [Size]nat32
    var nextIndex: nat8
    var count: nat8
end

function initialise () returns RingBuffer
    return { nextIndex = 0, count = 0 }
end

function push (value: nat32) (rb: RingBuffer)
    rb.buffer[rb.nextIndex] = value
    rb.nextIndex = rb.nextIndex + 1
    if rb.count = Size then // ringbuffer ist completely filled
        rb.nextIndex = rb.nextIndex % Size
    else
        rb.count = rb.count + 1
    end
end

function average (rb: RingBuffer) returns nat32
    var idx: nat8 = 0
    var avg: nat32 = 0
    while idx &lt; rb.count do
        avg = avg + rb.buffer[idx]
    end
    return avg / rb.count
end
```

```blech
signature

type RingBuffer

function initialise () returns RingBuffer
function push (value: nat32) (rb: RingBuffer)
function average (rb: RingBuffer) returns nat32
```


```blech
import rb &#34;ringbuffer&#34;

module exposes SlidingAverage 

activity SlidingAverage (value: nat32) (average: nat32)
    var buf: rb.RingBuffer = rb.initialise() 
    repeat
        rb.push(value)(buf)
        average = rb.average(buf)
        await true
    end
end
```

``` blech
signature

activity SlidingAverage (value: nat32) (average: nat32)
```

```blech
import sa &#34;slidingaverage&#34;

@[EntryPoint]
activity SlidingAverage (sensor: nat32) (sensorAverage: nat32)
    run sa.SlidingAverage(sensor)(sensorAverage)    
end
```


Bad design.

``` blech
import rb &#34;ringbuffer&#34;

module exposes SlidingAverage 

activity SlidingAverage (value: nat32) 
                        (ringbuffer: rb.RingBuffer, average: nat32)
    repeat
        rb.push(value)(ringBuffer)
        average = rb.average(ringBuffer)
        await true
    end
end
```

``` blech
import rb &#34;ringbuffer&#34;

signature

activity SlidingAverage (value: nat32) 
                        (ringbuffer: rb.RingBuffer, average: nat32)
```

```blech
import r &#34;ringbuffer&#34;
import s &#34;slidingaverage&#34;

@[EntryPoint]
activity SlidingAverage (sensor: nat32) (sensorAverage: nat32)
    var ringBuffer: r.RingBuffer = r.initialise()
    run s.SlidingAverage(sensor)(ringBuffer, sensorAverage)    
end
```



### Using internal import to access internal details.

A module that uses an `internal import` becomes itself an `internal module` if it leaks details of the `internal import` in its interface. 
Assume the following module in file `countobserver.blc`-
``` blech
internal import rb &#34;ringbuffer&#34;

internal module exposes MaxCount, count

const MaxCount: nat8 = rb.Size

function count (buf: rb.RingBuffer) returns nat8
    return buf.count
end
```

It is a compiler error not to classify the module as `internal`.

It is also not possible to create a module interface that is independent of the module implementation file  `ringbuffer.blc`.
Compilation completely relies on implementation files.
Therefore we never create the following a signature file.

``` blech
internal import rb &#34;ringbuffer&#34;

signature
const MaxCount: nat8 = rb.Size
function count (buf: rb.RingBuffer) returns nat8
```

On the other hand, we can classify a module as `internal` to prevent exposing it in a package.
This means internal modules are hidden inside a package, because they do not generate a signature.
An `internal import` or the import of an `internal module` always needs the source code of the module implementation file.

In order to create a signature for a module that uses an `internal import` or imports an `internal module`, the details of those imports must not leak through its interface.

``` blech
import rb &#34;ringbuffer&#34;

module exposes ObserveFilledBuffer

const MaxCount: nat8 = rb.Size

function count (buf: rb.RingBuffer) returns nat8
    return buf.count
end

activity ObserveFilledBuffer (value: nat32) (filled: bool)
    var buf: rb.RingBuffer = rb.initialise()
    repeat
        rb.push(value)(buf)
        filled = count(buf) == MaxCount
        await true
    end
end
```

``` blech
signature
activity ObserveFilledBuffer (value: nat32) (filled: bool)
```

 --&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Push button handling</title>
      <link>https://www.blech-lang.org/blog/2020/08/12/push-button-handling/</link>
      <pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/blog/2020/08/12/push-button-handling/</guid>
      <description>
        
        
        &lt;h2 id=&#34;application-example-push-button-handling&#34;&gt;Application example: Push button handling&lt;/h2&gt;
&lt;p&gt;In this example three push buttons, &lt;code&gt;TOP&lt;/code&gt;, &lt;code&gt;CENTER&lt;/code&gt; and &lt;code&gt;BOTTOM&lt;/code&gt;, are connected to our embedded system for user input. Like in our &lt;a href=&#34;https://www.blech-lang.org/blog/2020/06/15/decoding-the-dcf77-signal-with-blech/&#34;&gt;previous blog post&lt;/a&gt;
 our hardware setup is based on a &lt;a href=&#34;https://www.st.com/en/evaluation-tools/stm32f4discovery.html&#34; target=&#34;_blank&#34;&gt;STM32F4DISCOVERY&lt;/a&gt;
 board. The latter has four color LEDs, red, blue, green and orange, which we are going to use for showing the button states.&lt;/p&gt;
&lt;p&gt;Additionally, we connect a small breadboard with three general purpose push buttons. All buttons share a common electrical ground on the left-hand side of the breadboard. On the right-hand side, there is an individual signal wire for each button which is connected to a dedicated GPIO of the discovery board. The pull-up resistors of these GPIOs are active.&lt;/p&gt;
&lt;p&gt;Finally, we connect two probes of an oscilloscope. Channel 1 (&lt;code&gt;CH1&lt;/code&gt;) connects to a debug pin which is set to &lt;code&gt;HIGH&lt;/code&gt; while Blech code is executed. Channel 4 (&lt;code&gt;CH4&lt;/code&gt;) connects to the output signal of &lt;code&gt;BOTTOM&lt;/code&gt; for demonstration purpose. The complete setup is depicted below:&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 810px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;https://www.blech-lang.org/blog/2020/08/12/push-button-handling/hw_setup_hu23550f2f3ae8300fcffd20d487cc24a6_6311261_800x0_resize_catmullrom_2.png&#34; width=&#34;800&#34; height=&#34;560&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
Hardware setup for the push button handling example.
&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;
&lt;p&gt;By default, the electrical contacts of the push buttons are open. Thus, the pull-ups on the discovery board will tie the button output signals to the supply voltage (&lt;em&gt;+3.3V&lt;/em&gt;) while they are not pressed. If a button gets pressed it pulls the output signal to ground (&lt;em&gt;0V&lt;/em&gt;). This means that, physically speaking, the buttons are &lt;em&gt;active-low&lt;/em&gt; &amp;ndash; the corresponding GPIO input register on the discovery board will be &lt;code&gt;0&lt;/code&gt; if the button is pressed, &lt;code&gt;1&lt;/code&gt; if it is not pressed.&lt;/p&gt;
&lt;p&gt;In order to make our Blech code more readable, we invert the &lt;em&gt;physical signal level&lt;/em&gt; into a &lt;em&gt;logical signal level&lt;/em&gt; as follows:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Button state&lt;/th&gt;
&lt;th&gt;Physical signal level&lt;/th&gt;
&lt;th&gt;Logical signal level&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;not pressed&lt;/td&gt;
&lt;td&gt;+3.3V (&lt;code&gt;HIGH&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt; (&lt;code&gt;LOW&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pressed&lt;/td&gt;
&lt;td&gt;+0.0V (&lt;code&gt;LOW&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt; (&lt;code&gt;HIGH&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;When passing the GPIO input register values from C to Blech &lt;code&gt;0&lt;/code&gt; is changed to &lt;code&gt;1&lt;/code&gt; and vice versa. Then, in Blech, the button signal states are mapped to &lt;code&gt;bool&lt;/code&gt; variables. They will be &lt;code&gt;true&lt;/code&gt; when the corresponding button is pressed, &lt;code&gt;false&lt;/code&gt; if it is not pressed, thereby making the buttons &lt;em&gt;active-high&lt;/em&gt; in software.&lt;/p&gt;
&lt;p&gt;The goal of this application example is to show how we can handle button inputs in Blech. This involves &lt;a href=&#34;#signal-filter&#34;&gt;filtering the button signals&lt;/a&gt;
, &lt;a href=&#34;#event-detection-and-reaction&#34;&gt;detecting a button event&lt;/a&gt;
 and finally properly react to that. In the following sections we examine this in more detail.&lt;/p&gt;
&lt;p&gt;The complete project source code is available &lt;a href=&#34;https://github.com/mterber/blech-button&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;
 on Github.&lt;/p&gt;
&lt;h2 id=&#34;interlude-physical-time&#34;&gt;Interlude: Physical time&lt;/h2&gt;
&lt;p&gt;In practically all embedded applications we have to describe temporal behaviour in our software &amp;ndash; at least to a certain extent. The different use cases typically fall into two categories:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Delays&lt;/em&gt;: Sometimes the embedded system is much faster than its (physical) environment. In order to account for this speed difference, an artificial slowdown of the embedded software is required. This means that we deliberately suspend the code execution until a certain amount of time &amp;ndash; the &lt;em&gt;delay time&lt;/em&gt; &amp;ndash; has been passed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Timeouts&lt;/em&gt;: Sometimes we just need to know whether a certain event, or sequence of events, has happend before or after a certain amount of time &amp;ndash; the &lt;em&gt;timeout time&lt;/em&gt; &amp;ndash; has been elapsed. Depending on that the embedded software is going to behave differently.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both types require to express physical time in our code. For this, we establish the same execution scheme for Blech as described in &lt;a href=&#34;https://www.blech-lang.org/blog/2020/06/15/decoding-the-dcf77-signal-with-blech/#execution-scheme-and-integration-of-blech&#34;&gt;this&lt;/a&gt;
 blog post. That is, the entire Blech code is &lt;em&gt;purely time-driven&lt;/em&gt; based on a periodic system tick. Based on this, we can easily implement a small helper activity &lt;code&gt;AwaitMsec&lt;/code&gt; in Blech for suspending the program for an arbitrary number of milliseconds. The maximal resolution is given by the period interval of the system tick which is set to &lt;em&gt;10 milliseconds&lt;/em&gt; in this example.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;const MSEC_PER_SYSTICK: nat16 = 10

activity AwaitMsec (msec: nat16)
    var i: nat16 = msec / MSEC_PER_SYSTICK
    repeat
        await true
        i = i - 1
    until i == 0 end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Depending on the given number of milliseconds to wait, &lt;code&gt;AwaitMsec&lt;/code&gt; first determines the corresponding number of system ticks (line 4). Second, it awaits the relevant number in a &lt;code&gt;repeat&lt;/code&gt; loop (lines 5 &amp;ndash; 8). Calling &lt;code&gt;run AwaitMsec(50)&lt;/code&gt; causes the running trail to suspend for five system ticks for example. With this approach it is straight forward to implement &lt;a href=&#34;#delay&#34;&gt;delays&lt;/a&gt;
 and &lt;a href=&#34;#timeout&#34;&gt;timeouts&lt;/a&gt;
 in Blech.&lt;/p&gt;
&lt;h3 id=&#34;delay&#34;&gt;Delay&lt;/h3&gt;
&lt;p&gt;For realizing a delay of 120 milliseconds between two function calls &lt;code&gt;funcA()&lt;/code&gt; and &lt;code&gt;funcB()&lt;/code&gt; for instance we can directly use &lt;code&gt;AwaitMsec&lt;/code&gt; as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;funcA()
run AwaitMsec(120)
funcB()
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;This code snippet first executes function &lt;code&gt;funcA&lt;/code&gt;, then suspends the running trail for 120 milliseconds (= 12 system ticks) and finally calls function &lt;code&gt;funcB&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;timeout&#34;&gt;Timeout&lt;/h3&gt;
&lt;p&gt;For applying a timeout of 120 milliseconds onto an activity &lt;code&gt;SomeActivity&lt;/code&gt; for instance we can use &lt;code&gt;AwaitMsec&lt;/code&gt; in a concurrent trail as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;var done: bool = false
var timeout: bool = false
cobegin weak // Activity trail.
	run SomeActivity()
	done = true
with weak    // Timeout trail.
	run AwaitMsec(120)
	timeout = true
end
// Evaluate &amp;#39;done&amp;#39; and &amp;#39;timeout&amp;#39; (see below table).
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In this solution, we first declare two variables, &lt;code&gt;done&lt;/code&gt; and &lt;code&gt;timeout&lt;/code&gt;, which indicate whether or not &lt;code&gt;SomeActivity&lt;/code&gt; has been completed in time (lines 1 &amp;ndash; 2). Then, in the &lt;code&gt;cobegin&lt;/code&gt;, we execute two concurrent trails in which the first one (lines 4 &amp;ndash; 5) runs the actualy activity while the second one (lines 7 &amp;ndash; 8) is responsible for checking the timeout.&lt;/p&gt;
&lt;p&gt;Both trails are &lt;code&gt;weak&lt;/code&gt; so that they can abort each other depending on which event &amp;ndash; the completion of the activity or the timeout expiry &amp;ndash; happens first. Once the trails rejoin (line 10) we can use &lt;code&gt;done&lt;/code&gt; and &lt;code&gt;timeout&lt;/code&gt; to precisely distinguish the different scenarios as shown below:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Scenario&lt;/th&gt;
&lt;th&gt;&lt;code&gt;done&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;timeout&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Result&lt;/th&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;del&gt;1&lt;/del&gt;&lt;/td&gt;
&lt;td&gt;&lt;del&gt;&lt;code&gt;false&lt;/code&gt;&lt;/del&gt;&lt;/td&gt;
&lt;td&gt;&lt;del&gt;&lt;code&gt;false&lt;/code&gt;&lt;/del&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;&lt;del&gt;This is excluded by language design. At this point, at least one of the trails must have terminated before so that either &lt;code&gt;done&lt;/code&gt; or &lt;code&gt;timeout&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.&lt;/del&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;timeout&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SomeActivity&lt;/code&gt; has not terminated in time.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;success&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SomeActivity&lt;/code&gt; has terminated in time.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SomeActivity&lt;/code&gt; has terminated in the same reaction in which the timeout time has elapsed. This means that, according to the synchronous model of computation, both events have happened simultaneously. In this case it is up to the application logic to treat this as &lt;em&gt;success&lt;/em&gt;, &lt;em&gt;timeout&lt;/em&gt; or maybe something else.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
Some of you might wonder why we need two variables for realizing the timeout. Is it not possible to just use one? We just want to know whether we succeeded or failed. So two states, `true` and `false`, should be sufficient -- right? Can&#39;t we do something like this:

```blech
//
// !!! Erroneous Blech code. !!!
//
var success: bool = false
cobegin weak
	run SomeActivity()
	success = true   // We succeeded!
with weak
	run AwaitMsec(120)
	success = false  // We failed!
end
```

The short answer is: No. A more elaborated explanation is the following:

1. Due to the synchronous model of computation, this is technically not possible. If a variable *x* is shared across multiple concurrent trails at most one of them will be allowed to write to *x*. In the above code snippet `success` is shared between two concurrent trails that  modify it during runtime. If that was allowed the result of `success` -- after the trails have rejoined -- would depend on the execution order of these trails, making the runtime behaviour non-deterministic. As a consequence, this piece of code is reject by the Blech compiler.

1. A second point is that we actually have three different, possible results and not only two. This becomes apparent when looking at above table. It is possible that the completion of the activity and the timeout expiry happen at the same time and hence fell into the same reaction. Depending on your application logic this special scenario might have to be treated in a completely different way. With one variable only it would be impossible to make a proper distinction here.
--&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
Again, note how easy it is in Blech to use the same piece of reactive code (&lt;code&gt;AwaitMsec&lt;/code&gt;) for different concerns (delays and timeouts) likewise.
&lt;/div&gt;

&lt;h2 id=&#34;signal-filter&#34;&gt;Signal filter&lt;/h2&gt;
&lt;p&gt;In order to provide a good user experience we want to detect only &lt;em&gt;notable&lt;/em&gt; level changes of the button signals. Glitches and high frequent noise that might be caused by &lt;a href=&#34;https://en.wikipedia.org/wiki/Switch#Contact_bounce&#34; target=&#34;_blank&#34;&gt;bouncing&lt;/a&gt;
 for instance shall be filtered
out before we actually evaluate and consider the current button state in our software. For this purpose, we implement three dedicated activities, starting from bottom to top:&lt;/p&gt;
&lt;h3 id=&#34;await-a-stable-level&#34;&gt;Await a stable level&lt;/h3&gt;
&lt;p&gt;First, &lt;code&gt;AwaitStableLevel&lt;/code&gt; is responsible for checking the stability of the button output signal. Input &lt;code&gt;lvl&lt;/code&gt; is the signal level that shall be awaited until it is stable. Input &lt;code&gt;btnRaw&lt;/code&gt; is the raw button signal as retrieved from the GPIO. For example, &lt;code&gt;run AwaitStableLevel(false, btns.top)&lt;/code&gt; means we want to suspend execution until the logic level of button &lt;code&gt;TOP&lt;/code&gt; is reliably &lt;code&gt;LOW&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;const DEBOUNCE: nat8 = 5

activity AwaitStableLevel (lvl: bool, btnRaw: bool)
    var vote: nat8 = 0
    repeat
        run AwaitMsec(10)
        if btnRaw == lvl then
            vote = vote + 1 // Increment on match.
        elseif vote &amp;gt; 0 then
            vote = vote - 1 // Decrement on mismatch.
        end
    until vote &amp;gt;= DEBOUNCE end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In order to decide whether &lt;code&gt;lvl&lt;/code&gt; is stable or not this activity establishes a very simple voting strategy. Every 10 milliseconds (line 6) it checks the current state of the button signal. If it is equal to &lt;code&gt;lvl&lt;/code&gt; this is interpreted as &lt;em&gt;match&lt;/em&gt; whereby &lt;code&gt;vote&lt;/code&gt; gets incremented (lines 7 &amp;ndash; 8). If it is not equal this is interpreted as &lt;em&gt;no match&lt;/em&gt; whereby &lt;code&gt;vote&lt;/code&gt; gets decremented (lines 9 &amp;ndash; 10).&lt;/p&gt;
&lt;p&gt;As soon as five consecutive matches have been detected the signal is considered stable &amp;ndash; the &lt;code&gt;repeat&lt;/code&gt; loop exits (line 12) and &lt;code&gt;AwaitStableLevel&lt;/code&gt; returns. Its runtime behaviour is illustrated in the oscilloscope capture below:&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 810px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;https://www.blech-lang.org/blog/2020/08/12/push-button-handling/oszi_sampling_stable_huc342981c798b1526a5beb30db2463e38_327713_800x0_resize_catmullrom_2.png&#34; width=&#34;800&#34; height=&#34;480&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
Oszilloscope capture of button sampling. CH1 shows the execution of the Blech code. Each peak is one run of the Blech tick function and hence constitutes one reaction respectively computation step according to the synchronous model of computation. CH4 is the raw button signal.
&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;
&lt;p&gt;Remember that &lt;code&gt;CH1&lt;/code&gt; shows the debug pin signal which is pulled high whenever Blech code is running. Each yellow peak is one run of the Blech tick function and hence constitutes one reaction respectively computation step according to the synchronous model of computation. In particular, it is the &lt;code&gt;run AwaitMsec(10)&lt;/code&gt; in &lt;code&gt;AwaitStableLevel&lt;/code&gt; that causes our Blech code to get executed periodically, thereby determining the sampling rate of the button signals. The scope capture verifies that above &lt;code&gt;repeat&lt;/code&gt; loop actually checks the current state of the button signal exactly every 10 milliseconds &amp;ndash; the correct temporal behaviour as expressed in our Blech code.&lt;/p&gt;
&lt;p&gt;At the bottom of the scope capture you can see an exemplary run of &lt;code&gt;run AwaitStableLevel(true, btnsRaw.bottom)&lt;/code&gt;. Remember that &lt;code&gt;CH4&lt;/code&gt; shows the physical output signal of &lt;code&gt;BOTTOM&lt;/code&gt; with inverted logic &amp;ndash; we await &lt;code&gt;true&lt;/code&gt; in our software, means 0V in hardware! As a consequence, the first two samples lead to a &lt;em&gt;no match&lt;/em&gt; while the next five samples are &lt;em&gt;matches&lt;/em&gt;. As soon as the fifth match has been captured the activity returns.&lt;/p&gt;
&lt;h3 id=&#34;filter-a-single-button-signal&#34;&gt;Filter a single button signal&lt;/h3&gt;
&lt;p&gt;Second, &lt;code&gt;FilterSignal&lt;/code&gt; is responsible for filtering the signal of a &lt;em&gt;single&lt;/em&gt; button. Input &lt;code&gt;btnRaw&lt;/code&gt; is a raw button signal, output &lt;code&gt;btn&lt;/code&gt;is the filtered one. Based on a simple &lt;code&gt;repeat&lt;/code&gt; loop (lines 2 &amp;ndash; 10), this activity continuously alternates &lt;code&gt;btn&lt;/code&gt; between the two possible button states &lt;code&gt;false&lt;/code&gt; (not pressed, line 3) and &lt;code&gt;true&lt;/code&gt; (pressed, line 7):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity FilterSignal (btnRaw: bool)(btn: bool)
    repeat
        btn = false
        // Await transition: false -&amp;gt; true
        run AwaitStableLevel(true, btnRaw)
        
        btn = true
        // Await transition: true -&amp;gt; false
        run AwaitStableLevel(false, btnRaw)
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;A transition from &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; is only done once the raw signal &lt;code&gt;btnRaw&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and considered stable. The same applies vice versa for the transition from &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. Checking the signal stability is done by &lt;code&gt;AwaitStableLevel&lt;/code&gt; as shown above.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
Note that &lt;code&gt;FilterSignal&lt;/code&gt; is completely hardware-independent. At development time, it does not need to know which hardware signal it is actually working on. It just implements the algorithm used for filtering a signal, irrespective of whether this signal belongs to button &lt;code&gt;TOP&lt;/code&gt;, &lt;code&gt;CENTER&lt;/code&gt; or &lt;code&gt;BOTTOM&lt;/code&gt; – it does not even have to be a button signal at all. This allows to reuse and instantiate the same reactive code for different hardware entities. In conventional approaches, this is usually hard to achieve.
&lt;/div&gt;

&lt;h3 id=&#34;filter-all-button-signals&#34;&gt;Filter all button signals&lt;/h3&gt;
&lt;p&gt;Third, &lt;code&gt;FilterButtons&lt;/code&gt; is responsible for filtering the signal of &lt;em&gt;all&lt;/em&gt; buttons. It is the top level activity with respect to filtering. Input &lt;code&gt;btnsRaw&lt;/code&gt; are the raw button signals as retrieved from the GPIOs, output &lt;code&gt;btns&lt;/code&gt; are the filtered button signals. Internally, this activity runs a dedicated filter activity for each individual button &amp;ndash; &lt;code&gt;TOP&lt;/code&gt;, &lt;code&gt;CENTER&lt;/code&gt; and &lt;code&gt;BOTTOM&lt;/code&gt;. These activities are concurrently composed in the same &lt;code&gt;cobegin&lt;/code&gt; block. So &lt;code&gt;FilterButtons&lt;/code&gt; is basically a wrapper for comfortably running three instances of &lt;code&gt;FilterSignal&lt;/code&gt; concurrently.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity FilterButtons (btnsRaw: ButtonStates)(btns: ButtonStates)
    cobegin
        run FilterSignal(btnsRaw.top)(btns.top)
    with
        run FilterSignal(btnsRaw.center)(btns.center)
    with
        run FilterSignal(btnsRaw.bottom)(btns.bottom)
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Later, in the &lt;code&gt;Main&lt;/code&gt; activity of our Blech program, we can concurrently run &lt;code&gt;FilterButtons&lt;/code&gt; with respect to the remaining code (see line 7 below). In each reaction, the filtered button signals &lt;code&gt;btns&lt;/code&gt; are automatically updated (written) by &lt;code&gt;FilterButtons&lt;/code&gt; in the first trail and can be used (read) by other activities in concurrent trails. Activity &lt;code&gt;Visualize&lt;/code&gt;, for example, uses the filtered button signals in order to reflect the current button states on the color LEDs (line 10 below).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;@[EntryPoint]
activity Main (btnRaw: ButtonStates) (leds: LedStates)
    // ...
    var btns: ButtonStates
    cobegin
        // FilterButtons all button states.
        run FilterButtons(btnRaw)(btns)
    with
        // Visualizes all button states.
        run Visualize(btns)(leds.orange, leds.green, leds.blue)
    // ... 
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;event-detection-and-reaction&#34;&gt;Event detection and reaction&lt;/h2&gt;
&lt;p&gt;Above sections show how raw button signals can be filtered in Blech. Now, we want to use the filtered signals &lt;code&gt;btns&lt;/code&gt; for detecting button events and performing a corresponding reaction. For this purpose, we have implemented some example activities that show different application use cases.&lt;/p&gt;
&lt;p&gt;In each example, we want to detect a certain type of button event and, as an example of an arbitrary event reaction, turn on the red LED of the discovery board. After a certain release condition is met, the red LED is turned off again.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
At this point, the example activities do not have to care about signal glichtes, noise, bouncing or filtering in any way. In each reaction, they can fully rely on the output of the “upstream” filter activities – so to speak – and just focus on their own business. This means that both concerns, signal filtering and signal evaluation, are completely separated in our Blech program.
&lt;/div&gt;

&lt;h3 id=&#34;example-1-press-button-for-at-least-x-seconds&#34;&gt;Example 1: Press button for at least &lt;em&gt;x&lt;/em&gt; seconds&lt;/h3&gt;
&lt;p&gt;In this example, the LED shall light up once &lt;code&gt;CENTER&lt;/code&gt; has been pressed for at least two seconds. It shall stay on as long as the button is pressed and go off once it has been released.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity Example01 (btns: ButtonStates) (led: bool)
    when not btns.center reset
        await btns.center
        run AwaitMsec(2000)
    end
    led = true
    await not btns.center
    led = false
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The first step is to wait until the button is pressed (line 3). After that, we use &lt;code&gt;AwaitMsec&lt;/code&gt; in order to wait until two seconds have elapsed. If the button should be released meanwhile we automatically restart the process by taking advantage of Blech&amp;rsquo;s &lt;code&gt;when ... reset&lt;/code&gt; block (line 2).&lt;/p&gt;
&lt;p&gt;Once control flow reaches line 6, we know that &lt;code&gt;CENTER&lt;/code&gt; has been pressed for two seconds and hence turn on the LED. Finally, we wait for the button to be released (line 7) and turn off the LED (line 8) as a consequence.&lt;/p&gt;
&lt;h3 id=&#34;example-2-two-buttons-have-to-be-pressed&#34;&gt;Example 2: Two buttons have to be pressed&lt;/h3&gt;
&lt;p&gt;In this example, the LED shall light up once &lt;code&gt;TOP&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;BOTTOM&lt;/code&gt; are pressed. After that, it shall be turned off as soon as &lt;em&gt;both&lt;/em&gt; buttons have been released.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity Example02 (btns: ButtonStates) (led: bool)
    await btns.top and btns.bottom
    led = true
    await (not btns.top) and (not btns.bottom)
    led = false
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;This implementation is trivial in Blech. In line 2, we wait until both buttons are pressed, then turn on the LED (line 3). Subsequently, we wait until none of the buttons are pressed (line 4) and finally turn off the LED (line 5).&lt;/p&gt;
&lt;p&gt;The simplicity of this piece of code is caused by the fact that we do not care about timing in this example. No matter when or how long the buttons are pressed, we only have to check whether their is at least one reaction in which both button signals are &lt;code&gt;true&lt;/code&gt;. For detecting a real-world double button press a more sophisticated approach is usually required. We demonstrate this in &lt;a href=&#34;#example-3-double-button-press&#34;&gt;Example 3&lt;/a&gt;
.&lt;/p&gt;
&lt;h3 id=&#34;example-3-double-button-press&#34;&gt;Example 3: Double button press&lt;/h3&gt;
&lt;p&gt;In this example, the LED shall light up if a &lt;em&gt;double press&lt;/em&gt; of &lt;code&gt;TOP&lt;/code&gt; and &lt;code&gt;BOTTOM&lt;/code&gt; is detected. After that, it shall be turned off once both buttons have been released. In contrast to &lt;a href=&#34;#example-2-two-buttons-have-to-be-pressed&#34;&gt;Example 2&lt;/a&gt;
, here it is important that both buttons are pressed within a certain amount of time. For example, we only accept a double press if the time gap between the two button presses is one second at most.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;18
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;19
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;20
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;21
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;22
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;23
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity Example03 (btns: ButtonStates) (led: bool)
    let acceptedDelay: nat16 = 1000 // in milliseconds.
    var success: bool
    repeat
        success = false
        await (not btns.top) and (not btns.bottom)
        await btns.top or btns.bottom

        if btns.top and btns.bottom then
            // Double press already detected.
            success = true
        elseif btns.top and not btns.bottom then
            // Await BOTTOM within delay.
            success = run AwaitOtherButton(btns.top, btns.bottom, acceptedDelay)
        elseif not btns.top and btns.bottom then
            // Await TOP within delay.
            success = run AwaitOtherButton(btns.bottom, btns.top, acceptedDelay)
        end
    until success end

    led = true
    await (not btns.top) and (not btns.bottom)
    led = false
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The &lt;code&gt;repeat&lt;/code&gt; loop in line 4 is used to check for the double press. First, we await the idle state &amp;ndash; both buttons are not pressed. Second, we wait until at least one of the buttons has been pressed (line 7). Subsequently, we handle the different, possible scenarios:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Line 9: Both buttons are pressed. In this case, the double press is already detected. However, this case might be quite rare since it is difficult to perfectly push down both buttons at the same time so that they will be pressed in the same reaction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Line 12: &lt;code&gt;TOP&lt;/code&gt; is pressed, &lt;code&gt;BOTTOM&lt;/code&gt; not yet. In this case, we use &lt;code&gt;AwaitOtherButton&lt;/code&gt; in order to await &lt;code&gt;BOTTOM&lt;/code&gt; to get pressed within the accepted delay of one second. On success &lt;code&gt;repeat&lt;/code&gt; exits. The implementation of &lt;code&gt;AwaitOtherButton&lt;/code&gt; is shown below.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Line 15: Same as in (2) but &lt;code&gt;TOP&lt;/code&gt; and &lt;code&gt;BOTTOM&lt;/code&gt; are exchanged.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In any case, once the repeat loop has been left, we know that a valid double press has been detected and hence turn on the LED. Finally, we wait until both buttons have been release and turn off the LED.&lt;/p&gt;
&lt;p&gt;The helper activity &lt;code&gt;AwaitOtherButton&lt;/code&gt; demonstrates &lt;a href=&#34;#timeout&#34;&gt;timeout handling&lt;/a&gt;
 in Blech. We want to know if the second button &lt;code&gt;btn2&lt;/code&gt; is pressed within the given amount of milliseconds (&lt;code&gt;msec&lt;/code&gt;) and while the first button &lt;code&gt;btn1&lt;/code&gt; is still pressed. So there are actually two conditions to be checked &amp;ndash; the timeout and the current state of &lt;code&gt;btn1&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity AwaitOtherButton (btn1: bool, btn2: bool, msec: nat16) returns bool
    var success: bool = false
    when not btn1 abort
        cobegin weak
            await btn2
            success = true
        with weak
            run AwaitMsec(msec)
        end
    end
    return success
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;For the first condition, we basically apply the same approach as &lt;a href=&#34;#timeout&#34;&gt;described above&lt;/a&gt;
 using a concurrent composition (line 4). Note that both trails are &lt;code&gt;weak&lt;/code&gt; so that they can abort each other. Result variable &lt;code&gt;success&lt;/code&gt; is only set to &lt;code&gt;true&lt;/code&gt; (line 6) if the button press happens before the timeout. If there is a timeout &amp;ndash; means &lt;code&gt;run AwaitMsec(msec)&lt;/code&gt; returns &amp;ndash; the &lt;code&gt;cobegin&lt;/code&gt; rejoins and &lt;code&gt;success&lt;/code&gt; is still &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For the second condition, we surround the concurrent composition with a &lt;code&gt;when ... abort&lt;/code&gt; block that monitors the state of &lt;code&gt;btn1&lt;/code&gt;. Once it is not pressed anymore the entire block aborts, again leaving &lt;code&gt;success&lt;/code&gt; untouched (&lt;code&gt;false&lt;/code&gt;). Finally, &lt;code&gt;AwaitOtherButton&lt;/code&gt; returns the result which is then used by the caller to decide whether the second button has been pressed in time or not.&lt;/p&gt;
&lt;h3 id=&#34;example-4-measure-the-button-press-duration&#34;&gt;Example 4: Measure the button press duration&lt;/h3&gt;
&lt;p&gt;In this example, the LED shall light up if &lt;code&gt;CENTER&lt;/code&gt; has been pressed between one and two seconds. After that, the LED shall be turned off once &lt;code&gt;TOP&lt;/code&gt; has been pressed.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity Example04 (btns: ButtonStates) (led: bool)
    var i: nat32 = 0
    repeat
        await btns.center
        when not btns.center abort
            repeat
                run AwaitMsec(10)
                i = i + 1
            end
        end
    until i &amp;gt;= 1000 and i &amp;lt;= 2000 end

    led = true
    await btns.top
    led = false
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In contrast to the other examples above, we actually measure the button press duration here. For this, we use two &lt;code&gt;repeat&lt;/code&gt; loops.&lt;/p&gt;
&lt;p&gt;The inner loop (lines 6 &amp;ndash; 9) is used to measure the duration of the current button press which has been detected in line 4. It repeatedly awaits 10 milliseconds and increments the counter &lt;code&gt;i&lt;/code&gt; for measuring the duration. The surrounding &lt;code&gt;when ... abort&lt;/code&gt; automatically exits the inner loop as soon as the button is not pressed anymore. The outer loop (lines 3 &amp;ndash; 11) is used to check whether &lt;code&gt;i&lt;/code&gt; is in the desired time interval or not. If not, the entire process repeats.&lt;/p&gt;
&lt;p&gt;Once we hit line 13 we know that the current button press matches the given time interval. Consequently, the LED is switched on. Finally, we wait until &lt;code&gt;TOP&lt;/code&gt; has been pressed in order to turn off the LED again.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The below diagram depicts the architecture of the Blech program as function blocks. Moving from left to right, the three raw button signals &lt;code&gt;btnsRaw&lt;/code&gt; are handed over from the C environment to the &lt;code&gt;Main&lt;/code&gt; activity of Blech. At this point, they are forwared to the filter activity &lt;code&gt;FilterButtons&lt;/code&gt; which, in its turn, passes each raw signal to a dedicated instance of &lt;code&gt;FilterSignal&lt;/code&gt; likewise. The latter internally uses &lt;code&gt;AwaitStableLevel&lt;/code&gt; for the actual filter process. Finally, the filtered signals &lt;code&gt;btns&lt;/code&gt; are provided to the remaining, concurrent Blech code, e.g. &lt;code&gt;Visualize&lt;/code&gt; for controlling the color LEDs or one of our &lt;code&gt;Example&lt;/code&gt; activities as described above.&lt;/p&gt;
&lt;p&gt;Note that &lt;code&gt;FilterButtons&lt;/code&gt; and &lt;code&gt;FilterSignal&lt;/code&gt; will never terminate. They are designed to run infinitely throughout the entire livetime of the Blech program. In contrast, &lt;code&gt;AwaitStableLevel&lt;/code&gt; is called several times during runtime and terminates whenever the desired signal level is stable.&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 810px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;https://www.blech-lang.org/blog/2020/08/12/push-button-handling/hw_blocks_hu64dc87d3761fbcee9634b55743ec1f87_37050_800x0_resize_catmullrom_2.png&#34; width=&#34;800&#34; height=&#34;544&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
Architecture of the Blech program as function blocks.
&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;
&lt;p&gt;Last but not least, the block diagram shows that, on the top level, our Blech program behaves like a &lt;em&gt;reactive control block&lt;/em&gt;. It receives the raw button signals as inputs, processes them based on events (and time) and finally outputs the corresponding control signals for the color LEDs.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: The basic idea behind Blech – A practitioner&#39;s point of view</title>
      <link>https://www.blech-lang.org/blog/2020/07/22/the-basic-idea-behind-blech-a-practitioners-point-of-view/</link>
      <pubDate>Wed, 22 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/blog/2020/07/22/the-basic-idea-behind-blech-a-practitioners-point-of-view/</guid>
      <description>
        
        
        &lt;h2 id=&#34;application-example-uart-communication&#34;&gt;Application example: UART communication&lt;/h2&gt;
&lt;p&gt;Let us consider a simple embedded use case. We want to implement a &lt;a href=&#34;https://de.wikipedia.org/wiki/Universal_Asynchronous_Receiver_Transmitter&#34; target=&#34;_blank&#34;&gt;UART&lt;/a&gt;
 communication. For the sake of simplicity, we focus on the data transmission only. Given a number of bytes in a data buffer, the job is to physically send them via the serial interface one after the other.&lt;/p&gt;
&lt;p&gt;The implementation is to be done on the bare metal; no operating system, no fancy hardware abstraction layers or library functions. That means that, in our example, the UART peripherial is directly controlled via its hardware registers. Writing a byte to the register &lt;code&gt;UART1-&amp;gt;DR&lt;/code&gt; causes the UART hardware interface to send that byte over the wire. While the transmission is in progress, the flag &lt;code&gt;UART1_FLAG_TXE&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. The interface will automatically set the flag to &lt;code&gt;false&lt;/code&gt; after it has finished sending the byte. At that time, it can also trigger an interrupt to indicate that the job is done.&lt;/p&gt;
&lt;p&gt;Apart from the sole functional correctness it is important that the application is generally compatible with the stringent constraints of the embedded domain. That is, very limited resources &amp;ndash; &lt;em&gt;computation time&lt;/em&gt; and &lt;em&gt;memory&lt;/em&gt; &amp;ndash; and possible &lt;em&gt;realtime requirements&lt;/em&gt;. Keeping the embedded software reactive is key in order to handle realtime-critical events in time.&lt;/p&gt;
&lt;p&gt;Below sections discuss different implementation schemes in C and Blech for realizing the buffer transmission.&lt;/p&gt;
&lt;h2 id=&#34;implementation-schemes-in-c&#34;&gt;Implementation schemes in C&lt;/h2&gt;
&lt;p&gt;In the following section we consider the pros and cons of two popular programming styles for implementing the UART communication in C. The focus is on software engineering and suitability for the embedded domain.&lt;/p&gt;
&lt;h3 id=&#34;the-blocking-style&#34;&gt;The blocking style&lt;/h3&gt;
&lt;p&gt;Let us assume that we &amp;ndash; as software developers &amp;ndash; do not have any experience in writing embedded code and we do not know anything about the stringent constraints imposed by the embedded domain. We just (naively) start by implementing a function &lt;code&gt;send_buffer&lt;/code&gt; that encapsulates all the details required for data transmission. This approach is reasonable and natural because this is what we have been taught in school and at the university. Motivated by several fundamental software engineering principles such as abstraction, separation of concerns, encapsulation and so forth we develop the solution below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;send_buffer&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;u8&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;u16&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;u16&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;++&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UART1_FLAG_TXE&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;UART1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DR&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;We pass the buffer and its length to the function. Then, we loop over the buffer. For each byte, we first wait for the UART device to become ready, second copy the next byte into the UART data register and third check whether or not we have reached the end of the buffer &amp;ndash; it is as simple as that.&lt;/p&gt;
&lt;p&gt;In this approach, everything related to the transmission is &lt;em&gt;local&lt;/em&gt;. With local I not only mean the data in sense of local variables. I also mean the code &amp;ndash; the knowledge &amp;ndash; that is required to describe all necessary steps that have to be done. This makes it not only easy to comprehend how the transmission actually works but also facilitates its usage, debugging and maintenance. If something is not working as expected or if we want to change or extend the procedure in some way we know that &lt;code&gt;send_buffer&lt;/code&gt; is the sole code block to look at.&lt;/p&gt;
&lt;p&gt;However, there is a high price to be paid in order to obtain above encapsulation benefits. If we want to encapsulate the transmission of an entire buffer &amp;ndash; and not only of single bytes &amp;ndash; a call of &lt;code&gt;send_buffer&lt;/code&gt; must inevitably outlive the transmission of multiple bytes. For this, its code has to be implemented in a &lt;em&gt;blocking&lt;/em&gt; fashion so that it does not terminate once a single byte has been sent out. This becomes apparent from Line 5 in which we wait for the UART device to finish the transmission of the current byte. A &lt;code&gt;while&lt;/code&gt; loop polls the corresponding UART flag in order to block the control flow of &lt;code&gt;send_buffer&lt;/code&gt; before it proceeds with the next byte. The runtime behaviour of &lt;code&gt;send_buffer&lt;/code&gt; is exemplarily depicted below:&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 810px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;https://www.blech-lang.org/blog/2020/07/22/the-basic-idea-behind-blech-a-practitioners-point-of-view/oszi_1_hu7a477f07b182b110426619a64863e79e_99242_800x0_resize_catmullrom_2.png&#34; width=&#34;800&#34; height=&#34;217&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
Exemplary scope capture of three byte transmission with software in polling mode.
&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;
&lt;p&gt;Above example scope capture shows the transmission of a 3-byte buffer. &lt;code&gt;SW&lt;/code&gt; indicates when the CPU is busy (&lt;code&gt;SW -&amp;gt; HIGH&lt;/code&gt;) with executing &lt;code&gt;send_buffer&lt;/code&gt; while &lt;code&gt;TX&lt;/code&gt; shows the physical output signal of the UART hardware. It is easy to see that the entire processing time is eaten up by &lt;code&gt;send_buffer&lt;/code&gt; until the last byte has been sent out. This causes several drawbacks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The thread calling &lt;code&gt;send_buffer&lt;/code&gt; is blocked for anything else. No other code can run concurrently so that
&lt;ul&gt;
&lt;li&gt;no other concerns of the embedded system can be processed.&lt;/li&gt;
&lt;li&gt;no other (important) events can be handled meanwhile.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The CPU continuously runs at full speed leading to high consumption of processing time and energy.&lt;/li&gt;
&lt;li&gt;The call stack of &lt;code&gt;send_buffer&lt;/code&gt; is not freed so that memory cannot be reused for other concerns meanwhile.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remember that, depending on the UART baudrate and the length of the buffer, above conditions can be true for a significant period of time. Consider a typical UART baudrate of 115.200bit/s and a buffer length of 1024bit. In this case, one execution of &lt;code&gt;send_buffer&lt;/code&gt; would already block your software for 8.88 milliseconds &amp;ndash; a small eternity in the embedded domain! Thus, in sum, this approach leads to &lt;em&gt;poor reactivity&lt;/em&gt; and &lt;em&gt;high resource consumption&lt;/em&gt;.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;As a conclusion we can say that the &lt;em&gt;blocking style&lt;/em&gt; makes it generally&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;easy&lt;/strong&gt; to fulfil software engineering principles.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hard&lt;/strong&gt; to fulfil constraints of the embedded domain.&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;

&lt;h3 id=&#34;the-event-based-style&#34;&gt;The event-based style&lt;/h3&gt;
&lt;p&gt;Due to above limitations, practically all embedded software solutions decide in favour of the stringent embedded constraints and follow a non-blocking, &lt;em&gt;event-based&lt;/em&gt; style instead. In this approach, code is executed only if necessary. That is, whenever an &lt;em&gt;event&lt;/em&gt; &amp;ndash; a noteable change of the environment &amp;ndash; has happened.&lt;/p&gt;
&lt;p&gt;Event-driven behaviour, however, is not supported by C on language level. Typical workarounds rely on &lt;em&gt;statemachines&lt;/em&gt; and &lt;em&gt;callbacks&lt;/em&gt; that are executed in an asynchronous-concurrent fashion. See the example below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;18
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;u8&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;u16&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_len&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;u16&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_tx&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;ISR&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UART1_TX&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;_tx&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;++&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;_tx&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_len&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;UART1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DR&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;_tx&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;send_buffer&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;u8&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;u16&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UART1_FLAG_TXE&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;_buf&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;_len&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;_tx&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;UART1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DR&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;_tx&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In this solution, &lt;code&gt;send_buffer&lt;/code&gt; is only used to &lt;em&gt;initiate&lt;/em&gt; the buffer transfer. It waits for the UART device to become ready, saves the buffer, its length and a transmission counter as global variables, and finally writes the first buffer byte into the UART data register. Then, in contrast to the blocking style above, &lt;code&gt;send_buffer&lt;/code&gt; immediately terminates although not even a single byte has been actually transmittet yet.&lt;/p&gt;
&lt;p&gt;Once the first byte has physically left the UART device, the hardware automatically executes the interrupt service routine in Line 12 which picks the next byte from the buffer and triggers its transmission. This process repeats for each byte until the entire buffer has been transferred. Ultimately, the buffer transmission is driven by a chain of callbacks that advances the progress step by step. The corresponding runtime behaviour of this approach is shown below:&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 810px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;https://www.blech-lang.org/blog/2020/07/22/the-basic-idea-behind-blech-a-practitioners-point-of-view/oszi_2_hue664559e19091397989b194e3be32ca9_97431_800x0_resize_catmullrom_2.png&#34; width=&#34;800&#34; height=&#34;217&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
Exemplary scope capture of three byte transmission with software in event-driven mode.
&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;
&lt;p&gt;This time, the CPU is only busy when a new byte transmission is to be triggered. Meanwhile it could either process other concerns, react on other events or go to sleep in order to save energy. Since &lt;code&gt;send_buffer&lt;/code&gt; terminates after each byte its stack space is freed and can be easily reused for something else. By this, the event-driven approach perfectly fits the embedded domain.&lt;/p&gt;
&lt;p&gt;However, all the valuable software engineering benefits of the blocking approach are gone. The functionality &amp;ldquo;buffer transmission&amp;rdquo; is now torn apart a function, an interrupt service routine and a set of global variables. This eliminates locality and requires me &amp;ndash; the software developer &amp;ndash; to implement &lt;em&gt;manual stack&lt;/em&gt; and &lt;em&gt;state management&lt;/em&gt; in order to maintain the program state across several function and ISR calls respectively.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
Remember that stack and state management are actually low-level tasks done by the &lt;a href=&#34;https://de.wikipedia.org/wiki/Prozessor&#34; target=&#34;_blank&#34;&gt;CPU&lt;/a&gt;
, using a program counter and a set of working registers, in order to reduce the burden of the software developer. Now, with statemachines and callbacks, we have to do this tedious and error-prone job in my high-level programming realm &amp;ndash; doesn&amp;rsquo;t that sound kind of inherently contradictory and counterproductive?
&lt;/div&gt;

&lt;p&gt;All the data (the stack) that has to outlive multiple function calls, e.g. the pointer of the buffer, the buffer length and the transmission counter, have to be stored in global memory. The latter by itself entails a whole line up of engineering drawbacks. In addition, the asynchronous event-driven execution of &lt;code&gt;send_buffer&lt;/code&gt; and the interrupt service routine provokes concurrency bugs and non-deterministic runtime behaviour by design. By the way, what will happen if &lt;code&gt;send_buffer&lt;/code&gt; is called while a buffer transmission is still ongoing?&lt;/p&gt;
&lt;p&gt;The progress of the program (the state) is encoded in a statemachine that advances on each event. On the one hand, statemachines are generally a very efficient and well understood technology in order to describe and execute event-driven behaviour for and by &lt;em&gt;machines&lt;/em&gt; respectively. But, on the other hand, statemachines are less suitable for &lt;em&gt;humans&lt;/em&gt;, especially when it comes to readability and comprehensibility.&lt;/p&gt;
&lt;p&gt;In statemachines, &lt;em&gt;state is explicit&lt;/em&gt; while &lt;em&gt;control flow is implicit&lt;/em&gt;. This makes it easy to generically describe and perform single computation steps by transition tables based on the current state and the current input. But for us &amp;ndash; as software developers &amp;ndash; this is &lt;em&gt;not&lt;/em&gt; the natural understanding with what we have grown up. We are used to write code in a sequential fashion in which control flow is paramount. State is only implicitly given by the current code line that is to be executed and the set of variables. When looking at a statemachine implementation, irrespective of whether it is given as C code or a graphical drawing, it is generally difficult to comprehend the sequence of decisions and commands that have to be taken and executed in order to realize a certain functionality.&lt;/p&gt;
&lt;p&gt;Finally, think about how you would establish automated tests for this kind of code. You could write unit tests for each of the functions &amp;ndash; which is by itself not easy because they internally rely on global variables &amp;ndash; but this only covers the behaviour of your software on a per event basis. With this approach, it is really difficult to systematically test the behaviour over time across several reactions. Not only because the code is highly distributed but also because the runtime behaviour is inherently non-deterministic and hence not reproducible.&lt;/p&gt;
&lt;p&gt;To sum it up, the event-based style encourages software solutions that are difficult to program, comprehend, test and maintain.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;As a conclusion we can say that the &lt;em&gt;event-based style&lt;/em&gt; makes it generally&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;hard&lt;/strong&gt; to fulfil software engineering principles.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;easy&lt;/strong&gt; to fulfil constraints of the embedded domain.&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;

&lt;h2 id=&#34;lifting-the-abstraction-level----the-pseudo-blocking-style&#34;&gt;Lifting the abstraction level &amp;ndash; the pseudo-blocking style&lt;/h2&gt;
&lt;p&gt;Looking back to above implementation schemes the following becomes apparent:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The blocking style, on the one hand, typically leads to good software quality but is generally not applicable in the embedded domain.&lt;/li&gt;
&lt;li&gt;The event-driven style, on the other hand, perfectly matches the stringent embedded constraints but it seems that we figuratively fallback to a lower level of programming.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What if we lived in a &lt;em&gt;perfect world&lt;/em&gt; where we could cherry-pick and combine the advantages of both approaches? &amp;ndash; Welcome to Blech!&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Basic Idea&lt;/h4&gt;
The basic idea behind Blech is to let the software developer write code in a &lt;em&gt;blocking fashion&lt;/em&gt; (good software quality) and systematically compile it into an efficient, deterministic, &lt;em&gt;event-driven&lt;/em&gt; statemachine implementation (fit embedded domain). By this, Blech code allows to recover all the software engineering advantages mentioned above and, at the same time, fulfills the stringent embedded constraints. This combination is usually hard to achieve and makes Blech &lt;em&gt;lifting embedded programming to a higher level of abstraction&lt;/em&gt;.
&lt;/div&gt;

&lt;p&gt;This concept is what I call the &lt;em&gt;pseudo-blocking&lt;/em&gt; style. Your software looks and logically behaves like blocking code but is actually non-blocking under the hood. On the bare metal, it can easily interleave its execution with other synchronous or asynchronous parts of your software. For example, there could be some cryptographic algorithm asynchronously running in a background task while your Blech program continously reacts on incoming events.&lt;/p&gt;
&lt;p&gt;The following code snippet shows how the buffer transmission can look like in Blech:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;@[CFunction (binding = &amp;#34;UART_isReady&amp;#34;, header = &amp;#34;uart.h&amp;#34;)]
extern singleton function uart_isReady() returns bool
@[CFunction (binding = &amp;#34;UART_sendByte&amp;#34;, header = &amp;#34;uart.h&amp;#34;)]
extern singleton function uart_sendByte(val: nat8)

const LEN: nat16 = 20

activity SendBuffer (buf: [LEN]nat8, len: nat16)
    var i: nat16 = 0
    repeat
        await uart_isReady()
        uart_sendByte(buf[i])
        i = i + 1
    until (i &amp;gt;= len) or (i &amp;gt;= LEN) end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In the first four lines we declare the signatures of two external C functions that can be called by Blech in order to actually interact with the UART hardware. After that, an &lt;em&gt;activity&lt;/em&gt; is used to encapsulate all the data transmission code. We pass the buffer and its length as parameters. A &lt;code&gt;repeat&lt;/code&gt; loop is subsequently used to&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;suspend the activity until the UART is ready for transmission (Line 11).&lt;/li&gt;
&lt;li&gt;write the next buffer byte to the UART data register (Line 12).&lt;/li&gt;
&lt;li&gt;repeat from (1) until the end of buffer has been reached.&lt;/li&gt;
&lt;/ol&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
In the C environment, &lt;code&gt;ISR (UART1_TX)&lt;/code&gt; is used to generate an event for triggering the Blech program. This means that &lt;code&gt;await uart_isReady()&lt;/code&gt; will return as soon as possible after a byte has been transmitted &amp;ndash; we do not have to wait until the next periodic &lt;code&gt;sysTick&lt;/code&gt; for instance.
&lt;/div&gt;

&lt;p&gt;You may have already noticed that this solution looks very similar compared to the blocking style above. In fact, it has all of its software engineering benefits but none of its drawbacks. Above Blech code is translated by the Blech compiler into an event-driven state machine implementation that only logically simulates the blocking behaviour of &lt;code&gt;await&lt;/code&gt; for the software developer while your code actually remains reactive all the time. By this, the Blech solution effectively combines the advantages of both implementation schemes known from C.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;As a conclusion we can say that the &lt;em&gt;pseudo-blocking style&lt;/em&gt; makes it generally&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;easy&lt;/strong&gt; to fulfil software engineering principles.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;easy&lt;/strong&gt; to fulfil constraints of the embedded domain.&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;

&lt;h2 id=&#34;concurrency-in-blech&#34;&gt;Concurrency in Blech&lt;/h2&gt;
&lt;p&gt;Concurrency is one of the key concerns in embedded programming. The traditional, asynchronous execution style of concurrent threads is known to induce a line-up of engineering problems such as race conditions, data inconsistencies, potential deadlocks and non-deterministic runtime behaviour. In Blech, however, all these issues are eliminated by language design due to the synchronous model of computation.&lt;/p&gt;
&lt;p&gt;Let us slightly extend above example. We want to make an LED blink on every system tick, e.g. every millisecond, while a buffer transmission is in progress. At this point, we are aware that blinking an LED with such a high frequency is generally not useful since it is not visible for the human eye. Here, we just use it for demonstration purpose to show how easy it is to express concurrent behaviour by taking advantage of Blech&amp;rsquo;s &lt;code&gt;cobegin&lt;/code&gt; statement:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity SendBufferBlinking (buf: [LEN]nat8, len: nat16, sysTick: bool)(led: bool)
    cobegin   // Buffer transmission.
        run SendBuffer(buf, len)
    with weak // LED flashing.
        repeat
            led = false
            await sysTick
            led = true
            await sysTick
        end
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In &lt;code&gt;SendBufferBlinking&lt;/code&gt;, we just need to run the existing code of &lt;code&gt;SendBuffer&lt;/code&gt; in one trail of the &lt;code&gt;cobegin&lt;/code&gt; and add a second, concurrent trail that is responsible for flashing the LED &amp;ndash; that&amp;rsquo;s it. The second trail is &lt;code&gt;weak&lt;/code&gt; so that it will be aborted as soon as the buffer transmission in the first trail has been completed. Note that &lt;code&gt;sysTick&lt;/code&gt; is a new input which provides the system tick event for switchting the LED on and off.&lt;/p&gt;
&lt;h3 id=&#34;concurrency-versus-single-threaded-c-code----a-contradiction&#34;&gt;Concurrency versus single-threaded C code &amp;ndash; a contradiction?&lt;/h3&gt;
&lt;p&gt;At this point, when people read that any Blech program is compiled into &lt;em&gt;single-threaded&lt;/em&gt; C code, they are sometimes slightly confused. On the one hand, Blech advertises language level support for describing concurrent behaviour but, at the same time, it produces sequential, single-threaded code only. So how can that even work?&lt;/p&gt;
&lt;p&gt;In order to understand this we have to distinguish between two different designs of concurrency. First, &lt;em&gt;physical concurrency&lt;/em&gt; aims to increase reliability and / or performance by running software on real parallel or distributed hardware platforms, e.g. multi-core architectures, at the same time. Second, &lt;em&gt;logical concurrency&lt;/em&gt; aims to provide a convenient and natural way to compose a system as a set of parallel, cooperating components. Physical and logical concurrency can be the same &amp;ndash; but they do not have to!&lt;/p&gt;
&lt;p&gt;Blech, in its current development state, allows to express logical concurrency only. The long term goal, however, is to provide support for multi-core systems and hence physical concurrency on language level too. Nevertheless, the existing feature set of Blech is powerful and beneficial already today.&lt;/p&gt;
&lt;h3 id=&#34;single-core-applications&#34;&gt;Single-core applications&lt;/h3&gt;
&lt;p&gt;Single-core hardware architectures exclude physical concurrency by design. This means that, even with asynchronous threads, it is impossible to execute two commands concurrently at the same time; the entire software is strictly sequential. As a consequence, on single-core architectures, Blech has no disadvantages compared to conventional solutions with respect to concurrency.&lt;/p&gt;
&lt;p&gt;Quite the contrary, in Blech the sequentialization is done systematically &lt;em&gt;during compile time&lt;/em&gt; based on the synchronous model of computation &amp;ndash; no non-deterministic scheduling decisions during runtime; no arbitrary interleavings of concurrent code; no race conditions and data inconsistencies. Finally, this leads to sequential code with deterministic and reproducible runtime behaviour &amp;ndash; &lt;em&gt;the&lt;/em&gt; major advantage that makes Blech outperform conventional, asynchronous languages in the embedded domain.&lt;/p&gt;
&lt;h3 id=&#34;multi-core-applications&#34;&gt;Multi-core applications&lt;/h3&gt;
&lt;p&gt;In multi-core applications where physical concurrency is mandatory Blech is still applicable. Considering a dual-core processor for example, we can have two instances of either the same or different Blech programs where each of them is running on a different core! By this, we basically create two &lt;em&gt;synchronous islands&lt;/em&gt; &amp;ndash; so to speak &amp;ndash; that locally benefit from executing synchronous code while, from a global view, running asynchronously with respect to each other. This solution is particularly suitable for applications in which the concerns handled by core A constitute a high independence with respect to those of core B and vice versa.&lt;/p&gt;
&lt;p&gt;What we cannot express in Blech today is concurrent runtime behaviour across multiple cores. That is, the &lt;code&gt;cobegin&lt;/code&gt; statement cannot be used to describe how two concurrent trails, for example, are to be deployed, started, executed and rejoined across two different processor cores. But remember that this is not possible with threads too! The notion of threads does not say anything about how data and control flow is shared between multiple, concurrent hardware architectures.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Decoding the DCF77 signal with Blech</title>
      <link>https://www.blech-lang.org/blog/2020/06/15/decoding-the-dcf77-signal-with-blech/</link>
      <pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/blog/2020/06/15/decoding-the-dcf77-signal-with-blech/</guid>
      <description>
        
        
        &lt;h2 id=&#34;what-is-dcf77&#34;&gt;What is DCF77?&lt;/h2&gt;
&lt;p&gt;DCF77 is a longwave radio signal which is widely used in Germany for time synchronization of clocks and watches. The signal transmitter is located in Mainflingen (Germany) and controlled by the Physikalisch-Technische Bundesanstalt (PTB).&lt;/p&gt;
&lt;p&gt;Information about the current time and date are modulated in a binary fashion onto a 77.5kHz radio carrier signal. On each second a so called &lt;em&gt;second mark&lt;/em&gt; is transmitted by reducing the carrier power for a certain amount of time. The duration of the reduction encodes either a &lt;em&gt;binary zero&lt;/em&gt; (100ms) or a &lt;em&gt;binary one&lt;/em&gt; (200ms). After a complete time code &amp;ndash; a sequence of 59 bits &amp;ndash; the process is repeated every full minute. For the 60th second there is no level change. This gap aids as a &lt;em&gt;synchronization mark&lt;/em&gt; for indicating the end of the current time code.&lt;/p&gt;
&lt;p&gt;Please refer to the &lt;a href=&#34;https://www.ptb.de/cms/en/ptb/fachabteilungen/abt4/fb-44/ag-442/dissemination-of-legal-time/dcf77.html&#34; target=&#34;_blank&#34;&gt;homepage of the PTB&lt;/a&gt;
 for further details about the technical setup and the time code of DCF77.&lt;/p&gt;
&lt;h2 id=&#34;application-example-dcf77-decoder&#34;&gt;Application example: DCF77 decoder&lt;/h2&gt;
&lt;p&gt;Our goal is to implement a simple DCF77 decoder based on a &lt;a href=&#34;https://www.st.com/en/evaluation-tools/stm32f4discovery.html&#34; target=&#34;_blank&#34;&gt;STM32F4DISCOVERY&lt;/a&gt;
 board. For the user interface we use the on-board LEDs and push button. The application shall behave as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;After power-up the application waits until the DCF77 signal is stable. During this time all LEDs are turned on.&lt;/li&gt;
&lt;li&gt;When the signal ist stable the decoding process starts automatically. All LEDs are turned off.&lt;/li&gt;
&lt;li&gt;While the decoding is running the blue LED visualizes the current level of the time signal. If the signal is &lt;code&gt;HIGH&lt;/code&gt; the LED is turned off and vice versa. This means whenever a new second mark has been received the LED lights up for 100 or 200 milliseconds.&lt;/li&gt;
&lt;li&gt;As soon as the synchronization mark has been captured the orange LED is turned on. This shows that capturing the time code is now actually in progress.&lt;/li&gt;
&lt;li&gt;Finally, if the decoding has been successfully completed the green LED lights up while the orange one goes off. In case of an error the decoding stops immediately and the red LED is turned on.&lt;/li&gt;
&lt;li&gt;Irrespective of success or error the user has to press the button in order to start a new decoding process.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In order to receive the DCF77 time signal an additional receiver module &amp;ndash; similar to &lt;a href=&#34;https://www.reichelt.de/dcf-77-receiver-module-dcf77-modul-p57772.html?&amp;amp;nbc=1&#34; target=&#34;_blank&#34;&gt;this&lt;/a&gt;
 one &amp;ndash; is required. It basically receives and transforms the radio signal into a digital &lt;a href=&#34;https://en.wikipedia.org/wiki/Transistor%E2%80%93transistor_logic&#34; target=&#34;_blank&#34;&gt;low-voltage TTL&lt;/a&gt;
 signal used as input for the microcontroller. The complete hardware setup is shown below.&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 610px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;https://www.blech-lang.org/blog/2020/06/15/decoding-the-dcf77-signal-with-blech/hw_setup_hu079e24572fecd1035cc0e27f9fc88fc8_4204382_600x0_resize_q75_catmullrom.jpg&#34; width=&#34;600&#34; height=&#34;338&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
Hardware setup of the DCF77 decoder: Discovery board (top) and RF receiver module with antenna (bottom).
&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;
&lt;p&gt;Jumper wires are used to connect the receiver module to the discovery board as follows:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;#&lt;/th&gt;
&lt;th&gt;Pin (RF Module)&lt;/th&gt;
&lt;th&gt;Pin (Discovery Board)&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Wire&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;Ground&lt;/td&gt;
&lt;td&gt;blue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Signal&lt;/td&gt;
&lt;td&gt;PB7&lt;/td&gt;
&lt;td&gt;DCF77 Signal&lt;/td&gt;
&lt;td&gt;green&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;VDD&lt;/td&gt;
&lt;td&gt;Supply Voltage&lt;/td&gt;
&lt;td&gt;red&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Note that &lt;em&gt;PB7&lt;/em&gt; is a simple GPIO configured as digital input. By connecting an oscilloscope to PB7 we check that the receiver module is working as expected. The scope visualizes how the DCF77 bits literally &amp;ldquo;fly&amp;rdquo; &amp;ndash; so to speak &amp;ndash; into the microcontroller:&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 610px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;https://www.blech-lang.org/blog/2020/06/15/decoding-the-dcf77-signal-with-blech/scope_hub36a3150171d15fb70dc7d6eab6ef70f_1185503_600x0_resize_catmullrom_2.png&#34; width=&#34;600&#34; height=&#34;360&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
Oszilloscope capture of the DCF77 time signal on GPIO PB7.
&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;
&lt;p&gt;We can also see the synchronization mark (&lt;code&gt;SYNC&lt;/code&gt;) in which the 60th low pulse is omitted. This is the delimiter between the current bit sequence and the following. Finally, the discovery board communicates via USB with the &lt;a href=&#34;https://www.st.com/en/development-tools/stm32cubeide.html&#34; target=&#34;_blank&#34;&gt;software IDE&lt;/a&gt;
 on the development machine for code flashing and debugging.&lt;/p&gt;
&lt;h2 id=&#34;implementation-outline&#34;&gt;Implementation outline&lt;/h2&gt;
&lt;p&gt;In this section we outline the decoder implementation, thereby focusing on the Blech application part and its integration into the C execution environment. The complete source code project can be found &lt;a href=&#34;https://github.com/mterber/blech-dcf77.git&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;
. Two files are of particular interest:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mterber/blech-dcf77/blob/master/Core/Src/main.c&#34; target=&#34;_blank&#34;&gt;main.c&lt;/a&gt;
 &amp;ndash; the main file of the C execution environment.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mterber/blech-dcf77/blob/master/Core/Blech/control.blc&#34; target=&#34;_blank&#34;&gt;control.blc&lt;/a&gt;
 &amp;ndash; the Blech application part.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;interface-between-c-and-blech&#34;&gt;Interface between C and Blech&lt;/h3&gt;
&lt;p&gt;The Blech application part is responsible for the following concerns:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Decoding the DCF77 signal &amp;ndash; requires the time signal level as &lt;em&gt;input&lt;/em&gt; from C to Blech.&lt;/li&gt;
&lt;li&gt;Controlling the LEDs &amp;ndash; requires the state of the blue, orange, green and red LED as &lt;em&gt;output&lt;/em&gt; from Blech to C.&lt;/li&gt;
&lt;li&gt;Reacting to button presses &amp;ndash; requires the state of the user button as &lt;em&gt;input&lt;/em&gt; from C to Blech.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The corresponding signature of the Blech entry point activity looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;// @param[in]   dcf77   The DCF77 signal level (true = &amp;#39;HIGH&amp;#39;).
// @param[in]   btn     The user button state (true = &amp;#39;PRESSED&amp;#39;).
// @param[out]  leds    The LED states (true = &amp;#39;ON&amp;#39;).
@[EntryPoint]
activity Main (dcf77: bool, btn: bool) (leds: LedStates)
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Note that &lt;code&gt;LedStates&lt;/code&gt; is a user-defined structure in Blech which contains the state information of the four LEDs. This is done to make the interface less verbose, thereby improving the readability.&lt;/p&gt;
&lt;h3 id=&#34;execution-scheme-and-integration-of-blech&#34;&gt;Execution scheme and integration of Blech&lt;/h3&gt;
&lt;p&gt;The execution progress of a Blech program advances based on &lt;em&gt;ticks&lt;/em&gt;. A tick can be any sporadic or periodic event- or time-based trigger provided by the underlying hard- and software platform. For decoding DCF77 it is a common approach to periodically sample the time signal and measure the duration of the level changes. This means that the entire decoding logic is &lt;em&gt;purely time-driven&lt;/em&gt; based on a cyclic timer tick.&lt;/p&gt;
&lt;p&gt;We follow this approach and execute the Blech application part every 10 milliseconds. This leads to a sample rate of 100Hz which is sufficiently fast in order to distinguish between a binary zero, a binary one and the synchronization mark. For the periodic execution, we take advantage of a simple delay function (&lt;code&gt;HAL_Delay&lt;/code&gt;) provided by the microcontroller&amp;rsquo;s driver library. An outline of &lt;code&gt;main.c&lt;/code&gt; is shown below.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&amp;#34;blech/control.h&amp;#34;      // Include C code generated from Blech.&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// ... init system ...
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;blc_blech_control_init&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;   &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Init Blech execution context.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;perform_reaction&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;         &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Run boot reaction. 
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;while&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#000&#34;&gt;HAL_Delay&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;          &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Suspend Blech execution for 10ms.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;	    &lt;span style=&#34;color:#000&#34;&gt;perform_reaction&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;     &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Run next reaction.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;perform_reaction&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// ... read inputs (DCF77 level + button state) ...
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#000&#34;&gt;blc_blech_control_tick&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dcf77&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;btn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;leds&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;   &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Actually run Blech.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// ... write outputs (new LED states) ...
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Basically, the main function initializes the system and the Blech execution context. It performs the very first reaction in Blech &amp;ndash; the &lt;em&gt;boot reaction&lt;/em&gt; &amp;ndash; and enters the infinite loop. Inside the loop, we repeatedly wait for the next tick to occur and perform the next reaction in Blech accordingly. The actual call of &lt;code&gt;blc_blech_control_tick&lt;/code&gt; is wrapped in &lt;code&gt;perform_reaction&lt;/code&gt; in order to encapsulate all the required steps for reading the Blech inputs and writing the Blech outputs.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
In this application, the Blech part is entirely time-triggered. All &lt;code&gt;await&lt;/code&gt; statements react in response to the periodic 10 milliseconds tick. Thus, calling &lt;code&gt;await true&lt;/code&gt; &amp;ndash; which means &amp;ldquo;await the next Blech tick&amp;rdquo; &amp;ndash; will suspend the running trail for the next 10 milliseconds. This allows to implement a time-driven counter for measuring durations, e.g. of the signal level changes (see &lt;a href=&#34;#capturing-the-synchronization-mark-and-the-bits&#34;&gt;here&lt;/a&gt;
).
&lt;/div&gt;

&lt;p&gt;Keep in mind that calling &lt;code&gt;HAL_Delay&lt;/code&gt; is generally not a good solution with respect to efficiency. Internally, this function actively polls a variable which gets updated by the system tick timer. This means that the CPU is continously running at full speed and the main thread is blocked for anything else. A better approach would be to switch the microcontroller into sleep mode and implement a wakeup strategy based on interrupts for each tick. We are going to show this in another blog post. In this example, however, we follow the simple delay approach for the sake of simplicity.&lt;/p&gt;
&lt;h3 id=&#34;hierarchical-software-structure&#34;&gt;Hierarchical software structure&lt;/h3&gt;
&lt;p&gt;The entire complexity of the example application is broken down into seven &lt;em&gt;activites&lt;/em&gt; &amp;ndash; the reactive code abstraction entities in Blech &amp;ndash; as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Main&lt;/code&gt; &amp;ndash; This is the entry point and top level of the Blech program. It defines the interface between Blech and C (see &lt;a href=&#34;#execution-scheme-and-integration-of-blech&#34;&gt;here&lt;/a&gt;
) and describes the application behaviour on a high abstraction level.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AwaitStableSignal&lt;/code&gt; &amp;ndash; This waits for the DCF77 time signal to become stable. When the system is powered up the RF receiver module needs some time to stabilize its oscillator and supply voltage. During this time the signal is not reliable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Visualize&lt;/code&gt; &amp;ndash; This visualizes the DCF77 signal level using the blue LED.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Decode&lt;/code&gt; &amp;ndash; This actually decodes the DCF77 time signal.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CaptureTimeInfo&lt;/code&gt; &amp;ndash; This captures and decodes one time code, means one sequence of 59 bits which is transmitted every minute.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CaptureBit&lt;/code&gt; &amp;ndash; This captures one second mark and evaluates it to either a binary zero or a binary one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CaptureSync&lt;/code&gt;&amp;ndash; This captures the synchronization mark.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following graph depicts the hierarchical decomposition and call dependency of the above activities. In particular, it shows that the DCF77 decoding relies on capturing the time code which, in its turn, relies on capturing the synchronization mark and the bits.&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 410px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;https://www.blech-lang.org/blog/2020/06/15/decoding-the-dcf77-signal-with-blech/activity_tree_hu8eb9351a76627fa7002efdf26ac3730a_44992_400x0_resize_catmullrom_2.png&#34; width=&#34;400&#34; height=&#34;320&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
Hierarchical call structure of activities.
&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;
&lt;p&gt;Note how easy it is to reuse the same piece of reactive code for different concerns in Blech &amp;ndash; &lt;code&gt;CaptureBit&lt;/code&gt; is used in &lt;code&gt;AwaitStableSignal&lt;/code&gt; and &lt;code&gt;CaptureTimeInfo&lt;/code&gt; likewise. In the former, we repeatedly run &lt;code&gt;CaptureBit&lt;/code&gt; until three consecutive bits have been successfully captured. Only then we consider the time signal to be stable.&lt;/p&gt;
&lt;h3 id=&#34;the-applications-top-level&#34;&gt;The application&amp;rsquo;s top-level&lt;/h3&gt;
&lt;p&gt;We dig into the implementation starting at the top level. Inside the &lt;code&gt;Main&lt;/code&gt; activity, the program first awaits a stable DCF77 signal by running &lt;code&gt;AwaitStableSignal&lt;/code&gt;. This suspends the control flow until the signal is reliable. A &lt;em&gt;function&lt;/em&gt; call is used before to turn on all LEDs.&lt;/p&gt;
&lt;p&gt;After that, the infinite &lt;code&gt;repeat&lt;/code&gt; loop is entered and all LEDs are turned off. By taking advantage of &lt;code&gt;cobegin&lt;/code&gt;, the main application trail is split into two concurrent trails. While the first one runs &lt;code&gt;Decode&lt;/code&gt; for performing the DCF77 decoding, the second one executes &lt;code&gt;Visualize&lt;/code&gt; in order to concurrently reflect the time signal level on the blue LED. Note that the second trail is marked as &lt;code&gt;weak&lt;/code&gt;. This means that, as soon as the first trail terminates, the second trail will be aborted &amp;ndash; both trails rejoin their control paths and continue as one. By this, it is pretty easy to describe that visualizing the signal level shall be done only while the decoding is running.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
Due to the synchronous computation model, abortion of trails is done only at the end of the current reaction when all trails have finished their job and are waiting for the next tick. Thus, trails are particularly &lt;em&gt;not&lt;/em&gt; interrupted at an arbitrary code location because this would lead to non-deterministic runtime behaviour!
&lt;/div&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;18
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;19
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;20
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;21
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;22
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;23
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;24
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;25
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;26
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;27
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;28
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;@[EntryPoint]
activity Main (dcf77: bool, btn: bool) (leds: LedStates)
    ledsAllOn()(leds)
    run AwaitStableSignal(dcf77)

    repeat
        ledsAllOff()(leds)      // Turn off all LEDs.
    
        var ti: TimeInfo        // The decoded time information.
        var success: bool

        cobegin
            success = run Decode(dcf77)(ti, leds.orange)
        with weak
            run Visualize(dcf77)(leds.blue)
        end

        ledsAllOff()(leds)      // Turn off all LEDs.

        if success then
            leds.green = true   // Decode() succeeded -&amp;gt; green LED on.
            // ... use &amp;#39;ti&amp;#39; for synchronizing the local clock ...
        else
            leds.red = true     // Decode() failed -&amp;gt; red LED on.
        end

        await btn               // Await user button press.
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;After decoding has been finished, all LEDs are turned off again and we check for success or error. On success, the green LED is turned on while on error the red LED is turned on. Finally, the Blech program suspends until the push button is pressed by the user. Once this is done the whole process restarts.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
To keep the example simple, the button state is provided &lt;em&gt;as-is&lt;/em&gt; to the Blech program. This means we just pass the current value of the corresponding GPIO input register. Usually, however, it is common practice to apply a filter approach in software in order to suppress &lt;a href=&#34;https://en.wikipedia.org/wiki/Switch#Contact_bounce&#34; target=&#34;_blank&#34;&gt;bouncing&lt;/a&gt;
. In &lt;a href=&#34;https://www.blech-lang.org/blog/2020/08/12/push-button-handling/&#34;&gt;this blog post&lt;/a&gt;
 we are going to show how this can be done in Blech.
&lt;/div&gt;

&lt;h3 id=&#34;visualizing-the-dcf77-signal&#34;&gt;Visualizing the DCF77 signal&lt;/h3&gt;
&lt;p&gt;Reflecting the time signal level on the LED is a pretty simple task in Blech. We establish an infinite loop which alternates between the signal levels. First, it awaits the high level for switching off the LED. Second, it awaits the low level for switching on the same LED. Third, the whole process repeats &amp;ndash; that&amp;rsquo;s it.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity Visualize (dcf77: bool) (ledDcf77: bool)
    repeat
        await dcf77         // Await rising edge.
        ledDcf77 = false    // Turn off LED.
        await not dcf77     // Await falling edge.
        ledDcf77 = true     // Turn on LED.
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Note that &lt;code&gt;Visualize&lt;/code&gt; does not even have to know which of the four LEDs it is actually turning on and off. There is no hardware dependency and all the required logic is encapsulated in an activity. Thus, we could easily select another LED or execute multiple instances of &lt;code&gt;Visualize&lt;/code&gt; concurrently in order to show the signal level on several LEDs at the same time.&lt;/p&gt;
&lt;h3 id=&#34;capturing-the-synchronization-mark-and-the-bits&#34;&gt;Capturing the synchronization mark and the bits&lt;/h3&gt;
&lt;p&gt;For this functionality, we take advantage of the fact that the entire Blech application is purely time-triggered by the 10 milliseconds tick (see &lt;a href=&#34;#execution-scheme-and-integration-of-blech&#34;&gt;here&lt;/a&gt;
). Based on that, we establish a time-based counter &lt;code&gt;len&lt;/code&gt; which measures the duration of the signal&amp;rsquo;s &lt;code&gt;HIGH&lt;/code&gt; level. Therefore, &lt;code&gt;len&lt;/code&gt; is incremented on each (10 milliseconds) tick using &lt;code&gt;await true&lt;/code&gt; in a loop. Once that counter has reached the required value (&amp;gt; 1200ms) we detect the synchronization mark and exit the loop.&lt;/p&gt;
&lt;p&gt;If the signal level goes &lt;code&gt;LOW&lt;/code&gt; during the measurement the process has to be resetted. For this, we use the &lt;code&gt;when ... reset&lt;/code&gt; block in Blech which causes the contained code to restart from the first line if the given condition is met. So in this case the code will jump back to &lt;code&gt;var len: nat16 = 0&lt;/code&gt; as soon as the level drops.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity CaptureSync (dcf77: bool)
    // Perform the measurement and restart if the level drops meanwhile.
    when not dcf77 reset
        var len: nat16 = 0
        repeat
            await true // Await next sys tick.
            len = len + 1
        until len &amp;gt; DCF77_SYNC_LEN end
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The implementation of &lt;code&gt;CaptureBit&lt;/code&gt; basically follows the same approach. It uses a time-driven counter for measuring the duration of the &lt;code&gt;LOW&lt;/code&gt; level instead. For this reason, we do not exemplify it in more detail here.&lt;/p&gt;
&lt;h3 id=&#34;capture-and-decode-the-time-information&#34;&gt;Capture and decode the time information&lt;/h3&gt;
&lt;p&gt;Implementing the time information capture based on &lt;code&gt;CaptureSync&lt;/code&gt; and &lt;code&gt;CaptureBit&lt;/code&gt; becomes a trivial task. First, we capture the synchronization mark. Before and after that we turn off and on the associated LED (orange) respectively. Second, we enter the &lt;code&gt;while&lt;/code&gt; loop in which we collect the 59 time code bits by repeatedly calling &lt;code&gt;CaptureBit&lt;/code&gt;. Each successfully received bit is passed to &lt;code&gt;processBit&lt;/code&gt; in order to update the gathered time information in &lt;code&gt;ti&lt;/code&gt;. This means that decoding the DCF77 signal actually happens bit-wise on-the-fly. Finally, &lt;code&gt;CaptureTimeInfo&lt;/code&gt; terminates, thereby returning the success status and the decoded time information to the caller.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;18
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;19
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;20
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;21
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;22
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;23
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity CaptureTimeInfo (dcf77: bool)(ti: TimeInfo, ledSync: bool) returns bool
    ledSync = false // Turn off LED.
    run CaptureSync(dcf77)
    ledSync = true  // Turn on LED.

    var success: bool = true
    var parity: nat8 = 0
    var i: nat8 = 0
    
    while success and (i &amp;lt;= 58) repeat // [0, 58]
        var bit: nat8
        success = run CaptureBit(dcf77)(bit)
        
        if success then
            success = processBit(i, bit)(parity, ti)
        end

        i = i + 1
    end

    ledSync = false // Turn off LED.

    return success
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The job of &lt;code&gt;Decode&lt;/code&gt; is to retrieve two consecutive time codes (&lt;code&gt;tmp&lt;/code&gt; and &lt;code&gt;ti&lt;/code&gt;) and apply a simple validity check by comparing them. A common approach is to check whether the second timestamp (&lt;code&gt;ti&lt;/code&gt;) is exactly one minute ahead of the first one (&lt;code&gt;tmp&lt;/code&gt;). If that is the case the second one is considered valid and returned to the caller &amp;ndash; the decoding is done.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity Decode (dcf77: bool) (ti: TimeInfo, ledSync: bool) returns bool
    var success: bool
    var tmp: TimeInfo

    success = run CaptureTimeInfo(dcf77)(tmp, ledSync)  // First capture.

    if not success then
        return false
    end

    success = run CaptureTimeInfo(dcf77)(ti, ledSync)   // Second capture.

    if not success then
        return false
    end

    return isTimeInfoValid(tmp, ti) // Check plausibility.
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The following video shows the DCF77 decoder in action. In focus are the four color LEDs and the user button on the left side. Watch the video to get in impression about how above Blech activities control the runtime behaviour.
&lt;a href=&#34;https://youtu.be/KaX_LRlV4oI&#34; target=&#34;_blank&#34;&gt;






&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 610px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;https://www.blech-lang.org/blog/2020/06/15/decoding-the-dcf77-signal-with-blech/vid_thumb_huc0fefdc87aee5b67d4c7c252c53ee7a9_156721_600x0_resize_q75_catmullrom.JPG&#34; width=&#34;600&#34; height=&#34;338&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
    Video: The DCF77 decoder in action.
    &lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Above implementation outline shows that implementing DCF77 decoding is a straightforward job in Blech. The combination of the synchronous execution model and activities allows to divide the entire decoding complexity into smaller parts that are easier to program, comprehend and maintain. In particular, it is possible to compose these reactive functionalities in a hierarchical top-down fashion. All concurrent behaviour is deterministic by design and does not require any mutexing.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: The purpose of Blech</title>
      <link>https://www.blech-lang.org/blog/2020/05/27/the-purpose-of-blech/</link>
      <pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/blog/2020/05/27/the-purpose-of-blech/</guid>
      <description>
        
        
        &lt;h2 id=&#34;why-blech&#34;&gt;Why Blech?&lt;/h2&gt;
&lt;p&gt;There is a huge difference between the environments of a desktop, a server, or a mobile application 
and a typical application in the embedded domain.
Moreover, the embedded industry is itself huge &amp;ndash; including automotive, aerospace, robotics, medical technology, rail, IoT, home appliances, power tools.&lt;/p&gt;
&lt;!-- Just because it&#39;s &#34;huge&#34; doesn&#39;t of itself motivate anything yet - how about the following? --&gt; 
&lt;p&gt;Mainstream discourse about programming, with its traditional IT focus, has tended to ignore these issues,
with the result that the size and scope of these problems are seldom discussed or understood outside the confines
of academic circles or highly proprietary walled garden approaches.&lt;/p&gt;
&lt;p&gt;We want to change that.&lt;/p&gt;
&lt;h3 id=&#34;the-embedded-domain-is-tough&#34;&gt;The embedded domain is tough&lt;/h3&gt;
&lt;p&gt;Embedded applications usually run on dedicated hardware to interact with a specific physical environment.
More often than not, the hardware is resource-constrained in terms of memory and processing power. 
To fulfill safety requirements, the code needs to be safe, secure, reliable, and portable.
Applications must be reactive because of realtime requirements, and deterministic to make reactions predictable and repeatable under test.&lt;/p&gt;
&lt;p&gt;This mix of requirements imposes severe constraints on developers in terms of how to program their application.&lt;/p&gt;
&lt;p&gt;In principle, there are two ways to organize the code: event-driven or threaded.&lt;/p&gt;
&lt;p&gt;Event-driven functions cannot rely on a stack to maintain the state between consecutive events in a task. 
The programmer has to maintain the state across multiple events, and to manually combine these events into the required flow of control.
Therefore, event-driven programs can be very efficient in terms of memory footprint and they do not need scheduling.
The disadvantage is that they are hard to write and even harder to read and reason about.&lt;/p&gt;
&lt;p&gt;Threaded functions are easier to write and comprehend, since the program can be expressed as a sequence of actions, waiting for asynchronous input if needed.
The state between steps is preserved on the stack.
The big disadvantage is that each threaded function needs to allocate its maximum possible required stack during its existence, 
and the composition of threaded functions creates the need for pre-emptive or cooperative scheduling at run-time, which either is non-deterministic or non-reactive.&lt;/p&gt;
&lt;p&gt;As a consequence, applications are often written in an event-driven style.&lt;/p&gt;
&lt;h3 id=&#34;c-programming-is-like-defusing-a-bomb&#34;&gt;C programming is like defusing a bomb&lt;/h3&gt;
&lt;p&gt;Many areas in software development have benefitted from improvements made to programming languages. 
Embedded systems are an exception to this. 
C remains the de-facto standard for development, although there are many flaws that need to be mitigated by tight coding conventions and static analysis tools.&lt;/p&gt;
&lt;p&gt;Of course, there are several languages like Ada, C++, or Rust that have the potential to improve certain aspects of embedded development.
Due to its backwards compatability with C and its maturity, C++ is often preferred and used in many embedded projects.
Nevertheless, C++ as well as older (Ada) and newer (Rust) developments are all general-purpose languages, which only improve certain programming aspects and do not really reduce the complexity of embedded applications.&lt;/p&gt;
&lt;p&gt;Blech is different.&lt;/p&gt;
&lt;h2 id=&#34;what-is-blech&#34;&gt;What is Blech?&lt;/h2&gt;
&lt;p&gt;Blech is a language that is specifically designed for safety- and realtime-critical, reactive, embedded programming. 
The cornerstones of Blech are its model of computation (MoC) and its simple integration with C.
Being a new language, it benefits from the progress in programming languages over the past 4 decades. 
With its domain focus, it is designed to guarantee important properties via the compiler.&lt;/p&gt;
&lt;h3 id=&#34;the-blech-model-of-computation&#34;&gt;The Blech model of computation&lt;/h3&gt;
&lt;p&gt;Blech is a synchronous language.&lt;/p&gt;
&lt;p&gt;In a nutshell, the synchronous model of computation allows us to write threaded functions, which are compiled into an efficiently executable event-driven code that is deterministic.
For this purpose, it incorporates the step-wise execution of typical realtime, reactive applications into the language.&lt;/p&gt;
&lt;p&gt;Blech allows us to write subprograms, called &lt;em&gt;activities&lt;/em&gt;, that execute in &lt;em&gt;steps&lt;/em&gt;, as a sequence of actions which pause once a step is finished.
A synchronous language regards the trigger events that initiate these steps as the &lt;em&gt;ticks&lt;/em&gt; of a clock. 
The ticks can either be periodically triggered by time, or aperiodically triggered by events.
The synchronous model of computation (MoC) assumes a minimum inter-arrival time between ticks, which defines the maximum execution time in order to complete a step.
Based on this assumption, which is very suitable for realtime-critical, reactive applications, the programming model can be abstracted to a perfect model, where every step is executed immediately and runs to completion, before the next tick occurs.&lt;/p&gt;
&lt;p&gt;A Blech activity is a sequential control flow of statements that finishes a step by pausing at an &lt;em&gt;await&lt;/em&gt; statement. 
The await statement guards the continuation of the control flow with a condition, which is evaluated as soon as the next step is triggered by a tick.
These subprograms can be composed sequentially via normal control flow and concurrently via synchronous parallel composition.
The compiler guarantess deterministic execution of concurrently composed subprograms.&lt;/p&gt;
&lt;p&gt;Underneath the hood, a concurrently composed application compiles to a sequential program that is driven by a clock.
A clock can be anything that drives a reactive application, for example&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a main loop&lt;/li&gt;
&lt;li&gt;a time-triggering environment&lt;/li&gt;
&lt;li&gt;an event-triggering environment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This MoC regains the simplicity of threaded programs, the composability of sequential subprograms, and the efficiency of event-driven program organisation.&lt;/p&gt;
&lt;h3 id=&#34;blech-is-a-companion-to-cc&#34;&gt;Blech is a companion to C/C++&lt;/h3&gt;
&lt;p&gt;Blech compiles to &lt;em&gt;clean&lt;/em&gt; C - the common subset of C and C++.
Therefore, Blech programs can easily be integrated into existing embedded projects.&lt;/p&gt;
&lt;p&gt;Embedded hardware usually comes with driver software written in C.
Useful libraries written in C/C++ already exist, for almost everything.
There is no need to rewrite everything in Blech, existing C libraries can be used from Blech programs directly.&lt;/p&gt;
&lt;p&gt;This 2-way integration simplifies the necessary separation between&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;an asynchronous environment that drives the Blech program&lt;/li&gt;
&lt;li&gt;and the synchronous application written in Blech with the support of further C/C++ libraries.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Blech is a German word and roughly translates as bare metal.
As its name suggests, a Blech program can run on pretty much anything:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;directly on &amp;ldquo;the Blech&amp;rdquo; in an embedded device,&lt;/li&gt;
&lt;li&gt;on top of a realtime OS,&lt;/li&gt;
&lt;li&gt;as a safety-critical component integrated via some middleware,&lt;/li&gt;
&lt;li&gt;in combination with a simulation model.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;blech-is-made-for-the-embedded-domain&#34;&gt;Blech is made for the embedded domain&lt;/h3&gt;
&lt;p&gt;Here is a list of requirements for Blech that has found its way into the language design:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;time-driven and event-driven program execution,&lt;/li&gt;
&lt;li&gt;predictable and deterministic semantics,&lt;/li&gt;
&lt;li&gt;synchronous concurrency,&lt;/li&gt;
&lt;li&gt;hard real-time,&lt;/li&gt;
&lt;li&gt;predictable memory usage and execution time,&lt;/li&gt;
&lt;li&gt;compile-time mechanism for structuring and variants,&lt;/li&gt;
&lt;li&gt;safe shared memory,&lt;/li&gt;
&lt;li&gt;safe type system,&lt;/li&gt;
&lt;li&gt;expressive and productive programming,&lt;/li&gt;
&lt;li&gt;a &amp;ldquo;cool&amp;rdquo; development environment.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Blech core language is designed to resolve frequently encountered issues with C/C++.
With its domain focus and the synchronous MoC, we restrict the language to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no global variables,&lt;/li&gt;
&lt;li&gt;no undefined behaviour,&lt;/li&gt;
&lt;li&gt;no pointer aliasing problems,&lt;/li&gt;
&lt;li&gt;no address arithmetic,&lt;/li&gt;
&lt;li&gt;no machine-dependent types,&lt;/li&gt;
&lt;li&gt;no overflow, underflow, division-by-zero,&lt;/li&gt;
&lt;li&gt;no index out of bounds,&lt;/li&gt;
&lt;li&gt;no integer promotion,&lt;/li&gt;
&lt;li&gt;no unsafe casts,&lt;/li&gt;
&lt;li&gt;no side-effects in conditions,&lt;/li&gt;
&lt;li&gt;no dynamic memory allocation,&lt;/li&gt;
&lt;li&gt;no uninitialised variables,&lt;/li&gt;
&lt;li&gt;no shadowing,&lt;/li&gt;
&lt;li&gt;no race-conditions in concurrent code,&lt;/li&gt;
&lt;li&gt;no dynamic thread generation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These properties are guaranteed by the type system and several further compile-time analyses.
Virtually anything that is usually required by embedded, realtime, or safety-oriented coding-conventions like MISRA C/C++ can be handled by the compiler.&lt;/p&gt;
&lt;h3 id=&#34;the-future&#34;&gt;The future&lt;/h3&gt;
&lt;p&gt;Blech, as currently released, is a working first step. 
The new mechanisms and the semantics for synchronous imperative programming are fully implemented.
The compiler generates clean C code.&lt;/p&gt;
&lt;p&gt;However, some of the syntactic elements are not yet translated. 
Also, a few of the above safety checks are still missing. 
Filling these gaps is a matter of effort and is done bit by bit. 
Furthermore, there is a longer roadmap to enrich the language itself. 
This requires more research and design.&lt;/p&gt;
&lt;p&gt;Currently we are working on the module system, that incorporates cycle-free dependency management of separately compilable modules into the language.
The module system will support information hiding, black-box reuse and white-box testing.
It will allow us to deliver Blech modules as pre-compiled libraries with C header files and Blech module signatures.&lt;/p&gt;
&lt;p&gt;We have planned mechanisms for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;error handling,&lt;/li&gt;
&lt;li&gt;type-safe generics with predictable code size,&lt;/li&gt;
&lt;li&gt;multi-clock programming.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Besides the already working VS Code language server plug-in we plan a minimal tool set for Blech:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a test framework for regression tests of Blech components,&lt;/li&gt;
&lt;li&gt;a build system for mixed Blech/C projects.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Due to Blech&amp;rsquo;s statically guaranteed properties and its concurrent execution determinism, development tools become possible that are otherwise difficult to create.
For example,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a time-travel debugger for concurrent and parallel programs, or&lt;/li&gt;
&lt;li&gt;a deployment support tool.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To follow upon and participate in the development visit the Blech homepage: &lt;a href=&#34;www.blech-lang.org&#34;&gt;&lt;a href=&#34;http://www.blech-lang.org&#34;&gt;www.blech-lang.org&lt;/a&gt;&lt;/a&gt;
.
The documentation, examples, and plans for the evolution of the language can be found on the website.&lt;/p&gt;
&lt;p&gt;We are convinced that Blech can substantially boost productivity and the quality of safety- and realtime-critical, reactive, embedded applications.&lt;/p&gt;
&lt;p&gt;Stay tuned or &amp;ndash; even better &amp;ndash; participate.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
