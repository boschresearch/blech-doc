<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blech – Documentation</title>
    <link>https://www.blech-lang.org/docs/</link>
    <description>Recent content in Documentation on Blech</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://www.blech-lang.org/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: The Blech compiler - blechc</title>
      <link>https://www.blech-lang.org/docs/getting-started/blechc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/getting-started/blechc/</guid>
      <description>
        
        
        &lt;h2 id=&#34;build-blechc-from-source&#34;&gt;Build blechc from source&lt;/h2&gt;
&lt;p&gt;Clone the blech compiler project using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/boschresearch/blech
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To build the project, you need &lt;strong&gt;.NET Core&lt;/strong&gt; installed. Go to the &lt;a href=&#34;https://dotnet.microsoft.com/download&#34; target=&#34;_blank&#34;&gt;Microsoft .NET website&lt;/a&gt;
 and follow their instructions to install the latest stable &lt;strong&gt;.NET Core&lt;/strong&gt; available for your operating system.&lt;/p&gt;
&lt;p&gt;Navigate to the folder where you checked out the Blech project. It should contain the file &lt;code&gt;Blech.sln&lt;/code&gt;. Now you have choices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For a simple &lt;strong&gt;debug build&lt;/strong&gt; run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dotnet build
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This creates &lt;code&gt;./src/blechc/bin/Debug/netcoreapp3.1/blechc.dll&lt;/code&gt;.
Use the dotnet command to start the compiler like so&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dotnet ./src/blechc/bin/Debug/netcoreapp3.1/blechc.dll
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For a release build additionally use the &lt;code&gt;-c Release&lt;/code&gt; option.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finally, for a &lt;strong&gt;self-contained release build&lt;/strong&gt;, which is operating system dependent, you need to run &lt;code&gt;dotnet publish&lt;/code&gt; with a specific runtime identifier like so&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dotnet publish -c Release -r win-x64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For Linux use &lt;code&gt;linux-x64&lt;/code&gt;, for MacOS use &lt;code&gt;osx-x64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This creates a folder &lt;code&gt;./src/blechc/bin/Release/netcoreapp3.1/win-x64/publish&lt;/code&gt; which contains all files needed for execution. The folder as a whole can be moved arbitrarily.
Inside the folder invoke the binary&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;blechc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to run the Blech compiler.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;use-blechc&#34;&gt;Use &lt;code&gt;blechc&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Assuming you have a binary of the Blech Compiler &lt;code&gt;blechc&lt;/code&gt; for your operating system, or you have built the Blech project yourself from sources, this sections tells you how to use it.&lt;/p&gt;
&lt;p&gt;If the &lt;code&gt;blechc&lt;/code&gt; binary is in your &lt;code&gt;$PATH&lt;/code&gt;, you can invoke the compiler by simply writing&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;blechc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;on the command line interface.
If you do not have a standalone (publish) build and want to use your local Debug (or Release) build, use the &lt;code&gt;dotnet&lt;/code&gt; command to start the compiler from your blech working directory.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dotnet &amp;lt;path-to&amp;gt;/blech/src/blechc/bin/Debug/netcoreapp3.1/blechc.dll
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;From here on out we assume &lt;code&gt;blechc&lt;/code&gt; to be a synonym for either call above&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The following shows some typical invocations of &lt;code&gt;blechc&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Compile a Blech program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;blechc someBlechFile.blc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Translates &lt;code&gt;someBlechFile.blc&lt;/code&gt; to C code silently. You will only see output on the command line if there are problems with the translation.
This will generate a file &lt;code&gt;blech.c&lt;/code&gt; in the same folder which contains a runnable program. It runs in a main loop and calls the entry point activity of &lt;code&gt;someBlechFile.blc&lt;/code&gt; 60 times. Furthermore in the subfolder &lt;code&gt;./blech&lt;/code&gt; two files are generated &lt;code&gt;someBlechFile.c&lt;/code&gt; and &lt;code&gt;someBlechFile.h&lt;/code&gt;. They contain the C code and interface declarations respectively.&lt;/p&gt;
&lt;p&gt;Compile with diagnostic messages:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;blechc -v d someBlechFile.blc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Does the same as above but prints out textual representations of intermediate compilation results including: typed syntax tree, control flow graphs and block graphs for activities, C code.&lt;/p&gt;
&lt;p&gt;Just check the programs correctness:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;blechc --dry-run someBlechFile.blc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Runs through all compilation phases but do not write any C files. This is useful to check for problems without actually touching anything on the file system.&lt;/p&gt;
&lt;p&gt;Try all the options&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;blechc --help
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;compile-generated-c-files&#34;&gt;Compile generated C files&lt;/h2&gt;
&lt;p&gt;By default the compiler produces a main program in &lt;code&gt;blech.c&lt;/code&gt; which can be used as a first test. To compile this code you need to include Blech specific C header files. These are located in &lt;code&gt;&amp;lt;path-to&amp;gt;/blech/src/blechc/include&lt;/code&gt;. 
On Windows C compilation may look like this.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mingw32-cc.exe -I. -I&amp;lt;path-to&amp;gt;/blech/src/blechc/include blech.c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the current folder &lt;code&gt;.&lt;/code&gt; is explicitly added as a path to be included.
The resulting executable will run the program for 60 reactions and print the variable evaluations after every reaction in JSON format.&lt;/p&gt;
&lt;p&gt;To include the generated C code in your own project inspect &lt;code&gt;blech.c&lt;/code&gt; for details. In particular, make sure you call the &lt;code&gt;init&lt;/code&gt; function on initial startup and then &lt;code&gt;tick&lt;/code&gt; with every reaction.
For programmers familiar with Arduino these correspond to the &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt; functions.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>About: Corporate information</title>
      <link>https://www.blech-lang.org/about/corporate-information/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/about/corporate-information/</guid>
      <description>
        
        
        &lt;h3 id=&#34;name-and-address&#34;&gt;Name and address&lt;/h3&gt;
&lt;p&gt;Robert Bosch GmbH &lt;br&gt;
Corporate Research &lt;br&gt;
Robert-Bosch-Campus 1&lt;br&gt;
71272 Renningen &lt;br&gt;
GERMANY&lt;/p&gt;
&lt;h3 id=&#34;members-of-the-board-of-management&#34;&gt;Members of the Board of Management&lt;/h3&gt;
&lt;p&gt;Dr. Volkmar Denner, Prof. Dr. Stefan Asenkerschbaumer, Dr. Michael Bolle, Dr. Christian Fischer, Dr. Stefan Hartung, Dr. Markus Heyn, Harald Kröger, Christoph Kübel, Rolf Najork, Uwe Raschke, Peter Tyroller&lt;/p&gt;
&lt;h3 id=&#34;your-contact-at-bosch-research&#34;&gt;Your contact at Bosch Research&lt;/h3&gt;
&lt;p&gt;&lt;i class=&#34;fas fa-envelope&#34;&gt;&lt;/i&gt; &lt;a href=&#34;mailto:opensource@bosch.com&#34;&gt;&lt;a href=&#34;mailto:opensource@bosch.com&#34;&gt;opensource@bosch.com&lt;/a&gt;&lt;/a&gt;
 &lt;br&gt;
&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt; &lt;a href=&#34;https://www.bosch.com/research&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.bosch.com/research&#34;&gt;www.bosch.com/research&lt;/a&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;register-entries&#34;&gt;Register Entries&lt;/h3&gt;
&lt;p&gt;Registration Court: District Court Stuttgart HRB 14000&lt;/p&gt;
&lt;h3 id=&#34;value-added-tax-identification-number&#34;&gt;Value-added tax identification number&lt;/h3&gt;
&lt;p&gt;DE811128135&lt;/p&gt;
&lt;h3 id=&#34;responsible-in-the-sense-of--55-abs-2-staatsvertrag-für-rundfunk-und-telemedien&#34;&gt;Responsible in the sense of § 55 Abs. 2 Staatsvertrag für Rundfunk und Telemedien&lt;/h3&gt;
&lt;p&gt;Robert Bosch GmbH &lt;br&gt;
Corporate Research &lt;br&gt;
Franz-Josef Grosch&lt;br&gt;
Robert-Bosch-Campus 1&lt;br&gt;
71272 Renningen &lt;br&gt;
GERMANY&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Accessing variables in the Blech environment</title>
      <link>https://www.blech-lang.org/docs/language-evolution/blech-c-interface/env-variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/language-evolution/blech-c-interface/env-variables/</guid>
      <description>
        
        
        &lt;h2 id=&#34;environment-variables&#34;&gt;Environment variables&lt;/h2&gt;
&lt;p&gt;Environment variables are either read-only inputs or read-write outputs.
Every environment variables has a counterpart in the Blech environment.
Therefore, they are annotated as &lt;code&gt;@[CInput ...]&lt;/code&gt; or &lt;code&gt;@[COutput ...]&lt;/code&gt;.
Environment variables are classified by the keyword &lt;code&gt;extern&lt;/code&gt;. 
A &lt;code&gt;extern let&lt;/code&gt; definition must be annotated with a &lt;code&gt;@[CInput ...]&lt;/code&gt;.
An &lt;code&gt;extern var&lt;/code&gt; definition must be annotated with a &lt;code&gt;@[COutput ...]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CInput (binding = &amp;quot;theSensor&amp;quot;, header = &amp;quot;sensors.h&amp;quot;)]
extern let sensor: uint8 

@[COutput (binding = &amp;quot;spiIsReady&amp;quot;, header = &amp;quot;spi.h&amp;quot;)]
extern var spiReady: bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since the external C variables bound to the environment variables live in the environment they do not follow the synchronous semantics. 
They might be &lt;code&gt;volatile&lt;/code&gt; changing their value during a reaction. 
They might be read or written asynchronously by the environment.&lt;/p&gt;
&lt;p&gt;In order to synchronize these C variables, the Blech program holds a buffered value of the external value in the environment variable.&lt;/p&gt;
&lt;p&gt;The Blech runtime system takes care of the synchronisation.
Before the reaction, the values of all external C variables are copied into the environment variable.
After the reaction, the values of the &lt;code&gt;extern var&lt;/code&gt; variables are copied into the external C variables.&lt;/p&gt;
&lt;p&gt;The implementation is allowed to distribute these copying operations into the code generated for each activity, that defines &lt;code&gt;extern&lt;/code&gt; variables.&lt;/p&gt;
&lt;p&gt;Environment variables can only be declared in an &lt;code&gt;activity&lt;/code&gt;.
Functions can only access environment variables via the parameter list.&lt;/p&gt;
&lt;h2 id=&#34;external-read-write-c-variables-create-singletons&#34;&gt;External read-write C variables create singletons&lt;/h2&gt;
&lt;p&gt;An external C variable is a global variable, which is in danger to be accessed concurrently via the environment variable.
While Blech in general prevents this danger by not allowing the declaration of global variables at all, it needs more effort to guarantee this for external C variables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity handleCVariables()
    
    @[CInput (binding = &amp;quot;theSensor&amp;quot;, header = &amp;quot;sensors.h&amp;quot;)]
    extern let sensor: uint8
    @[COutput (binding = &amp;quot;spiIsReady&amp;quot;, header = &amp;quot;spi.h&amp;quot;)]
    extern var spiReady: bool

    repeat
        if sensor &amp;gt; 10 then
            spiReady = true
        end
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to comply to the single-writer principle, declaring an &lt;code&gt;extern var&lt;/code&gt; variable in an activity restricts this activity to be instantiated only once.
The declared activity is a &lt;code&gt;singleton&lt;/code&gt; and does not allow multiple instances.
An singleton activity cannot be called concurrently, but only sequentially.
Note that this is only necessary for &lt;code&gt;extern var&lt;/code&gt; declarations.
An &lt;code&gt;extern let&lt;/code&gt; variable does &lt;em&gt;not&lt;/em&gt; create a &lt;code&gt;singleton&lt;/code&gt;.
Different instances of such an activity can have separate buffers of the external C variable, which might have different values in the same reaction if the external C variable is &lt;code&gt;volatile&lt;/code&gt;.
It is the responsibility of the programmer not to share external C variables in different &lt;code&gt;extern var&lt;/code&gt; declarations.
Two or more &lt;code&gt;extern let&lt;/code&gt; declarations are allowed to have the same annotation &lt;code&gt;@[CInput ...]&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;singletons-and-separate-compilation&#34;&gt;Singletons and separate compilation&lt;/h2&gt;
&lt;p&gt;If a module exports a singleton activity, the signature needs to reflect this in order to enable a correct causality analysis.
The signature for the above activity &lt;code&gt;handleCVariables&lt;/code&gt; looks like the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;singleton handleCVariables.spiReady 
activity handleCVariables()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It shows the activities prototype, exposes the unique names of the external variables and shows their annotations. 
Showing the annotations allows to check the binding to C variables also for modules where the implementation is hidden.&lt;/p&gt;
&lt;h2 id=&#34;the-diamond-call-problem&#34;&gt;The diamond call problem&lt;/h2&gt;
&lt;p&gt;If an activity is a singleton, it still can be called from several activities.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity firstUsage()
    run handleCVariables()
end

activity secondUsage()
    run handleCVariables()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again &lt;code&gt;firstUsage&lt;/code&gt; and &lt;code&gt;secondUsage&lt;/code&gt; can not be called concurrently.&lt;/p&gt;
&lt;p&gt;In order to check this via the signature, the calling activities, inherits the singletons from the called activity.
In a module signature these activities occur as follows&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;singleton handleCVariables.spiReady
activity firstUsage()

singleton handleCVariables.spiReady
activity secondUsage()

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we combine activities with different singletons, they must not be called concurrently, if they share common singletons.
For example assume the following module signature.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;signature Module 

singleton handleOtherCVariable.theExternVar
activity handleOtherCVariable()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A calling activity might inherit all singletons&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import Module

activity thirdUsage()
    cobegin
        run handleCVariables()
    with
        run handleOtherCVariable()
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The deduced signature is&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import Module

singleton handleCVariables.spiReady, 
          Module.handleOtherCVariable.theExternVar
activity thirdUsage()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Activity &lt;code&gt;thirdUsage&lt;/code&gt; cannot be called concurrently to &lt;code&gt;firstUsage&lt;/code&gt; or &lt;code&gt;secondUsage&lt;/code&gt; because their singletons overlap.&lt;/p&gt;
&lt;h2 id=&#34;structured-access-to-external-variables&#34;&gt;Structured access to external variables&lt;/h2&gt;
&lt;p&gt;Environment variables can also be referenced from a &lt;code&gt;struct&lt;/code&gt; type, like normal Blech variables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct MyCVariables
    var x: int32
    let ref sensor: nat8
    var ref spiReady: bool
end
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity referToCVariables()
    @[CInput (binding = &amp;quot;theSensor&amp;quot;, header = &amp;quot;sensors.h&amp;quot;)]
    extern let sensor: nat8 

    @[COutput (binding = &amp;quot;spiIsReady&amp;quot;, header = &amp;quot;spi.h&amp;quot;)]
    extern var spiReady: bool

    var mcvs: MyCVariables = { x = 0, sensor = sensor, spiReady = spiReady }
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we use both activities &lt;code&gt;referToCVariables&lt;/code&gt; and &lt;code&gt;handleCVariables&lt;/code&gt; in a Blech program we obviously made a mistake.
Both activities write to the same external C Variable &lt;code&gt;&amp;quot;spiIsReady&amp;quot;&lt;/code&gt;.
The single-writer principle is broken.
The semantics of the program is undefined concerning the environment access.
In general working with externals is unsafe.
In this particular case, it is the responsibility of the programmer to take care, not to share the same &lt;code&gt;COutput&lt;/code&gt; between different &lt;code&gt;extern var&lt;/code&gt; declarations.&lt;/p&gt;
&lt;p&gt;The signatures of both activities cannot reveal this error.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;singleton referToCVariables.spiReady
activity referToCVariables()

singleton handleCVariables.spiReady
activity handleCVariables()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Idea: It should be the responsibility. of the compiler to collect the environment of a Blech program across all modules in order to allow for a code review supported by such a description file.&lt;/p&gt;
&lt;p&gt;Hints: &lt;code&gt;extern var&lt;/code&gt; and &lt;code&gt;extern let&lt;/code&gt; declarations cannot be declared inside functions.
Use &lt;code&gt;extern let&lt;/code&gt; declarations when possible in order to prevent the propagation of the singleton property.&lt;/p&gt;
&lt;p&gt;Since signatures are deduced by the compiler, the whole checking of singletons and the generation of appropriate signatures is done by the compiler.&lt;/p&gt;
&lt;p&gt;Note: A conventional embedded program is full of singletons, not only created by &lt;code&gt;extern var&lt;/code&gt; declarations, but especially by global variables.
In order to maintain the single-writer principle by programming discipline it is almost inevitable, that all functions are only called once in a task list. This makes reuse and testing extremely difficult. Only the rather small number of services is reusable and rather easily testable.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Expressions, conditions, initialisers, constants</title>
      <link>https://www.blech-lang.org/docs/blechc-development/const-and-expr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/blechc-development/const-and-expr/</guid>
      <description>
        
        
        &lt;h2 id=&#34;equality-expressions&#34;&gt;Equality expressions&lt;/h2&gt;
&lt;p&gt;Theoretically, every type supports some notion of equality (and inequality). 
This is straightforward for &lt;strong&gt;simple (or primitive) value types&lt;/strong&gt; that consist of one memory cell only (booleans and all numeric types of all sizes): 
&lt;code&gt;a == b&lt;/code&gt; holds iff the value of &lt;code&gt;a&lt;/code&gt; is the same as the value of &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For &lt;strong&gt;structured (complex) value types&lt;/strong&gt; we can decide equality by comparing every element of data structures recursively.
At compile time the result of a comparison can be evaluated if the arguments are compile time constants. 
Thus it is technically no problem to compare compile time constants of any value type.&lt;/p&gt;
&lt;p&gt;At runtime a recursive comparison algorithm is too much of a runtime penalty and what looks like a constant time operation turns out to be growing with the dimension of the structure. 
An optimisation of runtime - not changing the run-time complexity but providing better factors - could be achieved by comparing the data structures byte-wise (&lt;code&gt;memcmp&lt;/code&gt;).
But this requires to fix padding in structs and then fails in special cases: 
floating point elements may use different bit representations for the same numerical value, e.g. &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;-0.0&lt;/code&gt;. 
Consequently, the comparison operator for structured data may not be used at runtime (like in C) and results in a type check error.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Reference types are not implemented yet but in principle they will have the same behaviour: compare (dereferenced) values for simple types, and disallow comparison for complex types.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;using-constants&#34;&gt;Using constants&lt;/h2&gt;
&lt;p&gt;In order to make evaluation work for arbitrary constant expressions the names are resolved by the constant values (literals) they represent. 
Thus at the end of the type check phase the declarations of the consts do exist and can be translated to C but all their usages disappear (being substituted by the value).
This has the drawback of less readable C code but still allows to export constants as #defines and use them in foreign code by including the relevant &lt;code&gt;.h&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;In C89, structs can be initialised using structured literals but cannot be assigned new values using structured literals. 
The same is true for arrays in all versions of C. 
Additionally, when calling functions the arguments need to be pointers to memory locations that contain the (structured) data. 
In all these cases, in the generated C code we create a stack local (automatic) temporary variable that is initialised using the literal and then use that variable (or its address) to perform assignments or function calls. 
In summary, literals occur only on the right hand side of initialisation in the generated C code.&lt;/p&gt;
&lt;h2 id=&#34;side-effects-in-conditions-are-not-allowed&#34;&gt;Side effects in conditions are not allowed&lt;/h2&gt;
&lt;p&gt;It is obvious that testing an &lt;code&gt;await&lt;/code&gt; condition may not have any impact on the state to implement a synchronous program. 
Additionally, we forbid side effects in conditions of preemption and all standard, imperative statements. 
This clearly seperates concerns of making decision about the current program state and (possibly) triggering other, (possibly) concurrent computation. 
The common programming practice of C where conditions&amp;rsquo; side effects are used to also advance computation is regarded as bad practice in Blech until proven otherwise.&lt;/p&gt;
&lt;h2 id=&#34;side-effects-are-allowed-in-initialisers&#34;&gt;Side effects are allowed in initialisers&lt;/h2&gt;
&lt;p&gt;Despite the urge to restrict the wild programmer, we allow side effects when declaring and initialising a variable. 
Otherwise the following code that declares an immutable variable cannot be written:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;let status = f()(x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead, we would have to write&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var status: typeOfF
status = f()(x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which not only is longer and less readable but makes &lt;code&gt;status&lt;/code&gt; a mutable variable which is not the intention of the programmer.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Model of execution</title>
      <link>https://www.blech-lang.org/docs/user-manual/controlflow/moc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/controlflow/moc/</guid>
      <description>
        
        
        &lt;h2 id=&#34;reactive-execution&#34;&gt;Reactive execution&lt;/h2&gt;
&lt;p&gt;Unlike classical desktop applications that solve a given task, a Blech application does not run in isolation by itself.
It interacts with a so-called &lt;em&gt;environment&lt;/em&gt; that triggers a &lt;em&gt;reaction&lt;/em&gt; of the Blech program.&lt;/p&gt;
&lt;p&gt;Typically, the environment provides a set of &lt;em&gt;inputs&lt;/em&gt; to a Blech program. These inputs may, for example, be sensor readings.
The environment then expects the Blech program to perform some computations and finally return a set of updated &lt;em&gt;outputs&lt;/em&gt;.
Outputs can be interpreted by the environment, for example, as set points for actuators.&lt;/p&gt;
&lt;p&gt;We deliberately use the generic word &amp;ldquo;environment&amp;rdquo; because depending on the use case it may have a different form. 
It ranges from just a loop that calls the Blech application as soon as the last reaction has finished to a sophisticated real-time operating system which manages several tasks, timers and event queues.&lt;/p&gt;
&lt;p&gt;The Blech program maintains its state from one reaction to the next.
Thus a reaction does not merely depend on the given inputs but also on the state of the program itself.&lt;/p&gt;
&lt;h2 id=&#34;synchrony&#34;&gt;Synchrony&lt;/h2&gt;
&lt;p&gt;Blech is a &lt;em&gt;synchronous&lt;/em&gt; language.
That means its semantics adhere to the &amp;ldquo;synchrony assumption&amp;rdquo;.
In simple terms it states that a reaction happens instantaneously (takes no physical time).
Thus program execution proceeds in discrete reactions and there is no observable behaviour in between.&lt;/p&gt;
&lt;p&gt;This is of course not implementable in reality but rather a guideline for semantics that has implications on language design and induces a set of crucial properties that make the programmer&amp;rsquo;s life easier.&lt;/p&gt;
&lt;p&gt;One implication is that inputs keep their value throughout the reaction. This prevents a volatile behaviour where two readings of the same variable in the same reaction may produce two different values.&lt;/p&gt;
&lt;p&gt;The other implication  is that concurrent computations adhere to a &lt;a href=&#34;https://en.wikipedia.org/wiki/Consistency_model#Strict_consistency&#34; target=&#34;_blank&#34;&gt;strict consistency&lt;/a&gt;
 notion.
In essence, this means that &amp;ldquo;a write to a variable by any thread needs to be seen instantaneously by all threads [&amp;hellip;] it assumes concurrent writes to be impossible&amp;rdquo;.
Therefore race conditions are excluded by design.
Since each concurrent thread of execution perceives the others as instantaneous, every shared variable must assume precisely one value throughout the reaction.
It must not be possible for a reader to read two different values for a shared variable within one reaction.
This would discern computation into (at least two) different logical time steps and violate the assumption that the computation happened instantaneously.&lt;/p&gt;
&lt;p&gt;This semantics is very attractive to the programmer because concurrent programming becomes simple to understand and debug.
It is the single most crucial distinctive feature of synchronous programming languages in general, and Blech in particular.
Usually in asynchronous, thread-based programming this strict consistency notion is impossible to achieve in practice.
However strict consistency becomes possible in our setting because of two ingredients usually not present in asynchronous concurrent programming:
the distinction of individual reactions; and the distinction of a thread-local view and a global view on a shared memory.&lt;/p&gt;
&lt;p&gt;Synchronous languages differ in what programs they admit such that strict consistency is guaranteed. 
Such programs are called causally correct or simply &lt;em&gt;causal&lt;/em&gt;.
The next section explains what this means for Blech.&lt;/p&gt;
&lt;h2 id=&#34;causality&#34;&gt;Causality&lt;/h2&gt;
&lt;p&gt;The strict consistency memory model excludes write conflicts by definition.
Since we think of program execution as reaction steps, this means causal programs must have at most one writer per shared variable in one reaction.
In Blech we restrict this even further and require that there is at most one writer within a fork-join scope which is potentially executed for multiple reactions.
This is made more precise in the subsequent chapter when we explain the &lt;code&gt;cobegin&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;Furthermore, there is a &amp;ldquo;thread-local&amp;rdquo; view of shared variables and a &amp;ldquo;thread-global&amp;rdquo; view.
We require that in the thread-global view every shared variable is set to one value by the writer that all other threads may read.
However the writer-thread may update (and read) the variable multiple times locally.
Thus multiple values exist in the thread-local view but they are not observable by concurrent threads nor by the environment and the &amp;ldquo;illusion&amp;rdquo; of instantaneous updates is maintained.
Only the last written value is communicated to the concurrent readers.
Of course, &amp;ldquo;last&amp;rdquo; is to be understood with respect to the current reaction.
In essence, for every variable there is a write-before-read policy in every reaction.
This allows for normal sequential imperative programming within a thread and at the same time leverages the expressiveness and simplicity of synchronous concurrent programming.
Note that this deliberately excludes programs where threads are mutually (cyclically) dependent within a reaction.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;
There is at most one writer per shared variable. The writer must finish its last writing operation to a shared variable in the current reaction before concurrent readers may read it.
&lt;/div&gt;

&lt;p&gt;The compiler phase that statically ensures a given Blech program is causal is called &lt;em&gt;causality analysis&lt;/em&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Notation</title>
      <link>https://www.blech-lang.org/docs/user-manual/notation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/notation/</guid>
      <description>
        
        
        &lt;p&gt;We use a modified Backus-Naur form notation to describe the Blech language syntax.
The modifications to the original BNF make the rules look more like regular expressions.
We follow the same notation conventions as the &lt;a href=&#34;https://docs.python.org/3/reference/index.html&#34; target=&#34;_blank&#34;&gt;Python language documentation&lt;/a&gt;
. Here is what they write about notation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The descriptions of lexical analysis and syntax use a modified BNF grammar notation. This uses the following style of definition:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The first line says that a &lt;code&gt;name&lt;/code&gt; is an &lt;code&gt;lc_letter&lt;/code&gt; followed by a sequence of zero or more &lt;code&gt;lc_letter&lt;/code&gt;s and underscores. An &lt;code&gt;lc_letter&lt;/code&gt; in turn is any of the single characters &lt;code&gt;&#39;a&#39;&lt;/code&gt; through &lt;code&gt;&#39;z&#39;&lt;/code&gt;. (This rule is actually adhered to for the names defined in lexical and grammar rules in this document.)&lt;/p&gt;
&lt;p&gt;Each rule begins with a name (which is the name defined by the rule) and &lt;code&gt;::=&lt;/code&gt;. A vertical bar (&lt;code&gt;|&lt;/code&gt;) is used to separate alternatives; it is the least binding operator in this notation. A star (&lt;code&gt;*&lt;/code&gt;) means zero or more repetitions of the preceding item; likewise, a plus (&lt;code&gt;+&lt;/code&gt;) means one or more repetitions, and a phrase enclosed in square brackets (&lt;code&gt;[ ]&lt;/code&gt;) means zero or one occurrences (in other words, the enclosed phrase is optional). The &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; operators bind as tightly as possible; parentheses are used for grouping. Literal strings are enclosed in quotes. White space is only meaningful to separate tokens. Rules are normally contained on a single line; rules with many alternatives may be formatted alternatively with each line after the first beginning with a vertical bar.&lt;/p&gt;
&lt;p&gt;In lexical definitions (as the example above), two more conventions are used: Two literal characters separated by three dots mean a choice of any single character in the given (inclusive) range of ASCII characters. A phrase between angular brackets (&lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;) gives an informal description of the symbol defined; e.g., this could be used to describe the notion of ‘control character’ if needed.&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: References in Blech</title>
      <link>https://www.blech-lang.org/docs/language-evolution/borrowing/10_references/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/language-evolution/borrowing/10_references/</guid>
      <description>
        
        
        &lt;h2 id=&#34;parameters-are-references&#34;&gt;Parameters are references&lt;/h2&gt;
&lt;p&gt;Semantically, Blech passes parameters by reference.&lt;/p&gt;
&lt;p&gt;Imagine the following Blech program&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function outIsInPlus1 (a: int32) (b: int32)
    b = 1
    b = a + b 
end

activity godUsage ()
    var i = 42: int32
    var j: int32
    outIsInPlus1(i)(j) // 43 --&amp;gt; j
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So far so good, the program has the expected behaviour: &lt;code&gt;j&lt;/code&gt; gets &lt;code&gt;i + 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But if we call the same function with the same &lt;code&gt;variable&lt;/code&gt; as input and output we get a strange behaviour.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity badUsage ()
    var i = 42: int32
    outIsInPlus1(i)(i)
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If Blech would allow this code and we assume call-by-reference semantics, &lt;code&gt;i&lt;/code&gt; has value &lt;code&gt;2&lt;/code&gt; after the execution of the function.&lt;/p&gt;
&lt;p&gt;This would be an unexpected behavior both from the implementation and the usage point of view.&lt;/p&gt;
&lt;p&gt;The implementation does not take into account that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; may point to the same memory location.
The point of usage we know nothing about the actual implementation. 
The implicit assumption, input &lt;code&gt;a&lt;/code&gt; and output &lt;code&gt;b&lt;/code&gt; must no be the same memory location is not transparent.&lt;/p&gt;
&lt;p&gt;In order to prevent such errors, Blech forbids this usage.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: Read-write conflict. i or an alias thereof occurs both in the input and output list of the sub program call.
  --&amp;gt; incr.blc:3:5 [causality]

3  |     outIsInPlus1(i)(i)
   |                     - Output argument.
3  |     outIsInPlus1(i)(i)
   |                  ^ Input argument.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One might wonder, why a simple increment is allowed&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    i = i + 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;while the call of the function&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    outIsInPlus1(i)(i)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is not.&lt;/p&gt;
&lt;p&gt;The reason is, that parameters are passed by-reference.&lt;/p&gt;
&lt;p&gt;The input &lt;code&gt;a&lt;/code&gt; takes a read-only reference to the actual input, the output &lt;code&gt;b&lt;/code&gt; takes a read-write reference to the actual input.&lt;/p&gt;
&lt;p&gt;Semantically the function &lt;code&gt;outIsInPlus1&lt;/code&gt; has the following form&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function outIsInPlus1 (let ref a: int32) (var ref b: int32)
    b = 1
    b = a + b 
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Blech forbids taking a read-only reference and an read-write reference to the same memory location at the same time.&lt;/p&gt;
&lt;p&gt;Since the compiler rejects such programs, the code generation is free to pass input parameters of functions by value or by reference.
Currently, simple types are passed by reference while composed types are passed by reference.&lt;/p&gt;
&lt;p&gt;Activity parameters have the same pass-by-reference semantics. Due to the nature of activities input parameters must always be passed by-reference in the code generation&lt;/p&gt;
&lt;h2 id=&#34;return-values&#34;&gt;Return values&lt;/h2&gt;
&lt;p&gt;Return values of functions and activities are always passed by value.&lt;/p&gt;
&lt;p&gt;The generated code can either use the stack for simple type returns of functions or write directly to a result location for returned composite values and returned simple values of activities.&lt;/p&gt;
&lt;h2 id=&#34;reference-definitions&#34;&gt;Reference definitions&lt;/h2&gt;
&lt;p&gt;Blech also allows references definitions. They are a restricted form of pointers for expressing aliases and associating data structures.&lt;/p&gt;
&lt;h3 id=&#34;the-benefit-of-references&#34;&gt;The benefit of references&lt;/h3&gt;
&lt;p&gt;References can be used to express aliases.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct S
    var buffer: [3]int32
end

...
    var s: S

    do 
        let i: nat8 = 1
        if s.buffer[i] &amp;gt; 0 then
            s.buffer[i] = s.buffer[i] + 1
        end
    end

    do 
        let i: nat8 = 1
        var ref elem = s.buffer[i]
        if elem &amp;gt; 0 then 
            elem = elem + 1
        end
    end

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This prevents repetition and make a program better readable.&lt;/p&gt;
&lt;p&gt;References can also be used to associate data structures&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;
struct S
    var ref buffer: [3]int32
end


...
    
    var array: [3]int32
    var s: S = {buffer = array}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The variable &lt;code&gt;s&lt;/code&gt; is associated to (points to) the variable &lt;code&gt;array&lt;/code&gt; via the read-write reference &lt;code&gt;s.buffer&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;references-are-not-first-class-types&#34;&gt;References are not first-class types&lt;/h3&gt;
&lt;p&gt;References only occur implicitly as parameters or explicitly as reference definitions.&lt;/p&gt;
&lt;p&gt;Blech implicitly takes references and de-references them if necessary.
There is no such thing like an adress operator &lt;code&gt;&amp;amp;&lt;/code&gt; or a de-referencing operator &lt;code&gt;*&lt;/code&gt; as known from other imperative languages.&lt;/p&gt;
&lt;p&gt;References must be initialised at their declaration.&lt;/p&gt;
&lt;p&gt;This is done when&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;an actual parameter is supplied in a subprogram call, or&lt;/li&gt;
&lt;li&gt;an initialiser is given in a reference declaration.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This enables the compiler to conservatively track reference relationships across the program and in turn enables causality analysis.&lt;/p&gt;
&lt;p&gt;It prevents dangling references and circumvents pointer aliasing problems.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ref&lt;/code&gt; in a reference declaration is also &lt;strong&gt;not&lt;/strong&gt; a type constructor, that might occur anywhere in type expressions.
It is an additional property of a memory location or a value.&lt;/p&gt;
&lt;h3 id=&#34;the-problem-with-references&#34;&gt;The problem with references&lt;/h3&gt;
&lt;p&gt;The use of references can make a program difficult to reason about.&lt;/p&gt;
&lt;p&gt;If we do the same thing as above in sequential code,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var i: int32

let ref a = i
var ref b = i

b = 1
b = a + b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;we run into the same problems: &lt;code&gt;a&lt;/code&gt; is a read-only reference to &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is a read-write reference to &lt;code&gt;i&lt;/code&gt;.
When we change &lt;code&gt;i&lt;/code&gt; via &lt;code&gt;b&lt;/code&gt; we implicitly change the value we get from &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Even in the simple case&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var i: int32

let ref a = i

b = 1
b = a + b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;where we have a read-only reference to &lt;code&gt;i&lt;/code&gt; while at the same time we can change &lt;code&gt;i&lt;/code&gt; directly, we run into the same problems, when reasoning about a program.&lt;/p&gt;
&lt;p&gt;Having a read-only access to a memory location, would not guarantee, that the underlying value does not change.&lt;/p&gt;
&lt;p&gt;With references we need to be able to rule out calls like&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    var i: integer
    let ref a = i
    var ref b = i

    run anActivity(a)(b)
    run anActivity(b)(i)
    run anActivity(i)(b)
    run anActivity(a)(i)

    aFunction(a)(b)
    aFunction(b)(i)
    aFunction(i)(b)
    aFunction(a)(i)

    cobegin 
        run fstTread(a)(i)
    with
        run sndThread(a)(b)
    end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;due to read-write and write-write conflicts.&lt;/p&gt;
&lt;p&gt;With references causality errors might be very difficult to understand and even sequential code is already confusing.&lt;/p&gt;
&lt;p&gt;Luckily there is way of handling these problems at compile time.
In Rust this is called &lt;a href=&#34;../20_borrowing&#34;&gt;&lt;strong&gt;Borrowing Analysis&lt;/strong&gt;&lt;/a&gt;
.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Virtual Safe Lock</title>
      <link>https://www.blech-lang.org/docs/examples/virtuallock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/examples/virtuallock/</guid>
      <description>
        
        
        &lt;p&gt;This document was originally released as supplementary material for the Bosch Conference
on Software Engineering tutorial on Blech. It may be used on its own as a means
to get a first impression of the language and get a Blech project up and running. To
complete the programming assignments a Bosch XDK device is required.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;Blech_Tutorial_BoCSE2019.pdf&#34;&gt;The tutorial (pdf)&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;Code.zip&#34;&gt;Code samples (zip)&lt;/a&gt;
&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Bits and bytes</title>
      <link>https://www.blech-lang.org/docs/language-evolution/bits-and-bytes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/language-evolution/bits-and-bytes/</guid>
      <description>
        
        
        &lt;h2 id=&#34;bits-and-bytes&#34;&gt;Bits and bytes&lt;/h2&gt;
&lt;p&gt;Some notes on &lt;a href=&#34;https://blog.feabhas.com/2014/10/vulnerabilities-in-c-when-integers-go-bad/&#34; target=&#34;_blank&#34;&gt;C’s integers&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Some think, &lt;a href=&#34;https://www.learncpp.com/cpp-tutorial/unsigned-integers-and-why-to-avoid-them/&#34; target=&#34;_blank&#34;&gt;unsigned integers should be avoided&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;For embedded this is not an option.&lt;/p&gt;
&lt;h3 id=&#34;rename-the-exponentiation-operator-&#34;&gt;Rename the exponentiation operator &lt;code&gt;^&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The exponention operator &lt;code&gt;^&lt;/code&gt; should be renamed to &lt;code&gt;**&lt;/code&gt; - maybe right associative.&lt;/p&gt;
&lt;p&gt;Maybe it would be better to deprecate the exponentiation operator completely.
A good argument for this change is given by the &lt;a href=&#34;https://devblogs.microsoft.com/csharpfaq/why-doesnt-c-have-a-power-operator/&#34; target=&#34;_blank&#34;&gt;C# FAQ&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;With this change &lt;code&gt;^&lt;/code&gt; becomes available for the standard bitwise XOR (exclusive or) operation.&lt;/p&gt;
&lt;h3 id=&#34;rename-uint-to-nat&#34;&gt;Rename &lt;code&gt;uint&lt;/code&gt; to &lt;code&gt;nat&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Inspiration &lt;a href=&#34;https://sdk.dfinity.org/language-guide/index.html&#34; target=&#34;_blank&#34;&gt;Motoko&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Reason: &lt;code&gt;uint&lt;/code&gt; is not allowed to overflow and saturates in release code or panics in debug code.
The name &lt;code&gt;uint&lt;/code&gt; addresses the wrong association.
Therefore we should rename &lt;code&gt;uint&lt;/code&gt; to &lt;code&gt;nat&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;NOTE: Maybe we should rename &lt;code&gt;bitsN&lt;/code&gt; to &lt;code&gt;wordN&lt;/code&gt;. 
Those types occur only in 4 different sizes. 
The name &lt;code&gt;bits&lt;/code&gt; might be associated with an arbitrary number.
Additional inspiration, a &lt;a href=&#34;https://whatis.techtarget.com/definition/word&#34; target=&#34;_blank&#34;&gt;word&lt;/a&gt;
 is a unit of data of a defined bit length.
Therefore we should rename &lt;code&gt;bits&lt;/code&gt; to &lt;code&gt;word&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;allow-a-type-annotation-type-for-expressions&#34;&gt;Allow a type annotation &lt;code&gt;:&amp;lt;type&amp;gt;&lt;/code&gt; for expressions&lt;/h3&gt;
&lt;p&gt;It is mainly needed for literals.
It is consistent with type annotation in declarations.&lt;/p&gt;
&lt;p&gt;IMPORTANT: This is not a cast or a conversion, but only a type annotation, to give literals different meanings.&lt;/p&gt;
&lt;h3 id=&#34;eliminate-floatliteral32&#34;&gt;Eliminate &lt;code&gt;floatLiteral32&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Instead of using the specific &lt;code&gt;floatLiteral32&lt;/code&gt; we should use a type annotation.
With a type annotation any number literal can be used as a checked float literal.
This especially simplifies generic code.
Type annotation are anyway needed for binary, octal and hexadecimal literals.&lt;/p&gt;
&lt;p&gt;By default a floatLiteral and hexFloatLiteral are of type &lt;code&gt;float64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;NOTE: Check that hexfloat literals are precise representations for their type.
NOTE: Maybe the default should be &lt;code&gt;float32&lt;/code&gt; for embedded systems?&lt;/p&gt;
&lt;p&gt;Any &lt;code&gt;natLiteral&lt;/code&gt; can be annotated with a float type.
The range is checked, to get a precise float representation.&lt;/p&gt;
&lt;p&gt;The following are all valid float literals.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;
(42: float64)
(42: float32)

(-17: float32)
(-1.2: float32)

42.0 // has type float64
(42.0: float32)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bit-types&#34;&gt;Bit types&lt;/h3&gt;
&lt;p&gt;Bit types allow bitwise, relational, and arithmetic operators.
Arithmetic operators wrap-around.&lt;/p&gt;
&lt;p&gt;Different to &lt;code&gt;nat&lt;/code&gt; types which must not over- or underflow.&lt;/p&gt;
&lt;h3 id=&#34;bitwise-operators&#34;&gt;Bitwise operators&lt;/h3&gt;
&lt;p&gt;Blech provides the standard set of &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operations_in_C&#34; target=&#34;_blank&#34;&gt;bitwise operators known from C&lt;/a&gt;
.
Different to C these operators work on &lt;code&gt;bitsN&lt;/code&gt; types instead of unsigned &lt;code&gt;natN&lt;/code&gt; or signed &lt;code&gt;intN&lt;/code&gt; types.&lt;/p&gt;
&lt;h4 id=&#34;unary-bitwise-operator&#34;&gt;Unary bitwise operator&lt;/h4&gt;
&lt;p&gt;For N = 8, 16, 32, 64&lt;/p&gt;
&lt;p&gt;Bitwise negation: &lt;code&gt;~&lt;/code&gt;
Type: &lt;code&gt;function (bitsN) returns bitsN&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;binary-bitwise-operators&#34;&gt;Binary bitwise operators&lt;/h4&gt;
&lt;p&gt;More info on &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation&#34; target=&#34;_blank&#34;&gt;bitwise operations&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;For N = 8, 16, 32, 64&lt;/p&gt;
&lt;p&gt;Bitwise and: &lt;code&gt;&amp;amp;&lt;/code&gt;
Bitwise or: &lt;code&gt;|&lt;/code&gt;
Bitwise xor: &lt;code&gt;^&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Type: &lt;code&gt;function (bitsN , bitsN) returns bitsN&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;shift-and-rotate-operators&#34;&gt;Shift and rotate operators&lt;/h4&gt;
&lt;p&gt;Standard shift operators&lt;/p&gt;
&lt;p&gt;shift left: &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;
shift right: &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Type: &lt;code&gt;function (bitsN, AnyNat) returns bitsN&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Additionally Blech should provide advanced shift operators&lt;/p&gt;
&lt;p&gt;Arithmetic shift right: &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt;
left rotate: &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&lt;/code&gt;
right rotate: &lt;code&gt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Type: &lt;code&gt;function (bitsN, AnyNat) returns bitsN&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;These operators can be defined as Macros. 
If the macro has a suitable form, C compilers can translate circular shifts into one machine instruction.
C compilers recognize the &lt;a href=&#34;https://en.wikipedia.org/wiki/Circular_shift#Implementing_circular_shifts&#34; target=&#34;_blank&#34;&gt;circular shift idiom&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;The shift and rotate amount is a general unsigned integer type. 
It is considered modulo the &lt;code&gt;bitsN&lt;/code&gt; width &lt;code&gt;N&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;arithmetic-operators&#34;&gt;Arithmetic operators&lt;/h4&gt;
&lt;p&gt;As arithmetic types, &lt;code&gt;bitsN&lt;/code&gt; types implement numeric wrap-around (modulo &lt;code&gt;2**N&lt;/code&gt;).&lt;/p&gt;
&lt;h4 id=&#34;implicit-conversion&#34;&gt;Implicit conversion&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.guru99.com/c-type-casting.html&#34; target=&#34;_blank&#34;&gt;Implicit conversion in C&lt;/a&gt;
 is complicated.&lt;/p&gt;
&lt;p&gt;Implicit conversion is only allowed if no representation change is necessary.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int8&lt;/code&gt; -&amp;gt; &lt;code&gt;int16&lt;/code&gt; -&amp;gt; &lt;code&gt;int32&lt;/code&gt; -&amp;gt; &lt;code&gt;int64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float32&lt;/code&gt; -&amp;gt; &lt;code&gt;float64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nat8&lt;/code&gt; -&amp;gt; &lt;code&gt;nat16&lt;/code&gt; -&amp;gt; &lt;code&gt;nat32&lt;/code&gt; -&amp;gt; &lt;code&gt;nat64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bits8&lt;/code&gt; -&amp;gt; &lt;code&gt;bits16&lt;/code&gt; -&amp;gt; &lt;code&gt;bits32&lt;/code&gt; -&amp;gt; &lt;code&gt;bits64&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IMPORTANT: The representation of &lt;code&gt;char&lt;/code&gt; is still not decided&lt;/p&gt;
&lt;h4 id=&#34;safe-conversion-using-as&#34;&gt;Safe conversion using &lt;code&gt;as&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Conversion using the operator &lt;code&gt;as&lt;/code&gt; can be used for values.
That means:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for right-hand side values&lt;/li&gt;
&lt;li&gt;for function input parameters&lt;/li&gt;
&lt;li&gt;for activity input parameters of simple type: &lt;code&gt;intN&lt;/code&gt;, &lt;code&gt;natN&lt;/code&gt;, &lt;code&gt;bitsN&lt;/code&gt;, &lt;code&gt;floatN&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Conversion with representation change is only allowed if no information is lost (has the same bit-size).&lt;/p&gt;
&lt;h4 id=&#34;no-subtyping-for-bitsn-types&#34;&gt;No subtyping for &lt;code&gt;bitsN&lt;/code&gt; types&lt;/h4&gt;
&lt;p&gt;Whenever &lt;exp&gt; has type T and T &amp;lt;: U (T subtypes U) then by virture of implicit subsumption, &lt;exp&gt; also has type U (without extra syntax).&lt;/p&gt;
&lt;p&gt;In general, this means that an expression of a more specific type may appear wherever an expression of a more general type is expected, provided the specific and general types are related by subtyping.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bitsN&lt;/code&gt; types are in no subtype relation with each other.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bitsN&lt;/code&gt; types are in no subtype relation with other arithmetic types.&lt;/p&gt;
&lt;h3 id=&#34;literals&#34;&gt;Literals&lt;/h3&gt;
&lt;p&gt;Binary, octal and hexadecimal literals have type &lt;code&gt;AnyBits&lt;/code&gt;.
Decimal literals have type &lt;code&gt;AnyInteger&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;All literals of type &lt;code&gt;AnyBits&lt;/code&gt; need a type annotation in order to become an appropriate &lt;code&gt;bitsN&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;A type annotation can be ommited if an assignment determines the type.&lt;/p&gt;
&lt;p&gt;For negative values of type &lt;code&gt;AnyInteger&lt;/code&gt; the two&amp;rsquo;s-complement representation is used to create the bits.&lt;/p&gt;
&lt;p&gt;IMPORTANT: The two&amp;rsquo;s-complement representation for &lt;code&gt;intN&lt;/code&gt; is not mandatory in C.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;let b1: bits8 = 0x1
let b2 = 0x1 : bits8
let b3 = (0x1 : bits8) &amp;lt;&amp;lt; 2  // 0x4 as bits8
let b32 = 0x1A4: bits8   // type error not representable in bits8
let b4: bits8 = 255
let b5 = 255 : bits8 
let b6: bits8 = -129   // type error, no representable as 2-complement in bits8
let b7 = -128: bits8   // ok
let b8 = (-50 - 150): bits8 // compile time error, not representable as 2-complement in bits8
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;use-of-operations&#34;&gt;Use of operations&lt;/h3&gt;
&lt;p&gt;Bitwise operatorions and arithmetic operations cannot be applied to values of type &lt;code&gt;AnyBits&lt;/code&gt;.
Bitwise and arithmetic operations can only be applied to values of type &lt;code&gt;bitsN&lt;/code&gt;, that means the size has to be fixed before any operation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;let x: bits8 = -0x1 // type error size of `0x1` not known, for a suitable unary minus.
let x = -(0x1: bits8) // ok, is (0xFF: bits8), by wrap around.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;hackers-delight-translated-to-blech&#34;&gt;Hacker&amp;rsquo;s Delight translated to Blech&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Hacker%27s_Delight&#34; target=&#34;_blank&#34;&gt;Hacker’s Delight&lt;/a&gt;
 is the definitive source of bitwise programming algorithms. 
It should be possible to use these hacks in Blech.&lt;/p&gt;
&lt;p&gt;Turn off the rightmost 1-bit in a byte, producing 0 if none (e.g. 0b_0101_1000 =&amp;gt; 0b_0101_0000, 0x_00 =&amp;gt; 0x_00).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: bits8
x = x &amp;amp; (x - (1: bits8))
// or
x = x &amp;amp; (x - 0x_01)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Turn on the rightmost 0-bit in a word, producing all 1&amp;rsquo;s if none (e.g. 0x7AF3 =&amp;gt; 0x7AF4, 0xFFFF =&amp;gt; 0xFFFF).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: bits32
x = x | (x + (1: bits32))
// or
x = x | (x + 0b_1)
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Blech Language Services - the VS Code extension</title>
      <link>https://www.blech-lang.org/docs/getting-started/vsce/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/getting-started/vsce/</guid>
      <description>
        
        
        &lt;h2 id=&#34;visual-studio-code-and-the-blech-language-services&#34;&gt;Visual Studio Code and the Blech Language Services&lt;/h2&gt;
&lt;p&gt;We package the Blech Language Servicex as an extension for VS Code that provides two functionalities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;syntax highlighting, and&lt;/li&gt;
&lt;li&gt;a language server which checks the code every time it is saved.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This gives you editing support like code snippets, correct indentation, type checking or causality checking. 
In case of errors, it returns error messages to the user.
It also supports a few basic IDE functionalities.&lt;/p&gt;
&lt;p&gt;In order to use this, install Visual Studio Code (a.k.a. VS Code) either from &lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;https://code.visualstudio.com/&lt;/a&gt; or from &lt;a href=&#34;https://github.com/VSCodium/vscodium/releases&#34;&gt;https://github.com/VSCodium/vscodium/releases&lt;/a&gt;. 
It can be installed locally without admin rights.&lt;/p&gt;
&lt;h2 id=&#34;build-the-extension-from-source&#34;&gt;Build the extension from source&lt;/h2&gt;
&lt;p&gt;The build from source needs &lt;strong&gt;.NET Core&lt;/strong&gt; and &lt;strong&gt;NodeJS&lt;/strong&gt; for the Blech Language Services.&lt;/p&gt;
&lt;p&gt;If you &lt;a href=&#34;https://www.blech-lang.org/docs/getting-started/blechc/#build-blechc-from-source&#34;&gt;built the Blech compiler from source&lt;/a&gt;
 .NET Core is already installed.&lt;/p&gt;
&lt;p&gt;To install NodeJS &lt;a href=&#34;https://nodejs.org/&#34; target=&#34;_blank&#34;&gt;download and install the Long Term Support version&lt;/a&gt;
.
Enclosed is a version of the Node Package Manager &lt;code&gt;npm&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Test it with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm --version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;npm&lt;/code&gt; is frequently updated. In order to keep it up-to-date run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install npm@latest -g
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In most case you should see an upgrade when you run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm --version
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;prerequisites-for-building-the-extension&#34;&gt;Prerequisites for building the extension&lt;/h2&gt;
&lt;p&gt;Clone the &lt;code&gt;blech-tools&lt;/code&gt; repository, including the blech compiler submodule.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone --recurse-submodules https://github.com/boschresearch/blech-tools.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Change to the &lt;code&gt;ide&lt;/code&gt; subdirectory.&lt;/p&gt;
&lt;p&gt;Install the node package &lt;code&gt;vsce&lt;/code&gt;, which is able to package VS Code extensions.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm -g install vsce
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Install the Typescript node package. Typescript is a the typed superset of JavaScript, which is used to build the extension.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm -g install typescript
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Install the necessary node modules for this project.
From the &lt;code&gt;ide&lt;/code&gt; subdirectory run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Optionally: Run the TypeScript compilation.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm run compile
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you like, you can learn more about &lt;a href=&#34;https://www.typescriptlang.org&#34; target=&#34;_blank&#34;&gt;the TypeScript language&lt;/a&gt;
, which is created by Microsoft.&lt;/p&gt;
&lt;h2 id=&#34;build-the-extension&#34;&gt;Build the extension&lt;/h2&gt;
&lt;p&gt;Besides syntax highlighting the Blech Language Services consisting of two parts which need to be compiled.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;A language server written in F#, which is a small wrapper around the Blech compiler.&lt;/p&gt;
&lt;p&gt;The language server is build using dotnet. From the &lt;code&gt;ide&lt;/code&gt; subdirector run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dotnet publish -c Release -o bin -r win-x64 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Choose your runtime above &lt;a href=&#34;https://docs.microsoft.com/de-de/dotnet/core/rid-catalog&#34; target=&#34;_blank&#34;&gt;as necessary&lt;/a&gt;
 (&lt;code&gt;linux-x64&lt;/code&gt;, &lt;code&gt;linux-arm64&lt;/code&gt;, &lt;code&gt;osx-x64&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A VS code extension, which runs a client to the language server.
To build and package the client and the server as an extension run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vsce package
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you get a security warning when using Windows powershell. Try running it from &lt;code&gt;cmd&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This gives you a &lt;code&gt;blech-language-services-0.&amp;lt;i&amp;gt;.&amp;lt;j&amp;gt;.vsix&lt;/code&gt; file in the same directory.&lt;/p&gt;
&lt;h2 id=&#34;install-the-extension&#34;&gt;Install the extension&lt;/h2&gt;
&lt;p&gt;You can install the Blech Language Services VS Code extension via the commandline or interactively.&lt;/p&gt;
&lt;p&gt;From the command line go to the &lt;code&gt;ide&lt;/code&gt; subdirectory run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code blech-language-services-0.&amp;lt;i&amp;gt;.&amp;lt;j&amp;gt;.vsix
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;with the correct version number.&lt;/p&gt;
&lt;p&gt;If VS Code is already running: 
Open the Extension section, go to the &lt;code&gt;...&lt;/code&gt; menu, and select &lt;code&gt;Install from VSIX...&lt;/code&gt;.
Select the &lt;code&gt;blech-language-services-0.&amp;lt;i&amp;gt;.&amp;lt;j&amp;gt;.vsix&lt;/code&gt; file to install the extension.&lt;/p&gt;
&lt;p&gt;Verify it works by opening some &lt;code&gt;*.blc&lt;/code&gt; file. 
If the keywords are coloured, it works. 
Furthermore, if you hover over an activity name, you should see its signature in a tooltip.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Blinker</title>
      <link>https://www.blech-lang.org/docs/examples/blinker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/examples/blinker/</guid>
      <description>
        
        
        &lt;p&gt;The first community made demo for Blech is the implementation of a &lt;a href=&#34;https://github.com/frameworklabs/blinker&#34; target=&#34;_blank&#34;&gt;car’s blinker&lt;/a&gt;
 running in a simulated curses environment.
Making use of Blech&amp;rsquo;s reactive programming model and concurrent composition, this example shows how a rather complex state management logic can be decomposed into individual simple building blocks.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Borrowing for references</title>
      <link>https://www.blech-lang.org/docs/language-evolution/borrowing/20_borrowing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/language-evolution/borrowing/20_borrowing/</guid>
      <description>
        
        
        &lt;h1 id=&#34;borrowing&#34;&gt;Borrowing&lt;/h1&gt;
&lt;p&gt;The solution to the &lt;a href=&#34;../10_references/#the-problem-with-references&#34;&gt;problems with references&lt;/a&gt;
 is &lt;strong&gt;Borrowing analysis&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;borrowing-in-rust&#34;&gt;Borrowing in Rust&lt;/h2&gt;
&lt;p&gt;A Rust program very similar to the introductory example (../10_references/#parameters-are-references)
looks like the following&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;outIsInPlus1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;outIsInPlus1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Function &lt;code&gt;outIsInPlus1&lt;/code&gt; gets a read-only (immutable) reference &lt;code&gt;a&lt;/code&gt; and a read-write (mutable) reference &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Rust does not allow this call to &lt;code&gt;outIsInPlus1&lt;/code&gt;.
The so-called borrow checker detects an error.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;error[E0502]: cannot borrow `i` as mutable because it is also borrowed as immutable
 --&amp;gt; src/example.rs:9:11
  |
9 |     outIsInPlus1(&amp;amp;i, &amp;amp;mut i);
  |     ------------ --  ^^^^^^ mutable borrow occurs here
  |     |            |
  |     |            immutable borrow occurs here
  |     immutable borrow later used by call

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Rust does not allow to borrow a mutable and an immutable reference to a memory location in the same scope.&lt;/p&gt;
&lt;p&gt;In Blech this test is currently implemented as part of the causality analysis.&lt;/p&gt;
&lt;h2 id=&#34;behaviour-of-the-rust-borrow-checker&#34;&gt;Behaviour of the Rust borrow checker&lt;/h2&gt;
&lt;p&gt;A good overview of how borrowing restricts the usage of variables and references can be found in a &lt;a href=&#34;https://rufflewind.com/2017-02-15/rust-move-copy-borrow#comments&#34; target=&#34;_blank&#34;&gt;Graphical depiction of ownership and borrowing in Rust&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Move semantics can be neglected for the moment because it deals with memory management of heap allocated data. 
Currently Blech does not dynamically allocate heap data for safety and real-time reasons.&lt;/p&gt;
&lt;p&gt;For borrowing it distinguishes between &lt;em&gt;frozen&lt;/em&gt; and &lt;em&gt;locked&lt;/em&gt; behaviour.&lt;/p&gt;
&lt;p&gt;Mutable borrowing, &lt;em&gt;locks&lt;/em&gt; the original object for the duration of the borrow, rendering it unusable.&lt;/p&gt;
&lt;p&gt;Non-mutable borrowing &lt;em&gt;freezes&lt;/em&gt; the original object, you can still take more non-mutable references, but you cannot move or take mutable references of it.&lt;/p&gt;
&lt;h2 id=&#34;borrowing-in-blech&#34;&gt;Borrowing in Blech&lt;/h2&gt;
&lt;p&gt;If we adopt borrow semantics in Blech, the compiler would reject the program, which has been discussed as problematic.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var i: int32

let ref a = i
var ref b = i

b = 1
b = a + b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The analog program in Rust&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;cannot be compiled due to a borrowing error&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0502]: cannot borrow `i` as mutable because it is also borrowed as immutable
 --&amp;gt; src/main.rs:5:13
  |
4 |     let a = &amp;amp;i;
  |             -- immutable borrow occurs here
5 |     let b = &amp;amp;mut i;
  |             ^^^^^^ mutable borrow occurs here
...
8 |     *b = *a + *b;
  |          -- immutable borrow later used here
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For Blech we should also implemented a borrowing check.&lt;/p&gt;
&lt;h2 id=&#34;intuitive-behaviour-of-the-borrow-checker&#34;&gt;Intuitive behaviour of the borrow checker.&lt;/h2&gt;
&lt;p&gt;Borrow checking restricts the use borrowed references inside the same scope.&lt;/p&gt;
&lt;p&gt;The scope is either a statement scope or the entrance of a subprogram.&lt;/p&gt;
&lt;p&gt;In the same scope we can either&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;take several &lt;code&gt;let ref&lt;/code&gt;s or&lt;/li&gt;
&lt;li&gt;one &lt;code&gt;var ref&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;to a memory location.&lt;/p&gt;
&lt;p&gt;In both cases the original name for the memory location is no longer accessible.
If we switch to a separate scope we can take a mutable and after that an immutable borrowing. 
The reason is, that the borrow reference name is no longer visible if the scope is left.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var i: int32

do  // increment i via b
    var ref b = i  // read-write (mutable) borrow
    // i is locked
    b = b + 1    
end

// read i via a
let ref a = i     // read-only (immutable) borrow
// i is frozen
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;parameter-passing-is-borrowing-too&#34;&gt;Parameter passing is borrowing too&lt;/h2&gt;
&lt;p&gt;Passing parameters is also borrowing in a new scope.
All parameters are regarded borrows in the scope of the subprogram.&lt;/p&gt;
&lt;p&gt;Therefore the following Blech code would also be rejected by a borrow checker.&lt;/p&gt;
&lt;p&gt;The call takes a &lt;code&gt;let ref&lt;/code&gt; (immutable) borrow and a &lt;code&gt;var ref&lt;/code&gt; (mutable) borrow at the same time.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    var i: int32
    outIsInPlus1(i)(i)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to correct this we need an additional memory location,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    var i: int32
    let j = i  // read-only j gets value from i
    outIsInPlus1(j)(i)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The implementor of function &lt;code&gt;outIsInPlus1&lt;/code&gt; can assume that the actual parameters never overlap in their memory location.&lt;/p&gt;
&lt;p&gt;This check - which currently is implemented in the causality analysis - can be moved to a borrow checker, which would simplify the causality analysis.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: C bindings</title>
      <link>https://www.blech-lang.org/docs/language-evolution/blech-c-interface/c-bindings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/language-evolution/blech-c-interface/c-bindings/</guid>
      <description>
        
        
        &lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;
&lt;p&gt;Re-arranging parameters in C function calls is currently not possible.&lt;/p&gt;
&lt;p&gt;Output parameters in C are not always at the end of the parameter list.
For example, a function like &lt;code&gt;strcpy&lt;/code&gt; can not be used from Blech via a simple &lt;code&gt;extern function&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;strcpy&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;restrict&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;restrict&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The C function &lt;code&gt;strcpy&lt;/code&gt; copies &lt;code&gt;s2&lt;/code&gt; to &lt;code&gt;s1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;extern&lt;/code&gt; function declaration in Blech would put the target &lt;code&gt;toString&lt;/code&gt; in the output parameter list.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding =&amp;quot;strcpy&amp;quot;, header = &amp;quot;string.h&amp;quot;)]
extern function stringCopy (fromString: string)(toString: string)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Given that we currently do not support strings, which is another future topic, 
the order of input and output parameters cannot be rearranged for the bound C function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[EntryPoint]
activity Main () ()
    let s2 = &amp;quot;hello&amp;quot;
    var s1: string
    stringCopy(s2)(s1)

    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When we call &lt;code&gt;stringCopy&lt;/code&gt; from Blech we actually we like to call &lt;code&gt;strcpy&lt;/code&gt; in C directly.
This is currently not possible.&lt;/p&gt;
&lt;h2 id=&#34;proposal&#34;&gt;Proposal&lt;/h2&gt;
&lt;p&gt;Specifiy the full C function by indexing Blech identifiers&lt;/p&gt;
&lt;p&gt;This could be done by using the parameter names in a macro-like fashion.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;strcpy($2, $1)&amp;quot; , header = &amp;quot;string.h&amp;quot;)]
extern function stringCopy (formString: string)(toString: string)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The Blech identifiers in the extern declaration can be addressed via &lt;code&gt;$i&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$0&lt;/code&gt; is &lt;code&gt;stringCopy&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt; is &lt;code&gt;fromString&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; is &lt;code&gt;toString&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For code generation we would create the C macro by subsituting the Blech parameter names.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define blc_stringCopy(blc_fromString, blc_toString) strcpy(blc_toString, blc_fromString)
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As usual it is the reponsibility of the programmer to guarantee correct types, additionially the indexing of identifiers must be correct.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;strings&lt;/code&gt; will become &lt;code&gt;structs&lt;/code&gt; with &lt;code&gt;len&lt;/code&gt; field and a &lt;code&gt;buf&lt;/code&gt; reference.
The extern declaration could look like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;do { strcpy($2.buf, $1.buf); $2.len = $1.len; } while (0)&amp;quot; , header = &amp;quot;string.h&amp;quot;)]
extern function stringCopy (formString: string)(toString: string)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which would create the following macro&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define blc_stringCopy(blc_fromString, blc_toString) \ 
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;do&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;strcpy&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;blc_toString&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_fromString&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_toString&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_fromString&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As always with C code, this code is unsafe, because Blech cannot check the buffer sizes - actually the compiler does not know anything about copying or the semantics of the function call.&lt;/p&gt;
&lt;p&gt;Perhaps we should also allow multi-line strings in attributes and later on in string literals, for better formatting of long strings.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Lexical elements</title>
      <link>https://www.blech-lang.org/docs/user-manual/lexical/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/lexical/</guid>
      <description>
        
        
        &lt;h2 id=&#34;comments&#34;&gt;Comments&lt;/h2&gt;
&lt;p&gt;Single line comments are C++ style. They begin with &lt;code&gt;//&lt;/code&gt; and end with the end of line.&lt;/p&gt;
&lt;p&gt;Multi-line comments are C style. They begin with &lt;code&gt;/*&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. 
Comment nesting is supported.&lt;/p&gt;
&lt;h3 id=&#34;declaration-comments&#34;&gt;Declaration Comments&lt;/h3&gt;
&lt;p&gt;A special comment syntax allows to write comments for declarations (functions, activities, types, variables, &amp;hellip;) which will be transported over to the generated C code.
This allows to document the API and make this documentation available to the C programmer who integrates generated code in a larger scope.&lt;/p&gt;
&lt;p&gt;There are two supported styles of declaration comments.
Java style multi-line comments &lt;code&gt;/** */&lt;/code&gt; and .Net style single line comments &lt;code&gt;///&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that using declaration comments before something that is not a declaration, e.g. an assignment, is a syntax error.&lt;/p&gt;
&lt;h2 id=&#34;built-in-operators-and-separators&#34;&gt;Built-in Operators and Separators&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operators and Separators&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Logical operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;not&lt;/code&gt; &lt;code&gt;and&lt;/code&gt; &lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arithmetic operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bitwise operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Relational operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Type conversion&lt;/td&gt;
&lt;td&gt;&lt;code&gt;as&lt;/code&gt; &lt;code&gt;as!&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Separators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;;&lt;/code&gt; &lt;code&gt;:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;keywords&#34;&gt;Keywords&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;abort&lt;/code&gt;
&lt;code&gt;activity&lt;/code&gt;
&lt;code&gt;and&lt;/code&gt;
&lt;code&gt;as&lt;/code&gt; 
&lt;code&gt;await&lt;/code&gt;
&lt;code&gt;bits8&lt;/code&gt;
&lt;code&gt;bits16&lt;/code&gt; 
&lt;code&gt;bits32&lt;/code&gt;
&lt;code&gt;bits64&lt;/code&gt;
&lt;code&gt;blech&lt;/code&gt;
&lt;code&gt;bool&lt;/code&gt;
&lt;code&gt;cobegin&lt;/code&gt;
&lt;code&gt;const&lt;/code&gt;
&lt;code&gt;do&lt;/code&gt;
&lt;code&gt;else&lt;/code&gt;
&lt;code&gt;elseif&lt;/code&gt;
&lt;code&gt;end&lt;/code&gt;
&lt;code&gt;extern&lt;/code&gt;
&lt;code&gt;false&lt;/code&gt;
&lt;code&gt;float32&lt;/code&gt;
&lt;code&gt;float64&lt;/code&gt;
&lt;code&gt;function&lt;/code&gt;
&lt;code&gt;if&lt;/code&gt;
&lt;code&gt;int8&lt;/code&gt;
&lt;code&gt;int16&lt;/code&gt;
&lt;code&gt;int32&lt;/code&gt;
&lt;code&gt;int64&lt;/code&gt;
&lt;code&gt;let&lt;/code&gt;
&lt;code&gt;nat8&lt;/code&gt;
&lt;code&gt;nat16&lt;/code&gt;
&lt;code&gt;nat32&lt;/code&gt;
&lt;code&gt;nat64&lt;/code&gt;
&lt;code&gt;not&lt;/code&gt;
&lt;code&gt;or&lt;/code&gt;
&lt;code&gt;param&lt;/code&gt;
&lt;code&gt;prev&lt;/code&gt;
&lt;code&gt;repeat&lt;/code&gt;
&lt;code&gt;run&lt;/code&gt;
&lt;code&gt;reset&lt;/code&gt;
&lt;code&gt;return&lt;/code&gt;
&lt;code&gt;returns&lt;/code&gt;
&lt;code&gt;singleton&lt;/code&gt;
&lt;code&gt;struct&lt;/code&gt;
&lt;code&gt;then&lt;/code&gt;
&lt;code&gt;true&lt;/code&gt;
&lt;code&gt;until&lt;/code&gt;
&lt;code&gt;var&lt;/code&gt;
&lt;code&gt;weak&lt;/code&gt;
&lt;code&gt;when&lt;/code&gt;
&lt;code&gt;while&lt;/code&gt;
&lt;code&gt;with&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Note that the current compiler implementation may reserve more keywords than listed here.
This is because the language is still growing and there are concepts that are yet to be fully implemented but already exist on the syntactical level.&lt;/p&gt;
&lt;h2 id=&#34;identifiers&#34;&gt;Identifiers&lt;/h2&gt;
&lt;p&gt;An identifier is any token that is not a keyword and starts with a letter or underscore and continues with an arbitrary number of letters, digits or underscores.
The precise definition is given by the following grammar rule&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;Z&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+ &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;Z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that identifiers have an infix of at least one letter.&lt;/p&gt;
&lt;h2 id=&#34;wildcard&#34;&gt;Wildcard&lt;/h2&gt;
&lt;p&gt;Additionally we reserve a token that consists of underscores only.
We call this the &amp;ldquo;wildcard&amp;rdquo;. Wildcards are useful when you want to discard the result of a computation without declaring a dummy variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;_ = f()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example you cannot just call &lt;code&gt;f&lt;/code&gt; like in C because the Blech compiler will complain that &lt;code&gt;f&lt;/code&gt; is declared to return a value but there is no location to store this value in. The wildcard makes the intention to discard the returned value &lt;em&gt;explicit&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;literals&#34;&gt;Literals&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;        ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;NonZeroDigit&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;BinInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0b&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+
&lt;span style=&#34;color:#000&#34;&gt;OctInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0o&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;7&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+
&lt;span style=&#34;color:#000&#34;&gt;HexInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;f&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;F&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+  
&lt;span style=&#34;color:#000&#34;&gt;DecInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;NonZeroDigit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;Integer&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DecInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;BinInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;OctInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;HexInteger&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;FloatNumber&lt;/span&gt;   ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ExponentFloat&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt;    ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Fraction&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Fraction&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ExponentFloat&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;exponent&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Exponent&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;e&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;E&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>About: Privacy policy</title>
      <link>https://www.blech-lang.org/about/privacy-policy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/about/privacy-policy/</guid>
      <description>
        
        
        &lt;h3 id=&#34;github-pages-service&#34;&gt;GitHub Pages Service&lt;/h3&gt;
&lt;p&gt;This Website is hosted as a GitHub Pages website. 
GitHub may collect User Personal Information from visitors to this GitHub Pages website, including logs of visitor IP addresses, to comply with legal obligations, and to maintain the security and integrity of this Website and the Service. 
See the &lt;a href=&#34;https://help.github.com/en/github/site-policy/github-privacy-statement&#34; target=&#34;_blank&#34;&gt;GitHub Privacy Statement&lt;/a&gt;
 for details.&lt;/p&gt;
&lt;h3 id=&#34;this-website&#34;&gt;This Website&lt;/h3&gt;
&lt;p&gt;This Website does &lt;strong&gt;not&lt;/strong&gt; collect data or use cookies &lt;strong&gt;by default&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In order to improve the content and the experience on the website we kindly ask you to allow the usage of site analytics. If you opt-in to this service we use cookies to collect anonymous usage data.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can learn about cookies and site analytics at &lt;a href=&#34;https://www.cookiechoices.org/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.cookiechoices.org&#34;&gt;www.cookiechoices.org&lt;/a&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;opt-in-for-google-analytics&#34;&gt;Opt-in for Google Analytics&lt;/h3&gt;
&lt;p&gt;You can opt-in for site analytics, in this opt-in notice&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.blech-lang.org/images/opt-in-notice.png&#34; alt=&#34;Opt-in notice&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you &lt;code&gt;Opt-in&lt;/code&gt; we use site analytics to collect your anonymous resource usage data.&lt;/li&gt;
&lt;li&gt;If you close &lt;code&gt;x&lt;/code&gt; this notice, no data will be collected.&lt;/li&gt;
&lt;li&gt;We use a cookie to remember your decision.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After your opt-in we use &lt;a href=&#34;https://marketingplatform.google.com/about/analytics/features/&#34; target=&#34;_blank&#34;&gt;Google Analytics&lt;/a&gt;
 tracking on
this website, which uses cookies for this purpose.&lt;/p&gt;
&lt;p&gt;We are interested in understanding&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;what pages you visited and for how long,&lt;/li&gt;
&lt;li&gt;what site referred you to this web page,&lt;/li&gt;
&lt;li&gt;what types of content and topic areas you are interested in,&lt;/li&gt;
&lt;li&gt;including what content or sections never get viewed or used.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Your IP-Adress is anonymized, so we do &lt;strong&gt;not&lt;/strong&gt; store wether you have been to the site before.&lt;/p&gt;
&lt;h3 id=&#34;do-not-track&#34;&gt;Do not track&lt;/h3&gt;
&lt;p&gt;We respect your &lt;a href=&#34;https://en.wikipedia.org/wiki/Do_Not_Track&#34; target=&#34;_blank&#34;&gt;Do-Not-Track&lt;/a&gt;
 settings if your browser requests this.&lt;/p&gt;
&lt;p&gt;This means, you will never see the above opt-in notice, if you configured your browser for Do-Not-Track.
No cookies will be set. Google Analytics will not be used.&lt;/p&gt;
&lt;h3 id=&#34;linked-services&#34;&gt;Linked services&lt;/h3&gt;
&lt;p&gt;This website contains links to other services. If you follow these links you should become aware of their terms of service.&lt;/p&gt;
&lt;p&gt;We link to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://help.github.com/en/github/site-policy/github-terms-of-service&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;
 for documentation, compiler and tools repositories.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://policies.google.com/terms&#34; target=&#34;_blank&#34;&gt;Google Groups&lt;/a&gt;
 for Blech user questions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://slack.com/terms-of-service&#34; target=&#34;_blank&#34;&gt;Slack&lt;/a&gt;
 for Blech developer discussions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/tos&#34; target=&#34;_blank&#34;&gt;Twitter&lt;/a&gt;
 for announcements.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additional links might occur in the documentation and the blog posts.&lt;/p&gt;
&lt;h3 id=&#34;manage-cookies&#34;&gt;Manage cookies&lt;/h3&gt;
&lt;p&gt;You can manually delete and restrict the use of cookies in your web browser.&lt;/p&gt;
&lt;p&gt;Learn how to manage cookies for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://support.apple.com/guide/safari/manage-cookies-and-website-data-sfri11471/mac&#34; target=&#34;_blank&#34;&gt;Apple Safari&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://support.google.com/chrome/bin/answer.py?hl=en-GB&amp;amp;answer=95647&amp;amp;p=cpn_cookies&#34; target=&#34;_blank&#34;&gt;Google Chrome&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://support.microsoft.com/help/4027947/microsoft-edge-delete-cookies&#34; target=&#34;_blank&#34;&gt;Microsoft Edge&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://support.microsoft.com/help/17442/windows-internet-explorer-delete-manage-cookies&#34; target=&#34;_blank&#34;&gt;Microsoft Internet Explorer&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://support.mozilla.org/products/firefox/protect-your-privacy/cookies&#34; target=&#34;_blank&#34;&gt;Mozilla Firefox&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Statements</title>
      <link>https://www.blech-lang.org/docs/user-manual/controlflow/statements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/controlflow/statements/</guid>
      <description>
        
        
        &lt;p&gt;In its core, Blech is an imperative language.
Blech strictly separates between &lt;em&gt;statements&lt;/em&gt; that govern the flow of control and &lt;em&gt;expressions&lt;/em&gt; that evaluate to a value.
Both, a statement and an expression may have side-effects.&lt;/p&gt;
&lt;h2 id=&#34;activities-and-functions&#34;&gt;Activities and functions&lt;/h2&gt;
&lt;p&gt;Control flow is organised with two kinds of procedures: &lt;em&gt;activities&lt;/em&gt; and &lt;em&gt;functions&lt;/em&gt;.
Functions are used like in any other imperative language.
In Blech they have two parameter lists to support causality analysis.&lt;/p&gt;
&lt;p&gt;See the section on &lt;a href=&#34;../../declarations/#subprograms&#34;&gt;subprogram declarations&lt;/a&gt;
 for more details.&lt;/p&gt;
&lt;p&gt;Functions must terminate within a reaction. Therefore they are said to be instantaneous.&lt;/p&gt;
&lt;p&gt;Activities are called similarly to functions but their execution continues until it reaches a pause to end the current reaction.
In the next reaction they resume from the location they have paused and continue execution until the next pause.
Each reaction of an activity must end after finitely many computation steps.
However the activity itself may perform an unbounded number of reactions and never terminate.
It may also terminate after a finite number of reactions.
In any case, activities must not be instantaneous&amp;mdash;they need to pause at least once before termination.
The values of local variables in activities are stored from one reaction to the next.&lt;/p&gt;
&lt;p&gt;Activities may call other activities or functions.
Functions however can only call other functions.&lt;/p&gt;
&lt;h2 id=&#34;synchronous-statements&#34;&gt;Synchronous statements&lt;/h2&gt;
&lt;p&gt;Here we discuss statements that are specific to the synchronous paradigm of Blech.
These statements control the reactive behaviour of the program and hence may only appear inside activities, not in functions.&lt;/p&gt;
&lt;h3 id=&#34;await&#34;&gt;Await&lt;/h3&gt;
&lt;p&gt;The aforementioned &amp;ldquo;pause&amp;rdquo; is denoted as follows.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Pause&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;await&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;await&lt;/code&gt; statement marks the end of a reaction.
The control flow stops at this statement and the program &amp;ldquo;waits&amp;rdquo; for the next reaction to start.
Once an activity resumes its execution at an &lt;code&gt;await&lt;/code&gt; statement the condition is checked.
If it is true, the control flow proceeds to the next statement.
Otherwise, the reaction ends immediately and the control flow remains at the same location.&lt;/p&gt;
&lt;h4 id=&#34;example-simple-reactive-control-flow&#34;&gt;Example: Simple reactive control flow&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity MyAct (in1: bool, in2: float32) (out1: uint8)
    repeat
        await in1
        out1 = (out1 + 1) % 100 // count from 0 to 99
    until in2 &amp;lt; 0.0 end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Initially, &lt;code&gt;MyAct&lt;/code&gt; is entered and the control flow proceeds to line 3 and stops (regardless of the inputs).
In the next tick, &lt;code&gt;MyAct&lt;/code&gt; resumes its execution at the &lt;code&gt;await&lt;/code&gt; statement in line 3.
It checks the boolean input variable &lt;code&gt;in1&lt;/code&gt;.
If it is false, the reaction ends immediately, the control flow does not advance.
Otherwise, if &lt;code&gt;in1&lt;/code&gt; is true, the calculation is carried out in line 4.
This updates &lt;code&gt;out1&lt;/code&gt; to a new value.
Finally, if input &lt;code&gt;in2&lt;/code&gt; is indeed less than 0 the activity terminates its execution.
Otherwise the control flow loops around from line 5 back to line 2 and finally the reaction ends again in line 3.&lt;/p&gt;
&lt;h3 id=&#34;run&#34;&gt;Run&lt;/h3&gt;
&lt;p&gt;An activity call is given by the following grammar.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ActivityCall&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Wildcard&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;run&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;()&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;()&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsExpr&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsExpr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; keyword indicates an activity call.
Arguments must be provided that match the callee&amp;rsquo;s declaration in number and type.
If the callee does not declare any outputs the second pair of parentheses may be dropped for readability.
Input arguments must evaluate to a value that matches the declared type.
Output arguments must evaluate to a memory location that the callee can read from and write to.
If the callee is an activity that eventually terminates and declares a return value, this return value must be either received into some variable or ignored using a wildcard.&lt;/p&gt;
&lt;p&gt;When control flow reaches a &lt;code&gt;run&lt;/code&gt; statement the sub-activity is immediately called and the control flow is handed over to the callee.
It remains within the callee for as many reactions as it runs (but at least one reaction).
In every reaction inputs are passed though to the callee and its outputs are propagated outside.
Should the callee terminate, the control flow returns to the caller and proceeds with the next statement.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;// declaration
activity A (a: [8]int32, b: int32) (c: int32) returns bool
    /* some code */
    ...
end

    /* ... inside another activity ... */
    var result: bool
    var array: [8]int32 = {1, 2, 3, 4, 5, 6, 7, 8}
    var output: int32
    // usage
    result = run A(array, 7)(output)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;cobegin&#34;&gt;Cobegin&lt;/h3&gt;
&lt;p&gt;Concurrent composition is expressed with the &lt;code&gt;cobegin&lt;/code&gt; statement.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ForkJoin&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;cobegin&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;weak&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;with&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;weak&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+ &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Using &lt;code&gt;cobegin&lt;/code&gt; it is possible to compose arbitrary pieces of code.
The goal is not to parallelise to gain execution speed.
Rather this the language construct to express that two (or more) functionalities should be computed within the same reaction.
As such concurrency is rather a modelling concept in Blech.
The code generator will actually sequentialise the code in a causally correct order.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
In the future there will be the possibility to specify truly parallel executions in Blech which can be carried out independently.
&lt;/div&gt;

&lt;h4 id=&#34;example-concurrent-composition&#34;&gt;Example: Concurrent composition&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity P ()
    var x: int32
    var y: int32
    var z: int32
    cobegin
        run A(x)(z)
    with
        run B(y)(x)
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Assume the activities &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; have already been implemented.
In lines 5 &amp;ndash; 9 they are composed concurrently.
This means the control flow of &lt;code&gt;P&lt;/code&gt; is forked into two control flow points.
One resides in &lt;code&gt;A&lt;/code&gt; (line 6) and one in &lt;code&gt;B&lt;/code&gt; (line 8).
With every tick both, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, will perform one reaction.
When both subprograms terminate, &lt;code&gt;P&lt;/code&gt; regains control in line 9 and, in this example, terminates too.
Of course, more than two branches can be combined using more &lt;code&gt;with&lt;/code&gt; branches.
Note that the reaction of &lt;code&gt;B&lt;/code&gt; will be carried out before the reaction of &lt;code&gt;A&lt;/code&gt; due to causality:
First the unique value of &lt;code&gt;x&lt;/code&gt; needs to be set by writer &lt;code&gt;B&lt;/code&gt; before the reader &lt;code&gt;A&lt;/code&gt; may use it.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;cobegin&lt;/code&gt; statement is a composite statement like a &lt;code&gt;repeat&lt;/code&gt; loop or an &lt;code&gt;if&lt;/code&gt; statement.
Control flow can remain within the &lt;code&gt;cobegin&lt;/code&gt; branches for multiple reactions.
However in general the various branches can perform a different number of reactions, possibly infinitely many.
We therefore need to control the termination of &lt;code&gt;cobegin&lt;/code&gt; as a whole using the &lt;code&gt;weak&lt;/code&gt; qualifiers.&lt;/p&gt;
&lt;p&gt;Formally, a &lt;code&gt;cobegin&lt;/code&gt; statement terminates in the reaction in which all strong branches have terminated.
If all branches are weak, the &lt;code&gt;cobegin&lt;/code&gt; statement terminates in the reaction in which some branch terminates.&lt;/p&gt;
&lt;p&gt;In the above example no branch is &lt;code&gt;weak&lt;/code&gt;.
We say all branches are &amp;ldquo;strong&amp;rdquo;.
This means the &lt;code&gt;cobegin&lt;/code&gt; statement terminates when &lt;em&gt;all&lt;/em&gt; of its branches have terminated.
Branches that finish earlier (have fewer reaction to do) will simply do nothing until the last strong branch has terminated.
The following two examples illustrate the usage of the &lt;code&gt;weak&lt;/code&gt; qualifier.&lt;/p&gt;
&lt;h4 id=&#34;example-weak-and-strong-branches&#34;&gt;Example: Weak and strong branches&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;/* ... inside some activity ... */
var res: nat8
cobegin weak
    // non-terminating branch
    repeat
        await true
        out1 = (out1 + 1) % 100
    end
with
    // terminates once a key is pressed
    res = run ReadKeyStroke()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first branch contains an infinite loop in the sense that every iteration ends in a pause but the number of reactions is unbounded.
The loop is placed into a weak branch that allows to terminate the loop at the end of some reaction.
The second branch contains an activity call that is expected to return some value eventually.
In the reaction in which the result is returned the weak branch will be aborted (after it has done one iteration) and the control flow continues with the next statement following the &lt;code&gt;cobegin&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;example-all-branches-weak&#34;&gt;Example: All branches weak&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;cobegin weak
    await isButtonPressed
with weak
    await hasReceivedSignal
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example there are no strong branches.
The first branch to terminate will abort all others.
In this example it means as soon as &lt;code&gt;isButtonPressed&lt;/code&gt; or &lt;code&gt;hasReceivedSignal&lt;/code&gt; is true (or both are true!) the &lt;code&gt;cobegin&lt;/code&gt; statement terminates and control flow continues with the next statement.&lt;/p&gt;
&lt;h3 id=&#34;abort-and-reset&#34;&gt;Abort and reset&lt;/h3&gt;
&lt;p&gt;There are two kinds of synchronous preemptions built into Blech.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Preemption&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;when&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;abort&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;reset&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When control flow enters a preemption the statements in its body, denoted by &lt;code&gt;StmtBlock&lt;/code&gt; in the grammar, are executed until the reaction ends in an &lt;code&gt;await&lt;/code&gt; or &lt;code&gt;run&lt;/code&gt; statement.
Subsequently, when a reaction resumes execution inside the body, first the &lt;code&gt;when&lt;/code&gt; condition is checked.
If it is false, the execution starts as usual.
Otherwise the body is preempted &lt;em&gt;before&lt;/em&gt; any statement is executed or expression is evaluated inside the body.
There are two variants of preemptions.
&lt;code&gt;abort&lt;/code&gt; means that control flow jumps to the &lt;code&gt;end&lt;/code&gt; of the preemption statement.
&lt;code&gt;reset&lt;/code&gt; means that control flow restarts at the beginning of &lt;code&gt;StmtBlock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;when Condition reset P end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is syntactic sugar for&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var hasTerminated = false
repeat
    when Condition abort
        P
        hasTerminated = true
    end
until hasTerminated end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;where &lt;code&gt;hasTerminated&lt;/code&gt; is a fresh boolean variable.&lt;/p&gt;
&lt;p&gt;It is, of course, possible that the body is left instantaneously within one reaction.
In this case the preemption is irrelevant for the flow of control.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;
The preemption condition is &lt;em&gt;not&lt;/em&gt; checked when the control flow enters the body.
The &lt;code&gt;when&lt;/code&gt; condition is only checked when control flow resumes from within the body.
Wrap the preemption inside an &lt;code&gt;if&lt;/code&gt; statement in case you want to check the condition before entering the body.
&lt;/div&gt;

&lt;h4 id=&#34;example-abort-and-reset&#34;&gt;Example: Abort and Reset&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity A (in1: bool) (out1: uint8)
    // do something ...
    
    when in1 abort
        out1 = 1
        await true
        out1 = 2
        await true
        out1 = 3
    end
    
    // do something else ...
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The statement in line 4 says that &lt;code&gt;when&lt;/code&gt; a reaction &lt;em&gt;starts&lt;/em&gt; in the block lines 5 &amp;ndash; 9, it is checked whether &lt;code&gt;in1&lt;/code&gt; is true and in that case the control flow skips to line 10.
Thus when control flow reaches line 4 it will immediately proceed to line 5, set &lt;code&gt;out1&lt;/code&gt; accordingly and finish this reaction in line 6 (regardless of the value of &lt;code&gt;in1&lt;/code&gt;).
The next reaction starts by checking the abort condition &lt;code&gt;in1&lt;/code&gt;.
If it is true we skip the rest of the block and proceed to line 10.
Otherwise, we check the condition of the &lt;code&gt;await&lt;/code&gt; statement which here is vacuously true and the reaction proceeds to line 7 and finishes in line 8.
The same reasoning applies in line 8: the execution is possibly aborted before setting &lt;code&gt;out1&lt;/code&gt; to 3.
In any case, the block is left in line 10.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;abort&lt;/code&gt; statement is useful whenever we want to skip over a sequence of reactions when we detect some issue at the beginning of a reaction.
Sometimes instead of skipping ahead we would like to restart a sequence of reactions.
For this we may use the &lt;code&gt;reset&lt;/code&gt; statement.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity MyAct (in1: bool) (out1: uint8)
    // do something ...
    
    when in1 reset // reset instead of abort
        out1 = 1
        await true
        out1 = 2
        await true
        out1 = 3
    end
    
    // do something else ...
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It behaves just like the &lt;code&gt;abort&lt;/code&gt; statement except it jumps to line 4 if &lt;code&gt;in1&lt;/code&gt; is true.&lt;/p&gt;
&lt;h2 id=&#34;imperative-control-flow&#34;&gt;Imperative control flow&lt;/h2&gt;
&lt;p&gt;All of the following statements are known from mainstream imperative programming languages.
They may be used inside both, activities and functions.&lt;/p&gt;
&lt;h3 id=&#34;assignment&#34;&gt;Assignment&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Assignment&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsExpr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;do-block&#34;&gt;Do block&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;DoBlock&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;do&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;do&lt;/code&gt; block may be used to define local scopes.&lt;/p&gt;
&lt;h4 id=&#34;example-local-scopes&#34;&gt;Example: Local scopes&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function f ()
    do
        var x: int8 = 5
    end
    // x is out of scope here
end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;if&#34;&gt;If&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;IfStmt&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;if&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;then&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;elseif&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;then&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;else&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;while&#34;&gt;While&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;WhileLoop&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;while&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;repeat&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When using a loop in an activity, there must be some pause on every control flow path through the loop body.
This is not necessary for loops inside functions.
Note that using &lt;code&gt;while&lt;/code&gt; loops in activities may lead to unexpected error messages because we deliberately &lt;em&gt;do not&lt;/em&gt; evaluate the condition at compile time even if it is trivially true or false.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity Toggle()(out:bool)
    while true repeat
        out = not out
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This program will not compile because the compiler thinks there is a control flow path that does not enter the loop and immediately terminates the activity.
Since activities must not be instantaneous this program is rejected.
Use &lt;code&gt;repeat&lt;/code&gt; loops instead to avoid this spurious control flow paths that possibly skip the loop.&lt;/p&gt;
&lt;h3 id=&#34;repeat&#34;&gt;Repeat&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;RepeatLoop&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;repeat&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;until&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;repeat&lt;/code&gt; loops guarantee that control flow does enter the loop body at least once.
Endless loops (without the &lt;code&gt;until&lt;/code&gt; condition) may only be used in activities.
Again, when using a loop in an activity, there must be some pause on every control flow path through the loop body.
This is not necessary for loops inside functions.&lt;/p&gt;
&lt;h3 id=&#34;return&#34;&gt;Return&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ReturnStmt&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;return&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Void activities and functions can use &lt;code&gt;return&lt;/code&gt; without an expression to terminate at some point before control flow reaches the last statement.&lt;/p&gt;
&lt;h4 id=&#34;example-return-from-void-function&#34;&gt;Example: Return from void function&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function setSpeed (velocity: float32) ()
    if velocity &amp;lt; 0 then
        return
    end

    if not isMotorReady() then
        return
    end
    
    halSetSpeed(velocity) // call device driver
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This simple example assumes we implement a wrapper for calling a hardware device driver.
In order to avoid an if-then-else cascade &lt;code&gt;setSpeed&lt;/code&gt; tests the prerequisites individually and returns in case some of them is not met.&lt;/p&gt;
&lt;p&gt;Activities and functions that declare a return type must return a value of this type on every control flow path that reaches the end of the program body.&lt;/p&gt;
&lt;p&gt;Activities may only return from their main thread.
In other words &lt;code&gt;return&lt;/code&gt; must not occur inside a branch of a &lt;code&gt;cobegin&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;Mind the difference between activity return values and activity output values.
Outputs are set in every reaction of the activity.
A return value is returned precisely once in the reaction that terminates the activity.&lt;/p&gt;
&lt;h4 id=&#34;example-return-from-activity&#34;&gt;Example: Return from activity&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity A (in: int32) (out: int32) returns nat8
    var retcode: nat8
    var x: int32
    cobegin weak
        run B(in)(x)
    with
        retcode = run C(x)(out)
    end
    return retcode
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In every reaction &lt;code&gt;in&lt;/code&gt; is propagated to &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; is propagated from &lt;code&gt;C&lt;/code&gt; to the caller.
Only when &lt;code&gt;C&lt;/code&gt; terminates the variable &lt;code&gt;retcode&lt;/code&gt; is updated, the &lt;code&gt;cobegin&lt;/code&gt; statement is terminated and the &lt;code&gt;retcode&lt;/code&gt; is returned to the caller.&lt;/p&gt;
&lt;h3 id=&#34;function-call&#34;&gt;Function call&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;FunctionCallStmt&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Blech distinguishes between a function call statement and a function call expression.
On the statement level only void functions may be called.&lt;/p&gt;
&lt;p&gt;In summary, a block of statements in Blech is given by the following grammar.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; 
      &lt;span style=&#34;color:#000&#34;&gt;Pause&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;ActivityCall&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;ForkJoin&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Preemption&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Assignment&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;DoBlock&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;IfStmt&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;WhileLoop&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;RepeatLoop&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;ReturnStmt&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;FunctionCallStmt&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Depending on whether statements are used in an activity or a function their use may be restricted or prohibited (see above).
The optional semicolons in the grammar indicate that it is possible to separate statements in a sequence using semicolons.
We suggest to avoid writing any semicolons unless two (or more) statements are written in one line.&lt;/p&gt;
&lt;h3 id=&#34;semicolons-in-blech&#34;&gt;Semicolons in Blech&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function f()
    var x: int8 = 0; // do not clutter your code with superfluous &amp;quot;;&amp;quot;
    var y: int8 = 1  // preferred semicolon free style

    x = 7; y = y + x // ok, but usually it is better to write two lines
    x = 7 y = y + x  // compiles but is hardly readable, do not do that
end
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Local and external variables</title>
      <link>https://www.blech-lang.org/docs/blechc-development/external-vars/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/blechc-development/external-vars/</guid>
      <description>
        
        
        &lt;h2 id=&#34;local-variables&#34;&gt;Local variables&lt;/h2&gt;
&lt;p&gt;Variables declared with the scope of an activity are persistent.
They keep their value over multiple reactions.
Hence, in the generated code, they are stored outside the step-function of the given activity.
Instead they are passed as a context with every call of the step-function.&lt;/p&gt;
&lt;p&gt;Previous values however need not be stored in this static context.
In the generated code, they can be automatic variables (stack allocated variables) of the generated step-function.
The step-function itself will create the prev variables (where needed) and fill them before the actual step is carried out.&lt;/p&gt;
&lt;p&gt;Special attention has to be given to the reaction in which the declaration of the local variable takes place.
Here the local variable assumes its first value.
This is defined to be the prev value and thus the prev variable has to be reset here once.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
var x: int32 = 7 // prev x = 7
cobegin
    run B(prev y)(x) // x may have changed
with
    run A(prev x)(y) // prev x is guaranteed to be 7 in the first reaction
end
...
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;external-variables&#34;&gt;External Variables&lt;/h2&gt;
&lt;p&gt;External variables (inside the activity scope) are dual to local variables in terms of code generation.
We do not need to store external variables in the static context which is passed to the step-function.
Instead an external variable will be represented by an automatic variable which is set at the beginning of the reaction using the value of the actual external C-variable that it is bound to.
At the end of the reaction, the final value is written back to the external C-variable (if it is a &lt;code&gt;var&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Previous values of external variables on the other hand must be persisted in static memory.
This is to guarantee synchronous semantics, i.e. the prev value really is the value that the last reaction ended with 
(while the value of the external variable is volatile and may have changed arbitrarily between reactions).
The code generator will create an extra local activity variable and add it to the list of local variables that are stored in the context.
The value of the prev variable will be set &lt;em&gt;at the end&lt;/em&gt; of each reaction, so it can be used in the next reaction.&lt;/p&gt;
&lt;p&gt;Again, special treatment is required in the code block that represents the reaction in which the declaration of the external variable becomes active.
Here, as before, the prev value has to be set once so it is defined in the case that the prev value is used in the same reaction.&lt;/p&gt;
&lt;h2 id=&#34;effects-on-compilation-contexts&#34;&gt;Effects on compilation contexts&lt;/h2&gt;
&lt;p&gt;If necessary, the function &lt;code&gt;ActivityTranslator.cpAction&lt;/code&gt; adds the external variable with a &lt;code&gt;prev_&lt;/code&gt; infix in its name to the &lt;code&gt;Compilation.iface.locals&lt;/code&gt; of the current activity.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ActivityTranslator.makeActCall&lt;/code&gt; transports the locals of the called activity to the interface of the current one which includes the prev&amp;rsquo;ed version of external variables.
In order to be able to print this interface as C code, the variables are added to the dictionary of known declarations in the type check context (&lt;code&gt;ctx.tcc.nameToDecl&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Since the entry point activity is never called from within the Blech program the above mechanism of adding variables to the type check context is repeated in &lt;code&gt;ActivityTranslator.translate&lt;/code&gt; (for the entry point activity only).&lt;/p&gt;
&lt;h2 id=&#34;effects-on-c-code-generation&#34;&gt;Effects on C-code generation&lt;/h2&gt;
&lt;p&gt;Printing external constants or params does not require any additional modifications. The given binding is simply inserted. For &lt;code&gt;extern let&lt;/code&gt; and &lt;code&gt;extern var&lt;/code&gt; additional effort is required.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;External variables&lt;/p&gt;
&lt;p&gt;Whenever an external variable is accessed as a right-hand-side, left-hand-side or the input or output argument to a call, it needs to be rendered differently than local activity variables.
This is because external variables are generated as automatic variables in the scope of the step-function (instead of being passed in with the context).
Thus they need to be rendered like local variables in Blech functions.
This is achieved by hooking in the &lt;code&gt;isExtCurVar&lt;/code&gt; function in the call of the &lt;code&gt;cpRenderData&lt;/code&gt;.
It will set the &lt;code&gt;subProgDecl&lt;/code&gt; to &lt;code&gt;Function&lt;/code&gt; if the variable name to be rendered is an access to the current memory location of an external variable.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access to previous locations of external variables&lt;/p&gt;
&lt;p&gt;Usually the previous value is stored in an automatic variable of the step-function and is accessed accordingly. The name is mangled by prepending a &lt;code&gt;prev_&lt;/code&gt; to the QName of the variable.
However previous values of external variables are stored in the context. Thus they need to be accessed like a local variable. The &lt;code&gt;prev_&lt;/code&gt; infix is already mangled into the QName that is stored in the context.
Thus &lt;code&gt;cpRenderData&lt;/code&gt; will change &lt;code&gt;timepoint&lt;/code&gt; to &lt;code&gt;Current&lt;/code&gt; and add the &lt;code&gt;prev_&lt;/code&gt; infix into the name to be rendered.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copy-in / copy-out&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;ActivityTranslator.translate&lt;/code&gt; generates code for&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Copying the values from the bound external C-variables to the local memory inside the step-function at the beginning of the reaction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copying back the final results back to the bound external C-variables at the end of the reaction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(If necessary,) setting the previous memory to the final current value of the external variable such that in the next reaction the prev value can be used.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;effects-on-json-trace-printing&#34;&gt;Effects on JSON trace printing&lt;/h2&gt;
&lt;p&gt;Since prev locations of external variables become local activity variables and are added to the type check context, they are printed in the trace along with the normal variables.
Note however that the value shown in the trace is the prev value for the &lt;em&gt;next&lt;/em&gt; reaction.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Translating Blech variable names to C</title>
      <link>https://www.blech-lang.org/docs/blechc-development/cpdata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/blechc-development/cpdata/</guid>
      <description>
        
        
        &lt;style type=&#34;text/css&#34;&gt;
    ol ol { list-style-type: lower-roman; }
&lt;/style&gt;
&lt;h2 id=&#34;possibilities-in-blech&#34;&gt;Possibilities in Blech&lt;/h2&gt;
&lt;p&gt;Variable names appear in different &lt;em&gt;syntactic&lt;/em&gt; contexts (expressions):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;current / previous access&lt;/li&gt;
&lt;li&gt;lhs / rhs value (in assignment)&lt;/li&gt;
&lt;li&gt;lhs / rhs reference (in procedure call)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Variable names appear in different &lt;em&gt;declaration&lt;/em&gt; contexts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Parameter input / output&lt;/li&gt;
&lt;li&gt;Global constant&lt;/li&gt;
&lt;li&gt;Activity- / function-local Blech variable&lt;/li&gt;
&lt;li&gt;Activity-local external C-variable&lt;/li&gt;
&lt;li&gt;Auxiliary variable introduced by the compiler&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Variable names may represent various kinds of data &lt;em&gt;types&lt;/em&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Simple (atomic)&lt;/li&gt;
&lt;li&gt;Structures&lt;/li&gt;
&lt;li&gt;Arrays&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Not all combinations are possible.
Below is an overview of what is possible in Blech and what the corresponding generated C code must look like.&lt;/p&gt;
&lt;h2 id=&#34;translation-workflow&#34;&gt;Translation workflow&lt;/h2&gt;
&lt;p&gt;Translating any access to data runs through several stages:&lt;/p&gt;
&lt;p&gt;Given a typed memory location &lt;code&gt;foo[0].bar&lt;/code&gt;&amp;hellip;
&lt;em&gt;(Remark: &lt;code&gt;prev foo[0].bar&lt;/code&gt; binds as &lt;code&gt;(prev foo)[0].bar&lt;/code&gt;).&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For the QNamePrefix part &lt;code&gt;foo&lt;/code&gt;, determine a name scheme (depending on declaration context)
&lt;ol&gt;
&lt;li&gt;Static name &lt;code&gt;blc_&amp;lt;longId&amp;gt;_foo&lt;/code&gt; or &lt;code&gt;blc_&amp;lt;moduleName&amp;gt;_&amp;lt;longId&amp;gt;_foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Parameter name &lt;code&gt;blc_foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Auto name &lt;code&gt;blc_foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Context element &lt;code&gt;blc_blech_ctx-&amp;gt;blc_foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Auxiliary name &lt;code&gt;aux_blc_foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;prev of Blech var &lt;code&gt;prev_blc_foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;prev of extern var &lt;code&gt;blc_blech_ctx-&amp;gt;prev_blc_foo&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Ensure the name &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; generated above represents the memory blob itself, not a pointer to it
&lt;ol&gt;
&lt;li&gt;if &lt;code&gt;foo&lt;/code&gt; is a simple type or struct parameter rewrite name from above to &lt;code&gt;*&amp;lt;name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Nothing to do for arrays as the name (pointer to the first element) already &lt;em&gt;represents&lt;/em&gt; the whole array blob.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Append all field / cell access to this name &lt;code&gt;&amp;lt;name&amp;gt;[0].bar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Depending on usage context and type (of &lt;code&gt;bar&lt;/code&gt;) determine whether to use the path as is or construct a reference from it&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- .Usage context and type --&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;simple&lt;/th&gt;
&lt;th&gt;struct&lt;/th&gt;
&lt;th&gt;array&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;lhs assign&lt;/td&gt;
&lt;td&gt;as-is&lt;/td&gt;
&lt;td&gt;as-is&lt;/td&gt;
&lt;td&gt;as-is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rhs assign&lt;/td&gt;
&lt;td&gt;as-is&lt;/td&gt;
&lt;td&gt;as-is&lt;/td&gt;
&lt;td&gt;as-is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output arg&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;as-is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input arg&lt;/td&gt;
&lt;td&gt;as-is&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;as-is&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Possibly reduce trivial combinations like &lt;code&gt;&amp;amp;(*&amp;lt;name&amp;gt;)&lt;/code&gt; to &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;. This will happen for e.g. simple typed output parameters passed on as an output argument.&lt;/p&gt;
&lt;h2 id=&#34;remarks-and-after-thoughts&#34;&gt;Remarks and after thoughts:&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;blc_&lt;/code&gt; prefix is used to make sure we never overwrite global variables with the same name (that might appear in C sources outside the scope of the generated Blech code). Of course, we assume that the &lt;code&gt;blc_&lt;/code&gt; prefix is reserved and not used by sources not generated by the Blech compiler.&lt;/p&gt;
&lt;p&gt;However previous variables use the scheme &lt;code&gt;prev_blc_&lt;/code&gt; making &lt;code&gt;prev_&lt;/code&gt; yet another exclusive prefix. We cannot simply generate &lt;code&gt;blc_prev_&amp;lt;id&amp;gt;&lt;/code&gt; for &lt;code&gt;prev &amp;lt;id&amp;gt;&lt;/code&gt; as this would clash with a regular Blech variable called &lt;code&gt;prev_id&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We also use &lt;code&gt;blc_&lt;/code&gt; for naming fields in the activity context. This ensure we rule out clashes between normal and prev&amp;rsquo;ed external variables in the activity context.&lt;/p&gt;
&lt;p&gt;Auxiliary variables use yet another prefix &lt;code&gt;aux_blc_&lt;/code&gt;.
This ensures they do not shadow a global C variable with the same name (assuming that the environment never uses names starting with &lt;code&gt;aux_blc_&lt;/code&gt;).
This is basically the same reasoning as with auto variables. However we need the extra &lt;code&gt;aux_&lt;/code&gt; to prevent a clash with an actual Blech variable.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

TODO: at the moment all constants and params in local scopes are lifted to the top level.
Why do we not use the &lt;code&gt;static&lt;/code&gt; keyword of C and let the declaration remain inside the function?
&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Docs: Git workflow</title>
      <link>https://www.blech-lang.org/docs/blechc-development/git-workflow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/blechc-development/git-workflow/</guid>
      <description>
        
        
        &lt;h2 id=&#34;branches&#34;&gt;Branches&lt;/h2&gt;
&lt;p&gt;For the Blech compiler development we use branches and roughly follow the &lt;a href=&#34;https://gist.github.com/digitaljhelms/4287848&#34; target=&#34;_blank&#34;&gt;Git/Github branching standards &amp;amp; conventions&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The contained &lt;a href=&#34;https://gist.github.com/digitaljhelms/4287848#workflow-diagram&#34; target=&#34;_blank&#34;&gt;workflow diagram&lt;/a&gt;
 visualizes this in a nice way.&lt;/p&gt;
&lt;p&gt;Since we did not release a stable version until now, we do not have stable branch but only a master branch that reflects the evolution of the language and gets tagged from time to time.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Immutable references - `let ref`</title>
      <link>https://www.blech-lang.org/docs/language-evolution/borrowing/30_let-ref/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/language-evolution/borrowing/30_let-ref/</guid>
      <description>
        
        
        &lt;h2 id=&#34;read-only-references&#34;&gt;Read-only references&lt;/h2&gt;
&lt;p&gt;Different to Rust, Blech takes references and de-references whenever it is necessary.&lt;/p&gt;
&lt;p&gt;Althoug Blech semantically uses pass-by-reference it is possible to pass a complete right-hand-side expression for input parameters.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take our example from the introduction&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    var i: int32
    var j: int32

    outIsInPlus1(j + 1)(i)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This programm is valid.
Semantically Blech creates a auxiliary memory location from which the read-only reference can be taken.
For a function on simple types the generated code can be optimized and the parameter can be passed by-value.&lt;/p&gt;
&lt;p&gt;This is not true for an activity.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity outAlwaysIsInPlus1 (a: int32) (b: int32)
    repeat 
        b = 1
        b = a + b 
        await true
        b = 1
        b = a + b
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    var i: int32
    var j: int32

    run outAlwaysIsInPlus1(j + 1)(i)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In every step the activity gets &lt;code&gt;j+1&lt;/code&gt; as its input.&lt;/p&gt;
&lt;p&gt;For the code generation the auxiliary memory location is necessary.&lt;/p&gt;
&lt;p&gt;We imagine the new value is &lt;em&gt;pumped into&lt;/em&gt; the activity in every step.&lt;/p&gt;
&lt;h2 id=&#34;immutable-borrowing-in-sub-expressions&#34;&gt;Immutable borrowing in sub-expressions&lt;/h2&gt;
&lt;p&gt;Due to a causality error the Blech compiler rejects the following program.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    var i: int32
    run outAlwaysIsInPlus1(i + 1)(i)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Furthermore the compiler rejects a similar function call&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    var i: int32
    outIsInPlus1(i + 1)(i)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is different to Rust, because Rust cannot take immutable (read-only) references to right-hand side expressions.&lt;/p&gt;
&lt;p&gt;The borrow checker needs to check the occurence of read-only borrowing in right-hand side expressions.&lt;/p&gt;
&lt;h2 id=&#34;pure-functions&#34;&gt;Pure functions&lt;/h2&gt;
&lt;p&gt;Pure functions only have input parameters and a return value.&lt;/p&gt;
&lt;p&gt;For pure functions pass-by-reference and pass-by-value are semantically the same, because nothing at the call side gets changed.&lt;/p&gt;
&lt;p&gt;All build-in operators in Blech are pure functions.&lt;/p&gt;
&lt;h2 id=&#34;read-only-references-1&#34;&gt;Read-only references&lt;/h2&gt;
&lt;p&gt;Since we can pass a right-hand-side expression as an input parameter we should also be able to take a reference to a right-hand-side expression in sequential code.
This makes sense in an activity and is called &lt;code&gt;bind&lt;/code&gt; in the language Quartz.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity a (i: int32) (j: int32)
    let ref double = i * 2
    repeat
        j = double
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to take a reference to a right-hand-side expression the compiler would generate an additional memory location.&lt;/p&gt;
&lt;p&gt;This has roughly the following semantics:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity a (i: int32) (j: int32)
    var aux_double: int32  // not subject to borrow checking
    let ref double = internal_aux_double
    cobegin weak
        repeat
            aux_double = i * 2
            await true
        end
    with 
        repeat
            j = double
            await true
        end
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For the declaration &lt;code&gt;let ref double = i * 2&lt;/code&gt; we need to apply the borrowing rules for the sub-expression &lt;code&gt;i&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example in the following code would then be rejected.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    var i: int32
    var z: int32
    let ref double = i * 2  // immutable borrow of i
    repeat
        z = double
        await true
    until z &amp;gt; 1000 end
    i = i + 1 // i is no longer accessible here 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The read-only reference &lt;code&gt;double&lt;/code&gt; immutable borrows &lt;code&gt;i&lt;/code&gt;, which locks &lt;code&gt;i&lt;/code&gt; for further usage.&lt;/p&gt;
&lt;p&gt;As usual a separate scope can solve the problem:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;    var i: int32
    var z: int32
    do
        let ref double = i * 2
        repeat
            z = double
            await true
        until z &amp;gt; 1000
    end
    i = i + 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For purely sequential code that is not &lt;em&gt;re-entered&lt;/em&gt; on every tick, the contents of the auxiliary memory location gets only assigned once.&lt;/p&gt;
&lt;p&gt;It not possible to take a reference for a right-hand-side expression as an output or a &lt;code&gt;var ref&lt;/code&gt; declaration.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Stopwatch</title>
      <link>https://www.blech-lang.org/docs/examples/stopwatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/examples/stopwatch/</guid>
      <description>
        
        
        &lt;p&gt;This example illustrates synchronous control flow by means of a stopwatch: the &lt;code&gt;s&lt;/code&gt; button starts and stops the measurement of time; the &lt;code&gt;r&lt;/code&gt; button resets the watch to zero if no measurement is currently running, otherwise it shows the lap time.&lt;/p&gt;
&lt;p&gt;The example is discussed in detail in the paper &lt;a href=&#34;https://doi.org/10.1007/978-3-030-31585-6_9&#34; target=&#34;_blank&#34;&gt;“Blech, Imperative Synchronous Programming!&amp;quot;&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;There various modifications of the example are discussed as well as some aspects of software engineering practice.
The code sample provided here implements the final result from the paper.
The provided c file and build script are tailored towards the Microsoft Windows system using the &lt;code&gt;cl&lt;/code&gt; compiler.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;CompleteStopwatch.zip&#34;&gt;Code samples (zip)&lt;/a&gt;
&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Declarations</title>
      <link>https://www.blech-lang.org/docs/user-manual/declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/declarations/</guid>
      <description>
        
        
        &lt;p&gt;Declarations introduce new names for entities in the program.
Declarable entities include&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activities&lt;/li&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;types&lt;/li&gt;
&lt;li&gt;data storage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the future more of such entities may be added to the language such as clocks and physical units.&lt;/p&gt;
&lt;p&gt;Every declaration exists in a &lt;em&gt;lexical scope&lt;/em&gt;.
Scopes define the visibility of a name.
The top-level or file scope is the most global scope in Blech.
Functions, activities and types are defined here.
Entities in the top-level scope are visible everywhere in the file.
Every block introduces a sub-scope.
For example, a function body is a local scope.
Variables defined in this scope are visible in this function but not outside of it.
Composite statements, such as the &lt;code&gt;repeat&lt;/code&gt; loop introduce their statement-local scope. This allows to introduce a variable that is visible during the iteration through this loop and not outside of it.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
Once we implement a module system for Blech, the mechanisms for controlling visibility will need to be elaborated in more detail.
&lt;/div&gt;

&lt;p&gt;In Blech, declarations not only introduce a name but also &lt;em&gt;define&lt;/em&gt; what this name represents. For example, a function declaration will specify a function body.
That is the block of statements that are executed when this functions is called.
The definition may refer to names that were previously declared.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;
Declare before use! Even if, for example, functions are defined on the same scope, a function can only call other functions that have been declared before.
&lt;/div&gt;

&lt;p&gt;In the following we discuss the various entities that can be defined in a Blech program.&lt;/p&gt;
&lt;h2 id=&#34;data&#34;&gt;Data&lt;/h2&gt;
&lt;p&gt;Data declarations consist of an access and placement qualifier, an identifier, a data type and an initialisation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;DataDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Init&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A variable declaration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int32 = 17
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The type is either a built-in type or a name of a user defined type.
Built-in types are discussed in the &lt;a href=&#34;../types&#34;&gt;Types chapter&lt;/a&gt;
.
Type declarations are discussed &lt;a href=&#34;#user-defined-types&#34;&gt;below&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Initialisers are expressions that evaluate to a value that matches this declaration&amp;rsquo;s data type. Expressions (including literals) are discussed in the &lt;a href=&#34;../expressions&#34;&gt;Expressions chapter&lt;/a&gt;
.&lt;/p&gt;
&lt;h3 id=&#34;qualifiers&#34;&gt;Qualifiers&lt;/h3&gt;
&lt;p&gt;There are four possible qualifiers.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;const&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;param&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;let&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;var&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt; qualified data is relevant for the compilation phase only and does not have any representation in memory at run time. 
Typical use cases for &lt;code&gt;const&lt;/code&gt; are sizes of data structures, addresses in memory, &amp;hellip; 
In C, these are represented by &lt;code&gt;#define&lt;/code&gt; macros, which, too, have no representation after the preprocessor finishes.
Hence &lt;em&gt;using const on arrays (or structs containing arrays), albeit possible, is not advisable&lt;/em&gt; and produces inefficient code because temporary variables have to be created (and filled) at runtime for every (non-constant) access to these arrays.
Instead consider &lt;code&gt;param&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;param&lt;/code&gt; qualified data has a representation in memory at run time but cannot be changed by the running program for its entire lifetime (it can only be reflashed).
Typical use cases for &lt;code&gt;param&lt;/code&gt; are characteristics maps or other immutable lookup data structures.
The name &amp;ldquo;param&amp;rdquo; indicates that such data is a parameter of the final compilation result.
Tools exist to customise such parameters in a binary file directly in order to adapt the given software to a variant of a product.
Like with &lt;code&gt;const&lt;/code&gt; data, the &lt;code&gt;param&lt;/code&gt; value must be initialised with constant expressions.
You cannot write the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function f (input: int32)
   param x: int32 = input // error!
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is because the value of &lt;code&gt;input&lt;/code&gt; is determined at &lt;em&gt;runtime&lt;/em&gt; but &lt;code&gt;x&lt;/code&gt; must be initialised at &lt;em&gt;compile time&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt; and &lt;code&gt;param&lt;/code&gt; data may be declared at top level as well as inside functions or activities.
The other two qualifiers &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; indicate local data and may &lt;em&gt;only&lt;/em&gt; be used inside functions or activities.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; declares immutable data in the control flow of a program.
Finally, &amp;lsquo;var&amp;rsquo; declares the usual mutable variable.
Initialisation may be omitted for mutable variables. In this case the Blech compiler will automatically initialise the variable with its type&amp;rsquo;s default value.
The type annotation may be omitted if the type can be unambiguously determined from the initialisation expression.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;const LEN: int32 = 8
param lut: [LEN]float64 = {1.0, 0.5, 0.25, 0.125} // LEN is constant and may be used here
                                                  // the array literal will be filled with additional 0&#39;s up to length LEN.
function f()
    let i = LEN - 7 // i is deduced to be int32
    var x = lut[i] // x is deduced to be float64
                   // and equals 0.5 in this case
end
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;
No global variables in Blech!
We deliberately prohibit the use of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; outside subprogram scopes because we believe this leads to better understandable, easier to integrate and unit-testable programs.
&lt;/div&gt;



&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;
Confusion may arise about the difference between &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;.
They both qualify immutable data in memory.
They could be even stored in the same way which however is a compiler implementation detail and none of the concerns of the programmer.
The crucial difference is that &lt;code&gt;let&lt;/code&gt; takes values at runtime.
It is immutable throughout the scope where it has been declared.
Once the scope is left and re-entered, the value of that &lt;code&gt;let&lt;/code&gt; variable may be re-initialised. (In the literature this is sometimes dramatically referred to as &amp;ldquo;re-incarnation&amp;rdquo;.)
As stated above, &lt;code&gt;param&lt;/code&gt; data cannot be changed by the running program at all, it is completely static.
&lt;/div&gt;



&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;
The word &amp;ldquo;parameter&amp;rdquo; appears in two notions. One is the &amp;ldquo;formal parameter&amp;rdquo; of a function or activity.
The other is the &amp;ldquo;param&amp;rdquo; qualifier for immutable data.
The first parametrises a function (ar activity), the second parametrises a whole binary.
We try to make clear which one we mean throughout this document. Usually it should be apparent from context however.
&lt;/div&gt;

&lt;h2 id=&#34;user-defined-types&#34;&gt;User defined types&lt;/h2&gt;
&lt;p&gt;The programmer may define a data structure using the &lt;code&gt;struct&lt;/code&gt; keyword.
See the chapter on &lt;a href=&#34;../types/#structure-types&#34;&gt;struct types&lt;/a&gt;
 for more details.


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;
As the implementation of the compiler progresses there will be more user definable types.
&lt;/div&gt;
&lt;/p&gt;
&lt;h2 id=&#34;subprograms&#34;&gt;Subprograms&lt;/h2&gt;
&lt;p&gt;Blech discerns two type of subprograms: &lt;code&gt;activity&lt;/code&gt; and &lt;code&gt;function&lt;/code&gt;.
Their behaviour is different. Activities must pause at least once whereas functions need to terminate within one reaction. Functions are therefore called &amp;ldquo;instantaneous&amp;rdquo;.
The precise differences will be worked out in the chapter on Blech statements.
From a syntactic declaration point of view there is hardly any difference.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ProgramDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;singleton&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ProgramType&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;returns&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ProgramType&lt;/span&gt;        ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;function&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;activity&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;          ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;()&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt;   ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There are two parameter lists. 
The first lists declares formal parameters that may only be read (like &lt;code&gt;let&lt;/code&gt; variables), the second list declares formal parameters that may be both read and written (like &lt;code&gt;var&lt;/code&gt; variables).
In particular the two lists are useful for activities which, in every reaction, receive a list of read-only &lt;em&gt;inputs&lt;/em&gt;, perform some calculation and set the list of read-write &lt;em&gt;outputs&lt;/em&gt;.
We will therefore often refer to these two parameter lists as &amp;ldquo;input list&amp;rdquo; and &amp;ldquo;output list&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;The programming model is that all variables are passed by reference (even though in reality the compiler will optimise this into by-value for simple value typed inputs).&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function add (x: int32, y: int32) returns int32
   return x + y
end

@[EntryPoint]
activity A (in: int32)(out: int32)
   repeat
      out = add(in, out)
      await true
   end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The example above is a valid Blech program that sums all inputs over all time steps.
Note that &lt;code&gt;add&lt;/code&gt; omits an output list and &lt;code&gt;A&lt;/code&gt; does not declare any return type.
We call functions or activities that do not return anything &amp;ldquo;void&amp;rdquo; but unlike C we do not have a void type in the language.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;@[EntryPoint]&lt;/code&gt; annotation tells the compiler that &lt;code&gt;A&lt;/code&gt; is the main program of this file. Every Blech file must have precisely one entry point activity.
&lt;em&gt;(That is until we have a module system that allows to write libraries that may have no single entry point at all).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;singleton&lt;/code&gt; keyword is optional and may be used to indicate that there may exist only one instance of this subprogram in a concurrent context. 
For example, this is useful to indicate early on in the development phase that an activity will have some interaction with the external environment.
The caller of a singleton callee automatically becomes a singleton, too.&lt;/p&gt;
&lt;h2 id=&#34;external-declarations&#34;&gt;External Declarations&lt;/h2&gt;
&lt;p&gt;Sometimes it is useful to access global variables or functions of a C program.
This allows for example to make use of existing libraries.
Such variables and functions are &lt;em&gt;external&lt;/em&gt; from the point of view of a Blech program.
Annotations are required to tell the compiler how to code-generate access to these external entities.&lt;/p&gt;
&lt;p&gt;Formally, we have the following syntax.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ExternFunctionDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;extern&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;singleton&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;function&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;returns&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ExternDataDeclaration&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;extern&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Obviously, external functions have no body and external variables cannot be initialised.
As before, external functions may be characterised as &lt;code&gt;singleton&lt;/code&gt; which means such a function may not be called concurrently. This is useful when the external function to be called is not a pure function because it either returns a volatile value or has some effect on the environment. Calling such a function concurrently would violate the synchrony assumptions and lead to unexpected results.&lt;/p&gt;
&lt;p&gt;External declarations additionally require annotations which we introduce by example below.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;
Note that the type-safety and causality guarantees of Blech vanish once you interact with an external C implementation. That means the Blech compiler relies on the assumption that the specified annotations and interfaces are correct. We&amp;rsquo;ll point out a few caveats below.
&lt;/div&gt;

&lt;h3 id=&#34;external-constants&#34;&gt;External constants&lt;/h3&gt;
&lt;p&gt;In C, constant values may be defined using macros or &lt;code&gt;const&lt;/code&gt; variables.
In order to make these values available in Blech, external constants may be declared.
External constant declarations may appear in any scope.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CConst (binding = &amp;quot;PI&amp;quot;, header = &amp;quot;math.h&amp;quot;)]
extern const pi: float64
@[CParam (binding = &amp;quot;characteristics&amp;quot;, header = &amp;quot;magic.h&amp;quot;)]
extern param map: [10]float32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Both Blech qualifiers &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;param&lt;/code&gt; are supported.
They require a &lt;code&gt;CConst&lt;/code&gt; or a &lt;code&gt;CParam&lt;/code&gt; annotation respectively.
However they have more of a documentation character rather than any functional difference.
Both will evaluate whatever expression is given in the binding at runtime.
This is the reason why external constants cannot be used for constant expression evaluation in Blech &amp;ndash; their value is unknown at compile time.
While you can, for example, use a Blech constant to parametrise an array length, you cannot do so using an external constant.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;binding&lt;/code&gt; annotation attribute may contain any expression that can be evaluated in C.&lt;/p&gt;
&lt;p&gt;By design the Blech compiler generates C code that links with other C code but at no point in time does the Blech compiler &amp;ldquo;look into&amp;rdquo; C header or implementation files, nor does it try to evaluate any C-bindings.&lt;/p&gt;
&lt;h3 id=&#34;local-external-variables&#34;&gt;Local external variables&lt;/h3&gt;
&lt;p&gt;The aforementioned constants may be declared in local scopes as well.
Additionally, local Blech variables that link to external global variables may be declared inside activities (but not in functions).&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;
There is no semantical reason why external variables cannot be declared inside functions. It is simply due to compiler implementation pragmatics that we exclude this possibility as of now.
&lt;/div&gt;

&lt;p&gt;Access to external variables is useful to keep interfaces slim. That is you do not need to pass all data into the entry point activity and down the call chain to the piece of code that actually needs this data and then propagate the results back up this chain to the entry point to communicate the updated values to the environment.
These variables follow the same rules as the usual activity-local variables.&lt;/p&gt;
&lt;p&gt;Read-only external variables are annotated with the &lt;code&gt;CInput&lt;/code&gt; annotation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CInput (binding = &amp;quot;PIN_7&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern let isButtonPressed: bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This example assumes there is either a C macro or a C variable &lt;code&gt;PIN_7&lt;/code&gt; that returns a volatile boolean value indicating a button press.&lt;/p&gt;
&lt;p&gt;The declaration creates a local variable inside the enclosing activity.
It serves as a copy-in buffer.
When the activity starts a reaction the value of &lt;code&gt;PIN_7&lt;/code&gt; is copied into &lt;code&gt;isButtonPressed&lt;/code&gt;.
Within the Blech program we can only access the buffer &lt;code&gt;isButtonPressed&lt;/code&gt; and thereby have the guarantee that the value does not change during the reaction.
This corresponds to the semantics of activity input parameters.&lt;/p&gt;
&lt;p&gt;An activity that declares an immutable external variable does not become a singleton.
Concurrent instances may exist but they may contain different values for the same external variable if it is volatile.&lt;/p&gt;
&lt;p&gt;Read-write external variables are annotated with the &lt;code&gt;COutput&lt;/code&gt; annotation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[COutput (binding = &amp;quot;PIN_7&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern var isButtonPressed: bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here at the beginning of a reaction the value of &lt;code&gt;PIN_7&lt;/code&gt; is copied in.
During a reaction the variable &lt;code&gt;isButtonPressed&lt;/code&gt; can be modified as usual.
At the end of the reaction the value of &lt;code&gt;isButtonPressed&lt;/code&gt; is copied out to &lt;code&gt;PIN_7&lt;/code&gt;.
This guarantees a stable output behaviour. Intermediate changes to the local variable &lt;code&gt;isButtonPressed&lt;/code&gt; are not observable by the environment.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;prev&lt;/code&gt; operator may be used on external variables.
It returns the value that the variable held at the end of the previous reaction.
This behaviour corresponds to using &lt;code&gt;prev&lt;/code&gt; on normal local variables but there is a subtle difference.
External variables may be changed by the environment.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[COutput (binding = &amp;quot;PIN_7&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern var isButtonPressed: bool
isButtonPressed = true
await cond // some boolean condition
var x = prev isButtonPressed // is x == true?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If &lt;code&gt;cond&lt;/code&gt; is true immediately in the next reaction then x will be set to &lt;code&gt;true&lt;/code&gt;.
In general, however we do not know how many reaction it will take until &lt;code&gt;cond&lt;/code&gt; becomes true.
Yet in every reaction the copy-in and copy-out mechanisms will update the &lt;code&gt;isButtonPressed&lt;/code&gt; buffer.
If the environment does not change &lt;code&gt;PIN_7&lt;/code&gt; then surely &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;true&lt;/code&gt;.
But, in general, we cannot assume this.&lt;/p&gt;
&lt;p&gt;An activity that declares a mutable external variable automatically becomes a singleton.
Concurrent instances lead to a write-write conflict and compilation is rejected.&lt;/p&gt;
&lt;h3 id=&#34;external-functions&#34;&gt;External functions&lt;/h3&gt;
&lt;p&gt;There are two ways to link to external functions in Blech.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Via direct binding to function name declared in an .h file&lt;/li&gt;
&lt;li&gt;Via a wrapper to be implemented in some .c file.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the first case we annotate the name of the C function and the file wherein this function is declared.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;ceil&amp;quot;, header = &amp;quot;math.h&amp;quot;)]
extern function ceiling(i: float64) returns float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Inside the Blech program this function is now available through name &lt;code&gt;ceiling&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the second case we annotate which file we intend to implement the C function in.
Actually this information is irrelevant for the Blech compilation itself.
However, it may become useful in the future once a build system can make sense of these annotations and automatically detect which files are required for the compilation of the whole project.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (source=&amp;quot;impl.c&amp;quot;)]
extern function myCFunction(i: float64) returns float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assume the above declaration is written in a Blech file called &lt;code&gt;MyFile.blc&lt;/code&gt;, then the code generator will produce a header file &lt;code&gt;MyFile.h&lt;/code&gt; with the following code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// extern functions to be implemented in C
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;blc_float64&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_MyFile_myCFunction&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_float64&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is up to the C programmer now to include this header in his implementation file &lt;code&gt;impl.c&lt;/code&gt; and provide an actual definition of this function.&lt;/p&gt;
&lt;h3 id=&#34;remarks-on-caveats-when-interfacing-with-c&#34;&gt;Remarks on caveats when interfacing with C&lt;/h3&gt;
&lt;h4 id=&#34;types&#34;&gt;Types&lt;/h4&gt;
&lt;p&gt;Blech has no representation of C types. It requires that the C implementation matches the Blech types. This is usually straightforward for simple types. If there is no one-to-one correspondence between types a wrapper has to be implemented in C that marshals the data between Blech and the actual C function to be called.&lt;/p&gt;
&lt;h4 id=&#34;parameter-lists&#34;&gt;Parameter lists&lt;/h4&gt;
&lt;p&gt;In Blech, functions have two parameter lists as explained above. 
The Blech compiler ensures that inputs will only be read. 
However the Blech compiler has no chance to check that the external code adheres to this contract.&lt;/p&gt;
&lt;p&gt;For example, say we have an external function that takes an array of length 10 and sorts it in-place.
The correct binding would look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;sort&amp;quot;, header = &amp;quot;utils.h&amp;quot;)]
extern function sort()(arr: [10]int32)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this way, the Blech compiler knows that &lt;code&gt;sort&lt;/code&gt; will modify the given array. When calling this function in a concurrent context the compiler will prevent write-write conflicts and read-write cycles on the array.&lt;/p&gt;
&lt;p&gt;However, the programmer could erroneously declare the same function as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;sort&amp;quot;, header = &amp;quot;utils.h&amp;quot;)]
extern function sort(arr: [10]int32)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The code will compile all the same but the causality guarantees are gone because the Blech compiler relies on the assumption that the array will only be read and not modified. At runtime the program may then exhibit unexpected behaviour.&lt;/p&gt;
&lt;h4 id=&#34;singletons&#34;&gt;Singletons&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;singleton&lt;/code&gt; annotation is a help to the Blech programmer but does not completely prevent concurrent calls to functions with conflicting effects. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;foo&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern singleton function doA() 
@[CFunction (binding = &amp;quot;foo&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern singleton function doB() 

/* ... somewhere in an acitivity scope ... */
cobegin
   doA()
with
   doB()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This example is a valid Blech program because two different singleton functions are called. This is allowed. However the annotation points to the same C function which is obviously a problem. While a linter could in principle check for this &lt;em&gt;particular&lt;/em&gt; mistake there are many more possibilities to specify bindings to functions which will have conflicting effects when called concurrently.
It is up to the programmer to know what are the effects of the external functions to be called and to avoid scenarios such as the one above.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Programs and modules - the Blech compilation units</title>
      <link>https://www.blech-lang.org/docs/language-evolution/modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/language-evolution/modules/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;The modules proposal is work in progress.&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id=&#34;introduction-to-compilation-units&#34;&gt;Introduction to compilation units&lt;/h2&gt;
&lt;p&gt;A compilation unit in Blech is a single file.
A file can either be a complete Blech program or a module.
A module can be imported to support the implementation of another module or a program.&lt;/p&gt;
&lt;h3 id=&#34;program-files&#34;&gt;Program files&lt;/h3&gt;
&lt;p&gt;A program file is a Blech code file (a &lt;code&gt;.blc&lt;/code&gt;-file) that needs exactly one activity marked as  an &lt;code&gt;@[EntryPoint]&lt;/code&gt;.
This activity is the &lt;em&gt;main&lt;/em&gt; routine of a Blech program.
The name of this entry point to your program can be choosen freely.
A program can use other Blech files for its implementation.
A program is always a top-level file of a Blech application.&lt;/p&gt;
&lt;h3 id=&#34;module-files&#34;&gt;Module files&lt;/h3&gt;
&lt;p&gt;A module file is a Blech code file that is supposed to be used for the implementation of other modules or programs.&lt;/p&gt;
&lt;p&gt;By default, all internals of a Blech code file are hidden.
In order to become a module, a Blech code file must be marked as a &lt;code&gt;module&lt;/code&gt; and export at least one top-level declaration or a wildcard, see below. TODO: Add a relref here, how?.&lt;/p&gt;
&lt;p&gt;Different to other languages we do not use accessibility modifiers in front of declarations.
Instead, we require an explicit declaration of exported top-level declarations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;module exposes TopLevelIdentifier
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Every top-level declaration inside a module file can be exported to be used by another module or program file.
All neccessary declared identifiers must also be exported.
Optionally, the exported identifiers can be classified for readability.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;module exposes T, MyActivity

type T = int32

function f(x: T) ... end

function MyActivity(x: T) 
    f(x)
    ...
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example the export of activity &lt;code&gt;MyActivity&lt;/code&gt; also requires the export of type alias &lt;code&gt;T&lt;/code&gt;.
The compiler checks the correctness of exports.
It is a compiler error, if type &lt;code&gt;T&lt;/code&gt; is not exported.
For a correct module file an interface file is created that contains all compile-time information that is necessary to compile a Blech file that uses this module file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;signature

type T = int32

function MyActivity(x: T)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;reusing-a-blech-file&#34;&gt;Reusing a Blech file&lt;/h2&gt;
&lt;p&gt;In order to reuse a blech module file it needs to be imported.
Only exported entities can be used.
The internal - non-exposed - entities are hidden.&lt;/p&gt;
&lt;h3 id=&#34;importing-a-blech-module-file-for-use-in-a-program-or-another-module&#34;&gt;Importing a Blech module file for use in a program or another module&lt;/h3&gt;
&lt;p&gt;In order to use a module file it needs to be imported by another compilation unit, for example a Blech program.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import m = &amp;quot;mymodule&amp;quot;

@[EntryPoint]
activity MyMain()
    run m.MyActivity()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, &lt;code&gt;&amp;quot;mymodule&amp;quot;&lt;/code&gt; resembles the file name of the module.
In order order to use it we declare a Blech identifier for the module.
It is fine to use any valid identifier, here &lt;code&gt;m&lt;/code&gt;.
By default all imports are qualified with this module name.
In order to use an imported name without qualification is must be exposed at the import.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import m = &amp;quot;mymodule&amp;quot; exposes MyActivity

@[EntryPoint]
activity MyMain()
    var t: m.T 
    run MyActivity(t)
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note: The other exported entity &amp;ndash; type &lt;code&gt;T&lt;/code&gt; &amp;ndash; can only be used, when qualifed with the module name.&lt;/p&gt;
&lt;p&gt;For exposing everything from an imported module, which is usually neither necessary nor recommended, you can use the short cut &lt;code&gt;...&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import _ = &amp;quot;mymodule&amp;quot; exposes ...

@[EntryPoint]
activity MyMain()
    var t: T 
    run MyActivity(t)
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, a wildcard &lt;code&gt;_&lt;/code&gt; for the module name can be used.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Warning&lt;/h4&gt;
Since Blech has a very rigid no-shadowing policy, you cannot redefine an exposed identifier.
Therefore, use unqualified exposed imports sparingly.
&lt;/div&gt;

&lt;p&gt;Usually, several &lt;code&gt;import&lt;/code&gt; declarations are necessary for a module or program file.&lt;/p&gt;
&lt;h3 id=&#34;no-implicit-export-for-imported-modules&#34;&gt;No implicit export for imported modules&lt;/h3&gt;
&lt;p&gt;Assume the following two modules.&lt;/p&gt;
&lt;p&gt;Module file &lt;code&gt;pair.blc&lt;/code&gt; only exports type alias &lt;code&gt;Pair&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;module exposes Pair

type Pair = [2]int32

function fst(p: Pair) return int32
    return p[0]
end

function snd(p: Pair) returns int32
    return p[1]
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Module file &lt;code&gt;usepair.blc&lt;/code&gt; imports modul &lt;code&gt;pair&lt;/code&gt;, but cannot access hidden functions &lt;code&gt;fst&lt;/code&gt; and &lt;code&gt;snd&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import pair = &amp;quot;pair&amp;quot;

module exposes sum

function snd(p: Pair) return int32
    return p[2]
end

function sum(p: pair.Pair) returns int32
    return p[0] + snd(p)
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On successful compilation the compiler generates the following interface files&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;signature

type Pair = [2]int32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Module &lt;code&gt;&amp;quot;usepair&amp;quot;&lt;/code&gt; requires an &lt;code&gt;import&lt;/code&gt; of module &lt;code&gt;&amp;quot;pair&amp;quot;&lt;/code&gt; and exports function &lt;code&gt;sum&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import pair = &amp;quot;pair&amp;quot;

signature

function sum(p: pair.Pair) returns int32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For reuse, a program that imports module file &lt;code&gt;&amp;quot;usepair&amp;quot;&lt;/code&gt; also needs to import module file &lt;code&gt;&amp;quot;pair&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import up = &amp;quot;usepair&amp;quot;
import p = &amp;quot;pair&amp;quot;

@[EntryPoint]
activity Main()
    var p: p.Pair
    _ = up.sum(p)
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note: Module &lt;code&gt;&amp;quot;pair&amp;quot;&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; exported indirectly via the import of module &lt;code&gt;&amp;quot;usepair&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The following program cannot be compiled.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import up = &amp;quot;usepair&amp;quot;

@[EntryPoint]
activity Main()
    var p: up.pair.Pair
              ^^^^--- unknown identifier
    _ = up.sum(p)
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;exporting-nothing&#34;&gt;Exporting nothing&lt;/h3&gt;
&lt;p&gt;For development purposes it might be useful to expose nothing until a module can be used.
A wildcard &lt;code&gt;_&lt;/code&gt; can be used for this purpose.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;module exposes _

type Pair = [2]int32

function fst(p: Pair) returns int32
    return p[0]
end

function snd(p: Pair) returns int32
    return p[1]
end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;exporting-everything&#34;&gt;Exporting everything&lt;/h3&gt;
&lt;p&gt;Sometimes it might be useful to expose everything in a module.
There is a shortcut &lt;code&gt;...&lt;/code&gt; for this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;module exposes ...

type Pair = [2]int32

function fst(p: Pair) returns int32
    return p[0]
end

function snd(p: Pair) returns int32
    return p[1]
end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;exporting-abstract-types-as-new-types&#34;&gt;Exporting abstract types as new types&lt;/h3&gt;
&lt;p&gt;Sometimes it is useful to hide the implementation of a type, from its importers.
You can create a &lt;code&gt;newtype&lt;/code&gt; for this purpose.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;module exposes Pair, set, fst, snd

newtype Pair = [2]int32

function set(fst: int32, snd: int32) returns Pair
    return {fst, snd}
end

function fst(p: Pair) returns int32
    return p[0]
end

function snd(p: Pair) returns int32
    return p[1]
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since the internal structure is unknown additional functions must be exposed.
The module&amp;rsquo;s signature does not expose the internal type structure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;signature

newtype Pair

function set(fst: int32, snd: int32) returns Pair

function fst(p: Pair) returns int32

function snd(p: Pair) returns int32
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;non-cyclic-import-hierarchy&#34;&gt;Non-cyclic import hierarchy&lt;/h3&gt;
&lt;p&gt;The compiler takes care for non-cyclic import dependencies.
Cyclic-import dependencies are flaged as a dependency error.&lt;/p&gt;
&lt;p&gt;In order to compile a program or module file, every imported module is compiled recursively, if necessary.
Every imported module only needs to be loaded once.&lt;/p&gt;
&lt;h2 id=&#34;file-structure&#34;&gt;File structure&lt;/h2&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Partial borrowing and borrowed parts</title>
      <link>https://www.blech-lang.org/docs/language-evolution/borrowing/40_partials/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/language-evolution/borrowing/40_partials/</guid>
      <description>
        
        
        &lt;h2 id=&#34;partial-borrow-from-a-struct&#34;&gt;Partial borrow from a struct&lt;/h2&gt;
&lt;p&gt;Imagine the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;
struct From 
    var a: int32
    var b: int32
end


activity main ()
    var f: From
    run outIsPlus1(f.a)(f.b)
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The compiler can statically decide on partial borrowing for structs.
But not for arrays.&lt;/p&gt;
&lt;p&gt;The following code would be rejected&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity main (i: int32)
    var f: [2]int43
    run outIsPlus1(f[1])(f[i])
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It cannot be decide at compile-time that &lt;code&gt;f[1]&lt;/code&gt; and &lt;code&gt;f[i]&lt;/code&gt; do not overlap.
That means borrowing form arrays borrows the whole array.&lt;/p&gt;
&lt;h2 id=&#34;structs-with-references&#34;&gt;Structs with references&lt;/h2&gt;
&lt;p&gt;A struct may contain a field that is a reference in order to define an alias or an associated data type.&lt;/p&gt;
&lt;p&gt;Structs with references contain borrowed fields.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct RefStruct
    var a: int32
    let ref b: int32
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Return a struct with references requires to define which references a borrowed by the struct.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function initRefStruct (refb: int32) returns RefStruct shares refb
    return {a = 42, b = refb}
end

var b: int32 = 1
var result = initRefStruct(b)
// b is immutably borrowed to result here
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The result of type &lt;code&gt;RefStruct&lt;/code&gt; shares read-only reference &lt;code&gt;refb&lt;/code&gt;. That means it immutably borrows &lt;code&gt;refb&lt;/code&gt;.
As a consequence &lt;code&gt;result&lt;/code&gt; immutably borrows &lt;code&gt;b&lt;/code&gt;.
Consequently &lt;code&gt;b&lt;/code&gt; is frozen after &lt;code&gt;result&lt;/code&gt; is iniatialized.&lt;/p&gt;
&lt;p&gt;We could also write &lt;code&gt;initRefers&lt;/code&gt; in the following way.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function initRefStruct (refb: int32) returns RefStruct shares refb
    var r: RefStruct = {a = 42, b = refB}
    return r
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The return value is a shallow copy of the struct.&lt;/p&gt;
&lt;p&gt;The borrow checker conservatively overestimates all possible borrowing if the return value is constructed through different control path.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function initRefStruct (refb: int32, refother: int32) returns RefStruct shares refb, refother
    if aB &amp;lt; aB2 then
        return {a = 42, b = refb}
    else
        return {a = -42, b = refother}
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It also overestimates the sharing if the &lt;code&gt;shares&lt;/code&gt; refers to an output, although the &lt;code&gt;RefStruct&lt;/code&gt; value immutably borrows &lt;code&gt;refb&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function initRefStruct () (refb: int32) returns RefStruct shares refb
    refB = refB + 1
    return {a = 42, b = refB}
end

var b: int32
var rs: RefStruct = initRefStruct()(b)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Overestimation is necessary for a rather simple signature.&lt;/p&gt;
&lt;p&gt;For separate compilation borrowing in the result must become part of the signature of a function without inspection of the actual code.&lt;/p&gt;
&lt;p&gt;The three variants have of &lt;code&gt;initRefStruct&lt;/code&gt; have the following signatures&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;
function initRefStruct (refb: int32) returns RefStruct shares refb

function initRefStruct (refb: int32, refOther: int32) returns RefStruct shares refb, refother

function initRefStruct ()(refb: int32) returns RefStruct shares refb

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Struct with references can only be assigned once, because a references need to be defined at the point of their declaration.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: React - a reaction test game</title>
      <link>https://www.blech-lang.org/docs/examples/react/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/examples/react/</guid>
      <description>
        
        
        &lt;p&gt;&lt;a href=&#34;https://github.com/frameworklabs/react&#34; target=&#34;_blank&#34;&gt;This example&lt;/a&gt;
 implements a reaction test game for the &lt;a href=&#34;https://m5stack.com/products/stick-c&#34; target=&#34;_blank&#34;&gt;M5StickC&lt;/a&gt;
 programmed in the Arduino environment with the help of Blech.
Source and build instructions are &lt;a href=&#34;https://github.com/frameworklabs/react&#34; target=&#34;_blank&#34;&gt;available on GitHub&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s a nifty piece of work demonstrating how the state flow of the game and the passage of time can be handled in Blech.&lt;/p&gt;
&lt;p&gt;Thank you very much &lt;a href=&#34;https://github.com/frameworklabs&#34; target=&#34;_blank&#34;&gt;@frameworklabs&lt;/a&gt;
.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Decoding the DCF77 longwave time signal</title>
      <link>https://www.blech-lang.org/docs/examples/dcf77/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/examples/dcf77/</guid>
      <description>
        
        
        &lt;p&gt;DCF77 is a longwave radio signal which is widely used in Germany for time synchronization of clocks and watches.&lt;/p&gt;
&lt;p&gt;This example implements the decoding of the DCF77 signal in Blech on &lt;em&gt;bare metal&lt;/em&gt; using an &lt;a href=&#34;https://www.st.com/en/evaluation-tools/stm32f4discovery.html&#34; target=&#34;_blank&#34;&gt;STM32 discovery board&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;A &lt;a href=&#34;https://www.blech-lang.org/blog/2020/06/15/decoding-the-dcf77-signal-with-blech/&#34;&gt;blog post&lt;/a&gt;
 accompanies the implementation, which explains the implementation details and the simplicity of the structured synchronous top-down design.&lt;/p&gt;
&lt;p&gt;The sources are &lt;a href=&#34;https://github.com/mterber/blech-dcf77&#34; target=&#34;_blank&#34;&gt;available on GitHub&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Thank you very much &lt;a href=&#34;https://github.com/mterber&#34; target=&#34;_blank&#34;&gt;@mterber&lt;/a&gt;
 for this fine piece of work.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Types</title>
      <link>https://www.blech-lang.org/docs/user-manual/types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/types/</guid>
      <description>
        
        
        &lt;p&gt;A &lt;em&gt;type&lt;/em&gt; defines a &lt;em&gt;domain&lt;/em&gt; &amp;ndash; a set of &lt;em&gt;values&lt;/em&gt; &amp;ndash; a &lt;em&gt;representation&lt;/em&gt; for those values and a set of &lt;em&gt;operations&lt;/em&gt; on those values.&lt;/p&gt;
&lt;p&gt;Often the domains overlap between types.
Also operations may be overloaded for multiple types.
This provides the programmer with some versatility:&lt;/p&gt;
&lt;p&gt;For example, signed integers and unsigned integers share some interval in which calculations may be carried out and interpreted as either one.
Another example is that operations such as addition may have different implementations depending on type (and machine architecture): addition of 16-bit unsigned integers on a 16-bit machine invokes a different set of machine instructions than addition of 32-bit unsigned integers on that same machine.
Yet the same symbol &lt;code&gt;+&lt;/code&gt; denotes both computations in program text.
The same operator also covers additions of numbers for a completely different domain such as floats.&lt;/p&gt;
&lt;p&gt;This versatility comes at a price: the programmer has to pay attention to value ranges, make representation changes explicit and make sure that a unique implementation of an operation (such as &lt;code&gt;+&lt;/code&gt;) can be selected by the compiler.&lt;/p&gt;
&lt;p&gt;Blech is a type safe language which assists the programmer with a powerful type checker that prevents most type related errors at compile time.
It enforces type annotations and explicit casts whenever the type of an expression is not obvious or when a representation needs to be changed before the expression fits the context of an operation.&lt;/p&gt;
&lt;p&gt;The following sections precisely describe which types exist, what their domains and representations are, which operations they define and which types may be combined or transformed into one another.&lt;/p&gt;
&lt;h2 id=&#34;boolean-type&#34;&gt;Boolean type&lt;/h2&gt;
&lt;p&gt;Blech distinguishes a &lt;code&gt;bool&lt;/code&gt; type with two values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.
Boolean values may be combined using the binary &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators.
A Boolean value is inverted by the unary &lt;code&gt;not&lt;/code&gt; operator.
All comparisons are admissible.
Expressions which evaluate to a Boolean value are called &lt;em&gt;conditions&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In Blech, it is required that conditions that determine the control flow must be side-effect free.
For example, the statements &lt;code&gt;await&lt;/code&gt;, &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;repeat..until&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt; all require side-effect free conditions.
The reason is that the evaluation of a condition should not change the program&amp;rsquo;s state.
It would contradict the synchronous semantics if a program&amp;rsquo;s state changed although no reaction was performed in case an &lt;code&gt;await&lt;/code&gt; condition evaluated to &lt;code&gt;false&lt;/code&gt;.
The same reasoning applies to other synchronous control flow statements such as &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;.
Other imperative control flow statements such as loops or the &lt;code&gt;if&lt;/code&gt; statement follow the same logic for consistency and clarity of the program text.&lt;/p&gt;
&lt;h2 id=&#34;integer-types&#34;&gt;Integer types&lt;/h2&gt;
&lt;p&gt;Integer types are divided into three categories: natural numbers, signed integer numbers and &amp;ldquo;bits&amp;rdquo;.
Each one exist in four sizes that indicate the number of bits needed in a machine to represent a value of this type: 8, 16, 32, 64.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Integer types&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nat8&lt;/code&gt;, &lt;code&gt;nat16&lt;/code&gt;, &lt;code&gt;nat32&lt;/code&gt;, &lt;code&gt;nat64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Natural numbers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Signed integer numbers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bits8&lt;/code&gt;, &lt;code&gt;bits16&lt;/code&gt;, &lt;code&gt;bits32&lt;/code&gt;, &lt;code&gt;bits64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bits&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The distinction of three integral types has the following motivation.
As usual, we would like to distinguish non-negative numbers of the length &lt;code&gt;N&lt;/code&gt; with a range of &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;2^N -1&lt;/code&gt; from integer numbers centred around 0 with a range of &lt;code&gt;2^(N-1)&lt;/code&gt; to &lt;code&gt;2^(N-1) -1&lt;/code&gt;.
However, by design, the operations on both kinds of numbers prohibit overflows.
Computations must stay within the representable domain. 
&lt;em&gt;In a future implementation an overflow either causes the program to crash or to mitigate it using saturation arithmetic depending on the build mode.&lt;/em&gt;
In order to allow writing algorithms that do rely on overflowing non-negative integers as in C, as well as bit-masking and bit-shifting the &lt;code&gt;bitsX&lt;/code&gt; type is introduced.
The bits types of length &lt;code&gt;N&lt;/code&gt; have the same value range as the natural numbers of the same length.&lt;/p&gt;
&lt;p&gt;It is possible to cast between all three types without information loss so long as the size remains unchanged.&lt;/p&gt;
&lt;p&gt;All integral types types admit all arithmetic and comparison operators.
The &lt;code&gt;bitsX&lt;/code&gt; types additionally admit bitwise operations.&lt;/p&gt;
&lt;h2 id=&#34;floating-point-types&#34;&gt;Floating-point types&lt;/h2&gt;
&lt;p&gt;Blech provides the two most commonly used floating point types &lt;code&gt;float32&lt;/code&gt; and &lt;code&gt;float64&lt;/code&gt;.
The language assumes an implementation of these according to IEEE standards.
In the generated code they are mapped to C&amp;rsquo;s &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; respectively (see section on &lt;a href=&#34;#blechconfh&#34;&gt;blechconf.h&lt;/a&gt;
 below).&lt;/p&gt;
&lt;p&gt;Note that the C standard does not guarantee an IEEE compliant implementation of its floating point types nor does it require that &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; are distinct types at all.
It is the system integrators responsibility to ensure that the C compiler at hand does fulfil Blech&amp;rsquo;s assumptions.&lt;/p&gt;
&lt;p&gt;Floating point types admit all arithmetic and comparison operators.&lt;/p&gt;
&lt;h2 id=&#34;array-types&#34;&gt;Array types&lt;/h2&gt;
&lt;p&gt;The array data type is parametrised by a fixed &amp;ldquo;shape&amp;rdquo; and a payload data type.
The shape of an array is its dimensionality and length in each dimension.
It is not possible to declare an array data type with an unspecified length.&lt;/p&gt;
&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function f(a: [4][5]float32)
    /* ... */
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The function &lt;code&gt;f&lt;/code&gt; expects one read-only argument &lt;code&gt;a&lt;/code&gt;.
It is a two dimensional array (a table) with 4 rows and 5 columns.
Each cell contains a &lt;code&gt;float32&lt;/code&gt; number.&lt;/p&gt;
&lt;p&gt;Unlike C, in Blech the lengths appear before the payload type in the type declaration.&lt;/p&gt;
&lt;p&gt;Elements of an array are accessed using a subscription operation &lt;code&gt;[]&lt;/code&gt;.
The first element has index &lt;code&gt;0&lt;/code&gt;.
If an array dimension has &lt;code&gt;N&lt;/code&gt; values, the last index is &lt;code&gt;N-1&lt;/code&gt;.
The index argument must be an integer number within array bounds.&lt;/p&gt;
&lt;p&gt;The contents of one array may be copied to another using assignment provided their shape and payload data type are the same.&lt;/p&gt;
&lt;h3 id=&#34;array-operations&#34;&gt;Array operations&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;// Initialise the following matrix
//      cols
// rows 0.0  0.0
//      1.2  3.4
//      0.0  0.0
var a: [3][2]float32 = {[1]={1.2, 3.4}}

let r: [2]float32 = a[1] // copy 2nd row of a into r

let x = a[1][1]          // copy 3.4 to x
                         // x is deduced to have type float32
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;structure-types&#34;&gt;Structure types&lt;/h2&gt;
&lt;p&gt;Structure declarations introduce a new type identifier.
A structure contains a fixed number of &lt;em&gt;fields&lt;/em&gt;.
Each field has an access capability (&lt;code&gt;let&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt;), a name, some data type and possibly a default value initialiser.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StructDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;struct&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Field&lt;/span&gt;+ &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Field&lt;/span&gt;            ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;var&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;let&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If an initialiser is given for a field this value is taken as the default value when constructing an instance of this structure.
The initialisation expression must be a compile time value.
Of course, this default value may be overruled by the initialiser given at the instantiation.&lt;/p&gt;
&lt;h3 id=&#34;mutable-and-immutable-structures&#34;&gt;Mutable and immutable structures&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct S
   var a: int32 = 7
   var b: int32
end

/* ... somewhere in a local scope ... */
var s1: S    // s1 == {a = 7, b = 0}
s1.b = 17    // ok, now s1 == {a = 7, b = 17}
s1.a = 42    // ok, now s1 == {a = 42, b = 17}
s1 = {}      // ok, reset to default, now s1 == {a = 7, b = 0}

let s2: S = {a = -10, b = 10} // s2 == {a = -10, b = 10}
s2.b = 17                     // error! Cannot change the let variable s2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Structure &lt;code&gt;s1&lt;/code&gt; is declared using a &lt;code&gt;var&lt;/code&gt; access qualifier.
The fields may be overwritten as well as the structure as a whole.
By contrast, &lt;code&gt;s2&lt;/code&gt; is declared using &lt;code&gt;let&lt;/code&gt;.
It cannot be changed after initialisation.&lt;/p&gt;
&lt;p&gt;The above example illustrates all operations available on structures.
The dot &lt;code&gt;.&lt;/code&gt; is used to access a field value inside a structure.
If the value of a field again is a structure it may be further &amp;ldquo;dotted into&amp;rdquo;.
Structures may be assigned using a struct literal or a name of another struct of the same data type.
Assigning the empty literal &lt;code&gt;{}&lt;/code&gt; means that all default values are restored.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; fields cannot be changed once the structure is instantiated.
Assignment on structures as a whole is only permitted if all (sub-)field have &lt;code&gt;var&lt;/code&gt; access qualifiers (and the struct itself has been declared using &lt;code&gt;var&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&#34;immutable-fields-in-structures&#34;&gt;Immutable fields in structures&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct T
    let a: int32
    var b: int32
end

struct S
    var x: T
    var y: int32
end

/* usage in local scope */
var s: S = {x.a = 7} // ok, s == {x = {a = 7, b = 0}, y = 0}
s.x.b = 42           // ok, s == {x = {a = 7, b = 42}, y = 0}
s = {}               // error! s contains immutable fields
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assignments to the struct &lt;code&gt;s&lt;/code&gt; are prohibited because &lt;code&gt;s.x.a&lt;/code&gt; is immutable.
You need to individually specify which fields you want to update.
It may be helpful to implement a helper function for this specific data type as shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function resetS()(s: S)
    s.x.b = 0
    s.y = 0
end

/* usage in local scope */
var s: S
/* ... */
resetS()(s)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;blechconfh&#34;&gt;blechconf.h&lt;/h2&gt;
&lt;p&gt;Blech compiles to C.
Hence code generation has to map Blech types to C types.
The file &lt;code&gt;blechconf.h&lt;/code&gt; specifies this mapping.
It is automatically included (via &lt;code&gt;blech.h&lt;/code&gt;) in every generated C source file.
The Blech compiler guarantees type safety and correct operational behaviour so long as Blech types are mapped onto C types that fit above representation sizes.
It is up to the system integrator to ensure that this mapping is valid for the C compiler and hardware platform at hand.&lt;/p&gt;
&lt;p&gt;A default mapping that makes sense in most cases is shipped with the compiler:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_VOID void 
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BOOL int 
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT8 signed char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT16 signed short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT32 signed long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT64 signed long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT8 unsigned char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT16 unsigned short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT32 unsigned long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT64 unsigned long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS8 unsigned char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS16 unsigned short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS32 unsigned long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS64 unsigned long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_FLOAT32 float
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_FLOAT64 double
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;However compilers before the C99 standard may not support &lt;code&gt;unsigned long long&lt;/code&gt;, for example.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Expressions</title>
      <link>https://www.blech-lang.org/docs/user-manual/expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/expressions/</guid>
      <description>
        
        
        &lt;p&gt;The nomenclature in Blech is similar to that in C.
There are typed memory locations (objects), left hand side expressions (lvalues) and right hand side expressions (rvalues).
Blech does not allow to create function references and thus we have no designators.&lt;/p&gt;
&lt;h2 id=&#34;operator-precedence&#34;&gt;Operator precedence&lt;/h2&gt;
&lt;p&gt;The expression grammar below will not specify the precedence of operators.
This allows for a concise presentation.
Therefore this section specifies the precedence separately.&lt;/p&gt;
&lt;p&gt;All operators are left associative in Blech.
The following table summarizes the operator precedence in Blech, from lowest precedence (least binding) to highest precedence (most binding). Operators in the same box have the same precedence. Unless the syntax is explicitly given, operators are binary.&lt;/p&gt;
&lt;p&gt;Operator precedence low to high:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operators&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;as!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Type annotation and type cast&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean disjunction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;and&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean conjunction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Comparisons&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise OR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise XOR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise AND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Shifts, rotations and signed right shift&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Addition and subtraction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Multiplication, division and remainder&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;not&lt;/code&gt; x, &lt;code&gt;-&lt;/code&gt;x, &lt;code&gt;~&lt;/code&gt;x&lt;/td&gt;
&lt;td&gt;Negation, unary minus, bit inversion&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;atoms&#34;&gt;Atoms&lt;/h2&gt;
&lt;p&gt;Atoms are the building blocks of expressions.
They are composed using operators.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Atom&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Literal&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{}&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ArrayLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;StructLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ParenthForm&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that the term &amp;ldquo;atom&amp;rdquo; is not to be taken too literally because array and structure literals may contain arbitrary expressions themselves.&lt;/p&gt;
&lt;h3 id=&#34;identifiers&#34;&gt;Identifiers&lt;/h3&gt;
&lt;p&gt;An identifier occurring as an atom is a name. See section &lt;a href=&#34;../lexical/#identifiers&#34;&gt;Identifiers&lt;/a&gt;
 for a lexical definition.&lt;/p&gt;
&lt;h3 id=&#34;literals&#34;&gt;Literals&lt;/h3&gt;
&lt;p&gt;Blech supports various numeric literals:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Literal&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;BoolLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Integer&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;FloatNumber&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Evaluation of a literal yields an object of the given type (bytes, natural number, signed integer, floating point number) with the given value.
The value may be approximated in the case of floating point literals.&lt;/p&gt;
&lt;p&gt;Numeric literals are untyped on their own.
This makes their use more flexible and permits writing more generic code.
Of course, before code generation every expression (and thus every literal) must be assigned a type which is the task of the type checker.
This section explains how to use literals and what type errors may happen.&lt;/p&gt;
&lt;p&gt;Literals are assigned a type either explicitly using a &lt;em&gt;type annotation&lt;/em&gt; expression or implicitly when a unique type can be deduced from the context.&lt;/p&gt;
&lt;h4 id=&#34;annotated-literals&#34;&gt;Annotated literals&lt;/h4&gt;
&lt;p&gt;For example, the literal &lt;code&gt;1&lt;/code&gt; could represent a natural number, a signed integer or a byte word of some size. It could even be a floating point number.
It can be explicitly annotated using a type annotation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;1: nat16    // 2 bytes long natural number
1: int8     // 1 byte signed integer
1: bits32   // 4 bytes long word
1: float32  // single precision floating point number
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The lexical analysis of &lt;code&gt;Literal&lt;/code&gt; above suggests there are three kinds of literals.
In fact, we distinguish two kinds of integers.
Binary, octal and hexadecimal integer literals form the group of &lt;em&gt;bits literals&lt;/em&gt;.
They may be interpreted as a byte word of some length or as a natural number of some length.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;0xFF: nat32    // 4 byte natural number with value 255
0b101: bit8    // 1 byte word with value 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a name=&#34;bitsandints&#34;&gt;&lt;/a&gt;
They cannot be treated as a signed integer because depending on the length and the machine&amp;rsquo;s representation of negative numbers they might yield a negative or positive value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;0xFF: int8    // error! Would be -1 if represented in two&#39;s complement
0xFF: int16   // error! Would be 255 in a two byte word
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, bits literals cannot be interpreted as floating point numbers.
&lt;em&gt;For the exact specification of floating point numbers a hexadecimal float literal will be introduced.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Decimal integers&lt;/em&gt; may be interpreted as any kind of numeric type as long as the value fits the domain. The example above shows the straightforward use case with the literal &lt;code&gt;1&lt;/code&gt;. Below some corner cases are exemplified:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;-2: nat16     // error! Outside range of natural numbers
-200: int8    // error! Outside range [-128..127]
-2: bits8     // 1 byte word with value 254
-200: float32 // single precision floating point number
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Float literals may only be interpreted as either single or double precision floating point numbers even if their fraction part is zero as in &lt;code&gt;10.0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In summary: annotations may only be used where they do not change the value of the expression and the value fits into the domain of the type.&lt;/p&gt;
&lt;h4 id=&#34;type-deduction-for-literals&#34;&gt;Type deduction for literals&lt;/h4&gt;
&lt;p&gt;When a literal occurs as part of a binary expression where one side is already fully typed, the literal&amp;rsquo;s type may be automatically deduced.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;var a: int32 = 9
let b = a + 17    
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In line 1, the 9 is deduced to have type &lt;code&gt;int32&lt;/code&gt; because the left hand side is already typed.
Note that a bits literal cannot be used to initialise an integer for reasons explained &lt;a href=&#34;#bitsandints&#34;&gt;above&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;In line 2, the literal &lt;code&gt;17&lt;/code&gt; is deduced to be &lt;code&gt;int32&lt;/code&gt;, then a signed 32-bit addition is performed and &lt;code&gt;b&lt;/code&gt; is also deduced to be an &lt;code&gt;int32&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;complex-literals&#34;&gt;Complex literals&lt;/h3&gt;
&lt;h4 id=&#34;reset-literal&#34;&gt;Reset literal&lt;/h4&gt;
&lt;p&gt;Empty braces &lt;code&gt;{}&lt;/code&gt; have a special meaning.
They represent the default value for any struct or literal.
Using the reset literal in a declaration has the same effect as leaving out the initialisation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: [8]float32 = {}
var y: [8]float32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will be initialised with zeros in all cells.
The reset literal, as the name suggests, is most useful to set a modified data structure back to its default values:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: [8]float32 = {1, 2, 3, 4, 5, 6, 7, 8}
x = {}    // now x == {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The reset literal cannot be assigned to a structure that contains immutable fields (or, recursively, substructures with immutable fields).
The same is true for arrays with struct payloads.
See the section on &lt;a href=&#34;../types/#structure-types&#34;&gt;Structure types&lt;/a&gt;
 for more details.&lt;/p&gt;
&lt;h4 id=&#34;array-literals&#34;&gt;Array literals&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ArrayLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IndexExpr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;IndexExpr&lt;/span&gt;    ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;[&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The array literal has to fit the shape of the array it is assigned to.
That is, the &lt;code&gt;Expr&lt;/code&gt; in &lt;code&gt;IndexExpr&lt;/code&gt; must evaluate to a non-negative number within array bounds.
It is however permitted to specify fewer values than the number given by the array dimensions.
The missing values are implicitly set to the data type&amp;rsquo;s default value.
It is possible to set specific array cells by also specifying an index for a value.
Subsequent unindexed values will be set for the next array cells in order.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Expr&lt;/code&gt; in &lt;code&gt;CellInit&lt;/code&gt; must match the array&amp;rsquo;s data type.&lt;/p&gt;
&lt;h5 id=&#34;example-setting-array-values&#34;&gt;Example: Setting array values&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: [2][3]nat8 = {{1, 2, 3},{4, 5, 6}} // all explicit
// x is
// 1  2  3
// 4  5  6

x[1] = {7, 8}                             // third value implicitly 0
// x is
// 1  2  3
// 7  8  0

x[1] = {[1] = 9, 10}                      // first value implicitly 0
// x is                                   // the index of `10` implicitly is 2
// 1  2  3
// 0  9  10

x = {{[1] = 11},{[0] = 12, [2] = 13}}
// x is
// 0  11  0
// 12  0  13

x = { {[2]=14} }                          // second row implicitly zeroed out
// x is
// 0  0  14
// 0  0  0
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;struct-literals&#34;&gt;Struct literals&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StructLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The identifiers must match the field names of the struct to be assigned.
The &lt;code&gt;Expr&lt;/code&gt; must match the corresponding field&amp;rsquo;s data type.
Immutable (&lt;code&gt;let&lt;/code&gt; declared) fields may only be set in the initialisation of the structure.
Fields that are not specified in the literal are implicitly set to their data type&amp;rsquo;s default value.&lt;/p&gt;
&lt;h5 id=&#34;example-setting-struct-values&#34;&gt;Example: Setting struct values&lt;/h5&gt;
&lt;p&gt;Assume the following declarations:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct S
    var a: int8
    var b: int8
end

struct T
    let x: bool
    var y: S
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The following code may be written (in some local scope):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var t: T = {x = true, y = {a = 1, b = 2}}
// t is
// t.x == true
// t.y.a == 1
// t.y.b == 2

t = {y = {a = 7}} // error! Cannot assign immutable field t.x

t.y = {a = 7}     // implicitly b = 0
// t is
// t.x == true
// t.y.a == 7
// t.y.b == 0
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;parenthesised-form&#34;&gt;Parenthesised form&lt;/h2&gt;
&lt;p&gt;A parenthesised form is an expression enclosed in parentheses:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ParenthForm&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A parenthesised expression yields whatever that expression yields.&lt;/p&gt;
&lt;h2 id=&#34;primaries&#34;&gt;Primaries&lt;/h2&gt;
&lt;p&gt;Primaries represent the most tightly bound operations of the language. Their syntax is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Atom&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Selection&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Subscription&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;FunctionCallExpr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;field-selection&#34;&gt;Field selection&lt;/h2&gt;
&lt;p&gt;A field selection is a primary expression followed by a period and a name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Selection&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Primary&lt;/code&gt; must evaluate to a struct instance that contains a field with the name given by &lt;code&gt;Identifier&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;subscriptions&#34;&gt;Subscriptions&lt;/h2&gt;
&lt;p&gt;A subscripting expression selects an item of an array:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Subscription&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;[&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expression&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The index expression must return a value that is non-negative and smaller than the array length.
Otherwise the program will crash in debug build mode and saturate to array index bounds in release mode.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;
The current implementation relies on C semantics and has no build modes. It will not necessarily crash, since C may read any addressable memory.
&lt;/div&gt;

&lt;h2 id=&#34;calls&#34;&gt;Calls&lt;/h2&gt;
&lt;p&gt;A call calls a function with a possibly empty series of arguments:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;FunctionCallExpr&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;all-computation-expressions&#34;&gt;All computation expressions&lt;/h2&gt;
&lt;p&gt;All expressions above are concerned with retrieving a single value from some data structure. (With the exception of function calls).
Now all expressions are presented which take a value (or two) and produce a new value from it (those).
The following rule gives an overview of the remaining expression syntax.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt;                                            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;highest&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;precedence&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; 
    | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;~&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;not&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;%&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;lt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;lt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;amp;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;^&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;|&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;==&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;!=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;and&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;or&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;as&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;as!&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;lowest&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;precedence&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Operator precedence has been discussed &lt;a href=&#34;#operator-precedence&#34;&gt;above&lt;/a&gt;
.&lt;/p&gt;
&lt;h3 id=&#34;unary-operations&#34;&gt;Unary operations&lt;/h3&gt;
&lt;p&gt;The unary &lt;code&gt;-&lt;/code&gt; (minus) operator yields the negation of its numeric argument.
If the argument is a literal without an annotation, it may not be a binary, octal or hexadecimal number because these are supposed to be some &lt;code&gt;bitX&lt;/code&gt; type without a known length (yet) and the result of a minus cannot be defined.&lt;/p&gt;
&lt;p&gt;The unary &lt;code&gt;~&lt;/code&gt; (invert) operator yields the bitwise inversion of its &lt;code&gt;bitsX&lt;/code&gt; argument.
It cannot be applied to a literal without a type annotation.&lt;/p&gt;
&lt;p&gt;The unary &lt;code&gt;not&lt;/code&gt; operator yields the opposite of its Boolean argument.&lt;/p&gt;
&lt;h3 id=&#34;binary-arithmetic-operations&#34;&gt;Binary arithmetic operations&lt;/h3&gt;
&lt;p&gt;The binary arithmetic operations require that the arguments are of some numeric type.&lt;/p&gt;
&lt;p&gt;The arithmetic operations work as expected on all arithmetic types.
See the sections on &lt;a href=&#34;../types/#integer-types&#34;&gt;arithmetic types&lt;/a&gt;
 for details regarding overflow handling.&lt;/p&gt;
&lt;p&gt;The arguments&amp;rsquo; types may differ only in size.
When they differ, the smaller size value is lifted implicitly to the larger size.
The operation is then carried out on (possibly lifted) arguments of the same type.&lt;/p&gt;
&lt;h4 id=&#34;lifting-types&#34;&gt;Lifting types&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int8 = 7
var y: int16 = 300
var z = x + y
var u = x + 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both signed integers but have different sizes.
In the context of the addition in line 3, the smaller type is lifted to the larger, effectively making &lt;code&gt;x&lt;/code&gt; an &lt;code&gt;int16&lt;/code&gt;.
Then, 16-bit signed addition is carried out producing an &lt;code&gt;int16&lt;/code&gt; typed result.
This result is stored into &lt;code&gt;z&lt;/code&gt; making it a &lt;code&gt;int16&lt;/code&gt; variable, too.&lt;/p&gt;
&lt;p&gt;In line 4, the literal &lt;code&gt;1&lt;/code&gt; is deduced to be of type &lt;code&gt;int8&lt;/code&gt; in the context of this expression (cf. paragraph on &lt;a href=&#34;#type-deduction-for-literals&#34;&gt;type deduction&lt;/a&gt;
 for literals).
Then, 8-bit signed addition is carried out producing an &lt;code&gt;int8&lt;/code&gt; typed result.
This result is stored into &lt;code&gt;u&lt;/code&gt; making it a &lt;code&gt;int8&lt;/code&gt; variable, too.&lt;/p&gt;
&lt;p&gt;The following snippet shows typical caveats.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;var x: int32 = 49 - 7    // error! Cannot determine type of &amp;#39;49&amp;#39; and &amp;#39;7&amp;#39;

var y: int8 = (49: int8) - 128 // error 128 does not fit into int8

var a: bits8 = 0x1
var b: nat8 = 2
var c = a + b            // error! Type mismatch
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In line 1, the context of &lt;code&gt;49&lt;/code&gt; is &lt;code&gt;7&lt;/code&gt; and vice versa.
Both do not have a concrete type.
It is therefore not clear which implementation of &lt;code&gt;-&lt;/code&gt; should be invoked.
The code only specifies that the result will be stored in an &lt;code&gt;int32&lt;/code&gt; memory location but several different types (&lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;) would fit in there.&lt;/p&gt;
&lt;p&gt;In line 3, the previous issue was resolved by specifying that &lt;code&gt;49&lt;/code&gt; should be treated as an &lt;code&gt;int8&lt;/code&gt;.
Thus the other operand must be an &lt;code&gt;int8&lt;/code&gt; as well but the given literal is outside the &lt;code&gt;int8&lt;/code&gt; domain.
(In this particular case, writing &lt;code&gt;(49: int8) + (-128)&lt;/code&gt; would solve the problem due to the asymmetry of signed integers.)&lt;/p&gt;
&lt;p&gt;The last line shows an operation on different types (of the same size).
Addition for natural numbers must not overflow while addition for bits will wrap around.
It is not clear which one should be used here.
Either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; need to be explicitly cast using the &lt;code&gt;as&lt;/code&gt; operator to resolve this issue.&lt;/p&gt;
&lt;h3 id=&#34;bitwise-operations&#34;&gt;Bitwise operations&lt;/h3&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

// TODO
&lt;/div&gt;

&lt;h3 id=&#34;comparison-operations&#34;&gt;Comparison operations&lt;/h3&gt;
&lt;p&gt;Unlike C, in Blech equality and inequality have the same priority as the ordering operators.
Furthermore the precedence of comparison operators is lower than that of any arithmetic, shifting or bitwise operation.&lt;/p&gt;
&lt;p&gt;Note that all operators are left associative.
Hence chaining comparisons is possible syntactically but makes little sense.&lt;/p&gt;
&lt;h4 id=&#34;comparison-chaining&#34;&gt;Comparison chaining&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var b = 4 &amp;lt; 5 &amp;lt;= false // evaluates to true &amp;lt;= false which is false
var c = 4 &amp;lt; 5 &amp;lt;= 6 // type error: cannot compare true &amp;lt;= 6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is different to C because in Blech Booleans and numbers are incomparable.&lt;/p&gt;
&lt;h4 id=&#34;comparison-lifting&#34;&gt;Comparison lifting&lt;/h4&gt;
&lt;p&gt;Comparison operators lift their arguments to a common sized type like arithmetic operators do (see above).
Additionally, comparisons permit using literals that would require a larger domain.
This allows writing (in)equalities without cluttering the code with trivial type casts.&lt;/p&gt;
&lt;h5 id=&#34;example-comparison-with-literals-outside-the-domain&#34;&gt;Example: Comparison with literals outside the domain&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int8 = 7
var y = x &amp;lt; 1000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The literal &lt;code&gt;1000&lt;/code&gt; is a (signed) integral number and would fit into an &lt;code&gt;int16&lt;/code&gt;.
Therefore we allow to implicitly lift &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;int16&lt;/code&gt; and carry out the comparison.
This makes sense because the result of all comparison operators is always a Boolean value.
There are no &amp;ldquo;surprises&amp;rdquo; about the outcome.&lt;/p&gt;
&lt;h3 id=&#34;logical-operatorions&#34;&gt;Logical operatorions&lt;/h3&gt;
&lt;p&gt;The operators &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; may only be applied to Boolean typed arguments.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;a and b&lt;/code&gt; is true if and only if &lt;code&gt;a&lt;/code&gt; is true and &lt;code&gt;b&lt;/code&gt; is true.
The evaluation is performed lazily: first &lt;code&gt;a&lt;/code&gt; is evaluated. If it is false, the expression returns &lt;code&gt;false&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;a or b&lt;/code&gt; is true unless both &lt;code&gt;a&lt;/code&gt; is false and &lt;code&gt;b&lt;/code&gt; is false.
The evaluation is performed lazily: first &lt;code&gt;a&lt;/code&gt; is evaluated. If it is true, the expression returns &lt;code&gt;true&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;representation-annotation-and-change&#34;&gt;Representation annotation and change&lt;/h3&gt;
&lt;p&gt;Type annotations specify a concrete type for a literal which may represent values from different types.&lt;/p&gt;
&lt;p&gt;Type casts &lt;em&gt;change&lt;/em&gt; the type of an already typed expression.
Casts are only permitted where the (machine) representation of a value will not change and casts assume that the value fits into the target type&amp;rsquo;s domain.&lt;/p&gt;
&lt;h4 id=&#34;safe-casts&#34;&gt;Safe casts&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int16 = 100
let y = x as nat8    // ok, y == 100 of type nat8

x = x * 3
let z = x as nat8    // runtime error: 300 outside nat8 domain 0..255

x = -256             // assuming 2&#39;s complement on the machine:
                     // x == 0xb_1111_1111_0000_0000
let u = x as bits8   // runtime error
let v = x as bits16  // ok, v == 65280

let f: float32 = 1
x = f as int16       // error! impossible to cast floating point to integral types
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The restrictions on the casts do not rule out runtime errors.
At the same time they prevent some manipulations that are possible in C.
For example, it is not possible to interpret a floating point as a bits type and change individual bits.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

// TODO is the description of &lt;code&gt;as&lt;/code&gt; correct? Are there restrictions, bugs, features?
&lt;/div&gt;

&lt;h3 id=&#34;evaluation-order&#34;&gt;Evaluation order&lt;/h3&gt;
&lt;p&gt;Undefined at the moment. Evaluated by the C compiler.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: </title>
      <link>https://www.blech-lang.org/docs/blechc-development/traversals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/blechc-development/traversals/</guid>
      <description>
        
        
        &lt;h2 id=&#34;recursive-traversals-that-do-similar-things&#34;&gt;Recursive traversals that do similar things&lt;/h2&gt;
&lt;!-- ## Recursive traversals on typed Blech data structures --&gt;
&lt;h3 id=&#34;typecheckingfs&#34;&gt;TypeChecking.fs&lt;/h3&gt;
&lt;h4 id=&#34;traversing-statements-only&#34;&gt;Traversing statements only&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/// Determine the return type of a statement
let rec private stmtType stmt
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/// An activity must have some synchronous delay statement on every possible 
/// execution path through its body.
/// This can be an await or a run statement.
// This is partially double work with causality analysis, 
// here and there we will find instantaneous loops.
// Here we throw an error if that is the only statement in the activity.
// In causality analysis we throw an error any way.
let private checkStmtsWillPause p name stmts
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;let private determineGlobalOutputs lut bodyRes
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;traversing-expressions-and-statements&#34;&gt;Traversing expressions and statements&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/// Checks whether the lists of statements does not contain any synchronous
/// statements. This check is required for function bodies.
let private checkAbsenceOfSyncStmts stmts
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;let private determineCalledSingletons lut bodyRes =
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;tychkexpressionsfs&#34;&gt;TyChkExpressions.fs&lt;/h3&gt;
&lt;h4 id=&#34;traversing-expressions-only&#34;&gt;Traversing expressions only&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/// Returns true when the evaluation of expr does not change the program&#39;s state
let rec private hasNoSideEffect expr
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/// True if given expression contains only compile time or param values
let rec internal isStaticExpr lut expr
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/// Given a typed rhs expression, this function tries to evaluate this 
/// expression to a constant and return a new TypedRhs such that
/// isLiteral returns true on that.
/// However, it may return a non-constant expression if it cannot be
/// reduced. No error is thrown.
let rec internal tryEvalConst lut (checkedExpr: TypedRhs) : TypedRhs
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;tychkamendmentfs&#34;&gt;TyChkAmendment.fs&lt;/h3&gt;
&lt;h4 id=&#34;traversing-expressions-only-1&#34;&gt;Traversing expressions only&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/// Returns yes if the expression contains at least one name
/// This is useful for type checking where we want to make sure that
/// in a variable declaration such as &amp;quot;var x = 8&amp;quot;, we do not merely
/// look at the type of &amp;quot;8&amp;quot; which is int8 and falsely make x an int8
/// as well but instead give an error to the user.
let rec private exprContainsName rhs
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;programgraphfs&#34;&gt;ProgramGraph.fs&lt;/h3&gt;
&lt;h4 id=&#34;traversing-expressions-only-2&#34;&gt;Traversing expressions only&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;let rec internal addNameRead context node trhs =
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/// This function is here temporarily. It solves the following problem:
/// Since the abort conditions are pushed into the body of the abort statement
/// conditions may become concurrent in the context of a cobegin in the body.
/// This is a problem if the condition is modified in the body. The scheduler
/// will generate wrong code following the write first-then read strategy.
/// To avoid that we prev all variables which are part of the abort condition
/// and which are modified inside the abort body.
/// In the future we want to generate code for preemptions differently
/// such that prev&#39;ing conditions won&#39;t be necessary.
/// This future implementation would introduce another control point which is
/// traversed in every reaction before executing any blocks that correspond to
/// the abort body.
/// The future solution would allow to use references in cond which cannot be prev&#39;ed.
/// As of right now references are not implemented and thus the 
/// current implementation always works.
let private tempPrevHelper context cond subPg
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;traversing-statements-only-1&#34;&gt;Traversing statements only&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/// Generates a program graph for a given statement
let rec private createPGofStmt context thread stmt
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;cpdataaccessfs&#34;&gt;CPdataAccess.fs&lt;/h3&gt;
&lt;h4 id=&#34;traversing-expressions-only-3&#34;&gt;Traversing expressions only&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/// Convert expressions into Doc
/// Ensures that function calls with struct literals in their input list are
/// converted to function calls on precomputed structure variables.
// The result propagates recursively.
// Even if the resulting data type is simple, the expression producing that
// may contain sub-expressions that need to be rewritten, e.g.
// g( f({i=8}) ), where f is simply boolean but its argument needs to be rewritten
and private cpExpr inFunction ctx expr
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;activitytranslatorfs&#34;&gt;ActivityTranslator.fs&lt;/h3&gt;
&lt;h4 id=&#34;traversing-expressions-only-4&#34;&gt;Traversing expressions only&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/// Extract all QNames of variables that require a prev location in given code
// runs on nodes and program graphs instead of statements
// became necessary when strong abort was translated by introducing a prev on the condition and thus deviating from given source code
// might change again
let private collectVarsToPrev2 pg
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;functiontranslatorfs&#34;&gt;FunctionTranslator.fs&lt;/h3&gt;
&lt;h4 id=&#34;traversing-statements-only-2&#34;&gt;Traversing statements only&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;and private translateFunctionStatement ctx curComp stmt
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
  </channel>
</rss>
