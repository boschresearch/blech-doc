<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blech – The Blech language - user manual</title>
    <link>https://www.blech-lang.org/docs/user-manual/</link>
    <description>Recent content in The Blech language - user manual on Blech</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://www.blech-lang.org/docs/user-manual/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Model of execution</title>
      <link>https://www.blech-lang.org/docs/user-manual/moc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/moc/</guid>
      <description>
        
        
        &lt;h2 id=&#34;reactive-execution&#34;&gt;Reactive execution&lt;/h2&gt;
&lt;p&gt;Unlike classical desktop applications that solve a given task, a Blech application does not run in isolation by itself.
It interacts with a so-called &lt;em&gt;environment&lt;/em&gt; that triggers a &lt;em&gt;reaction&lt;/em&gt; of the Blech program.&lt;/p&gt;
&lt;p&gt;Typically, the environment provides a set of &lt;em&gt;inputs&lt;/em&gt; to a Blech program. These inputs may, for example, be sensor readings.
The environment then expects the Blech program to perform some computations and finally return a set of updated &lt;em&gt;outputs&lt;/em&gt;.
Outputs can be interpreted by the environment, for example, as set points for actuators.&lt;/p&gt;
&lt;p&gt;We deliberately use the generic word &amp;ldquo;environment&amp;rdquo; because depending on the use case it may have a different form. 
It ranges from just a loop that calls the Blech application as soon as the last reaction has finished to a sophisticated real-time operating system which manages several tasks, timers and event queues.&lt;/p&gt;
&lt;p&gt;The Blech program maintains its state from one reaction to the next.
Thus a reaction does not merely depend on the given inputs but also on the state of the program itself.&lt;/p&gt;
&lt;h2 id=&#34;synchrony&#34;&gt;Synchrony&lt;/h2&gt;
&lt;p&gt;Blech is a &lt;em&gt;synchronous&lt;/em&gt; language.
That means its semantics adhere to the &amp;ldquo;synchrony assumption&amp;rdquo;.
In simple terms it states that a reaction happens instantaneously (takes no physical time).
Thus program execution proceeds in discrete reactions and there is no observable behaviour in between.&lt;/p&gt;
&lt;p&gt;This is of course not implementable in reality but rather a guideline for semantics that has implications on language design and induces a set of crucial properties that make the programmer&amp;rsquo;s life easier.&lt;/p&gt;
&lt;p&gt;One implication is that inputs keep their value throughout the reaction. This prevents a volatile behaviour where two readings of the same variable in the same reaction may produce two different values.&lt;/p&gt;
&lt;p&gt;The other implication  is that concurrent computations adhere to a &lt;a href=&#34;https://en.wikipedia.org/wiki/Consistency_model#Strict_consistency&#34; target=&#34;_blank&#34;&gt;strict consistency&lt;/a&gt;
 notion.
In essence, this means that &amp;ldquo;a write to a variable by any thread needs to be seen instantaneously by all threads [&amp;hellip;] it assumes concurrent writes to be impossible&amp;rdquo;.
Therefore race conditions are excluded by design.
Since each concurrent thread of execution perceives the others as instantaneous, every shared variable must assume precisely one value throughout the reaction.
It must not be possible for a reader to read two different values for a shared variable within one reaction.
This would discern computation into (at least two) different logical time steps and violate the assumption that the computation happened instantaneously.&lt;/p&gt;
&lt;p&gt;This semantics is very attractive to the programmer because concurrent programming becomes simple to understand and debug.
It is the single most crucial distinctive feature of synchronous programming languages in general, and Blech in particular.
Usually in asynchronous, thread-based programming this strict consistency notion is impossible to achieve in practice.
However strict consistency becomes possible in our setting because of two ingredients usually not present in asynchronous concurrent programming:
the distinction of individual reactions; and the distinction of a thread-local view and a global view on shared memory.&lt;/p&gt;
&lt;p&gt;Synchronous languages differ in what programs they admit such that strict consistency is guaranteed. 
Such programs are called causally correct or simply &lt;em&gt;causal&lt;/em&gt;.
The next section explains what this means for Blech.&lt;/p&gt;
&lt;h2 id=&#34;causality&#34;&gt;Causality&lt;/h2&gt;
&lt;p&gt;The strict consistency memory model excludes write conflicts by definition.
Since we think of program execution as reaction steps, this means causal programs must have at most one writer per shared variable in one reaction.
In Blech we restrict this even further and require that there is at most one writer within a fork-join scope which is potentially executed for multiple reactions.
This is made more precise in the chapter when we &lt;a href=&#34;../statements/#cobegin&#34;&gt;explain the &lt;code&gt;cobegin&lt;/code&gt; statement&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Furthermore, there is a &amp;ldquo;thread-local&amp;rdquo; view of shared variables and a &amp;ldquo;thread-global&amp;rdquo; view.
We require that in the thread-global view every shared variable is set to one value by the writer that all other threads may read.
However the writer-thread may update (and read) the variable multiple times locally.
Thus multiple values exist in the thread-local view but they are not observable by concurrent threads nor by the environment and the &amp;ldquo;illusion&amp;rdquo; of instantaneous updates is maintained.
Only the last written value is communicated to the concurrent readers.
Of course, &amp;ldquo;last&amp;rdquo; is to be understood with respect to the current reaction.
In essence, for every variable there is a write-before-read policy in every reaction.
This allows for normal sequential imperative programming within a thread and at the same time leverages the expressiveness and simplicity of synchronous concurrent programming.
Note that this deliberately excludes programs where threads are mutually (cyclically) dependent within a reaction.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;

    There is at most one writer per shared variable. The writer must finish its last writing operation to a shared variable in the current reaction before concurrent readers may read it.

&lt;/div&gt;

&lt;p&gt;The compiler phase that statically ensures a given Blech program is causal is called &lt;em&gt;causality analysis&lt;/em&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Notation</title>
      <link>https://www.blech-lang.org/docs/user-manual/notation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/notation/</guid>
      <description>
        
        
        &lt;p&gt;We use a modified Backus-Naur form notation to describe the Blech language syntax.
The modifications to the original BNF make the rules look more like regular expressions.
We follow the same notation conventions as the &lt;a href=&#34;https://docs.python.org/3/reference/index.html&#34; target=&#34;_blank&#34;&gt;Python language documentation&lt;/a&gt;
. Here is what they write about notation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The descriptions of lexical analysis and syntax use a modified BNF grammar notation. This uses the following style of definition:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The first line says that a &lt;code&gt;name&lt;/code&gt; is an &lt;code&gt;lc_letter&lt;/code&gt; followed by a sequence of zero or more &lt;code&gt;lc_letter&lt;/code&gt;s and underscores. An &lt;code&gt;lc_letter&lt;/code&gt; in turn is any of the single characters &lt;code&gt;&#39;a&#39;&lt;/code&gt; through &lt;code&gt;&#39;z&#39;&lt;/code&gt;. (This rule is actually adhered to for the names defined in lexical and grammar rules in this document.)&lt;/p&gt;
&lt;p&gt;Each rule begins with a name (which is the name defined by the rule) and &lt;code&gt;::=&lt;/code&gt;. A vertical bar (&lt;code&gt;|&lt;/code&gt;) is used to separate alternatives; it is the least binding operator in this notation. A star (&lt;code&gt;*&lt;/code&gt;) means zero or more repetitions of the preceding item; likewise, a plus (&lt;code&gt;+&lt;/code&gt;) means one or more repetitions, and a phrase enclosed in square brackets (&lt;code&gt;[ ]&lt;/code&gt;) means zero or one occurrences (in other words, the enclosed phrase is optional). The &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; operators bind as tightly as possible; parentheses are used for grouping. Literal strings are enclosed in quotes. White space is only meaningful to separate tokens. Rules are normally contained on a single line; rules with many alternatives may be formatted alternatively with each line after the first beginning with a vertical bar.&lt;/p&gt;
&lt;p&gt;In lexical definitions (as the example above), two more conventions are used: Two literal characters separated by three dots mean a choice of any single character in the given (inclusive) range of ASCII characters. A phrase between angular brackets (&lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;) gives an informal description of the symbol defined; e.g., this could be used to describe the notion of ‘control character’ if needed.&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Lexical elements</title>
      <link>https://www.blech-lang.org/docs/user-manual/lexical/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/lexical/</guid>
      <description>
        
        
        &lt;h2 id=&#34;comments&#34;&gt;Comments&lt;/h2&gt;
&lt;p&gt;Single line comments are C++ style. They begin with &lt;code&gt;//&lt;/code&gt; and end with the end of line.&lt;/p&gt;
&lt;p&gt;Multi-line comments are C style. They begin with &lt;code&gt;/*&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. 
Comment nesting is supported.&lt;/p&gt;
&lt;h3 id=&#34;declaration-comments&#34;&gt;Declaration Comments&lt;/h3&gt;
&lt;p&gt;A special comment syntax allows to write comments for declarations (functions, activities, types, variables, &amp;hellip;) which will be transported over to the generated C code.
This allows to document the API and make this documentation available to the C programmer who integrates generated code in a larger scope.&lt;/p&gt;
&lt;p&gt;There are two supported styles of declaration comments.
Java style multi-line comments &lt;code&gt;/** */&lt;/code&gt; and .Net style single line comments &lt;code&gt;///&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that using declaration comments before something that is not a declaration, e.g. an assignment, is a syntax error.&lt;/p&gt;
&lt;h2 id=&#34;built-in-operators-and-separators&#34;&gt;Built-in Operators and Separators&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operators and Separators&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Logical operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;not&lt;/code&gt; &lt;code&gt;and&lt;/code&gt; &lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arithmetic operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bitwise operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; `&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Relational operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Type conversion&lt;/td&gt;
&lt;td&gt;&lt;code&gt;as&lt;/code&gt; &lt;code&gt;as!&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Separators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;;&lt;/code&gt; &lt;code&gt;:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;keywords&#34;&gt;Keywords&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;abort&lt;/code&gt;
&lt;code&gt;activity&lt;/code&gt;
&lt;code&gt;and&lt;/code&gt;
&lt;code&gt;as&lt;/code&gt; 
&lt;code&gt;await&lt;/code&gt;
&lt;code&gt;bits8&lt;/code&gt;
&lt;code&gt;bits16&lt;/code&gt; 
&lt;code&gt;bits32&lt;/code&gt;
&lt;code&gt;bits64&lt;/code&gt;
&lt;code&gt;blech&lt;/code&gt;
&lt;code&gt;bool&lt;/code&gt;
&lt;code&gt;cobegin&lt;/code&gt;
&lt;code&gt;const&lt;/code&gt;
&lt;code&gt;do&lt;/code&gt;
&lt;code&gt;else&lt;/code&gt;
&lt;code&gt;elseif&lt;/code&gt;
&lt;code&gt;end&lt;/code&gt;
&lt;code&gt;exposes&lt;/code&gt;
&lt;code&gt;extern&lt;/code&gt;
&lt;code&gt;false&lt;/code&gt;
&lt;code&gt;float32&lt;/code&gt;
&lt;code&gt;float64&lt;/code&gt;
&lt;code&gt;function&lt;/code&gt;
&lt;code&gt;if&lt;/code&gt;
&lt;code&gt;import&lt;/code&gt;
&lt;code&gt;int8&lt;/code&gt;
&lt;code&gt;int16&lt;/code&gt;
&lt;code&gt;int32&lt;/code&gt;
&lt;code&gt;int64&lt;/code&gt;
&lt;code&gt;internal&lt;/code&gt;
&lt;code&gt;let&lt;/code&gt;
&lt;code&gt;module&lt;/code&gt;
&lt;code&gt;nat8&lt;/code&gt;
&lt;code&gt;nat16&lt;/code&gt;
&lt;code&gt;nat32&lt;/code&gt;
&lt;code&gt;nat64&lt;/code&gt;
&lt;code&gt;not&lt;/code&gt;
&lt;code&gt;or&lt;/code&gt;
&lt;code&gt;param&lt;/code&gt;
&lt;code&gt;prev&lt;/code&gt;
&lt;code&gt;repeat&lt;/code&gt;
&lt;code&gt;run&lt;/code&gt;
&lt;code&gt;reset&lt;/code&gt;
&lt;code&gt;return&lt;/code&gt;
&lt;code&gt;returns&lt;/code&gt;
&lt;code&gt;signature&lt;/code&gt;
&lt;code&gt;singleton&lt;/code&gt;
&lt;code&gt;struct&lt;/code&gt;
&lt;code&gt;then&lt;/code&gt;
&lt;code&gt;true&lt;/code&gt;
&lt;code&gt;type&lt;/code&gt;
&lt;code&gt;until&lt;/code&gt;
&lt;code&gt;var&lt;/code&gt;
&lt;code&gt;weak&lt;/code&gt;
&lt;code&gt;when&lt;/code&gt;
&lt;code&gt;while&lt;/code&gt;
&lt;code&gt;with&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Additionally, the current compiler implementation reserves keywords for concepts that were designed into the language but not yet implemented. Reserved keywords include:
&lt;code&gt;assert&lt;/code&gt;
&lt;code&gt;assume&lt;/code&gt;
&lt;code&gt;default&lt;/code&gt;
&lt;code&gt;emit&lt;/code&gt;
&lt;code&gt;enum&lt;/code&gt;
&lt;code&gt;error&lt;/code&gt;
&lt;code&gt;extension&lt;/code&gt;
&lt;code&gt;in&lt;/code&gt;
&lt;code&gt;next&lt;/code&gt;
&lt;code&gt;of&lt;/code&gt;
&lt;code&gt;past&lt;/code&gt;
&lt;code&gt;print&lt;/code&gt;
&lt;code&gt;ref&lt;/code&gt;
&lt;code&gt;shares&lt;/code&gt;
&lt;code&gt;signal&lt;/code&gt;
&lt;code&gt;suspend&lt;/code&gt;
&lt;code&gt;throw&lt;/code&gt;
&lt;code&gt;throws&lt;/code&gt;
&lt;code&gt;try&lt;/code&gt;
&lt;code&gt;typealias&lt;/code&gt;
&lt;code&gt;unit&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;identifiers&#34;&gt;Identifiers&lt;/h2&gt;
&lt;p&gt;An identifier is any token that is not a keyword and starts with a letter or underscore and continues with an arbitrary number of letters, digits or underscores.
The precise definition is given by the following grammar rule&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;Z&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+ &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;Z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that identifiers have an infix of at least one letter.&lt;/p&gt;
&lt;h2 id=&#34;wildcard&#34;&gt;Wildcard&lt;/h2&gt;
&lt;p&gt;Additionally we reserve a token that consists of underscores only.
We call this the &amp;ldquo;wildcard&amp;rdquo;. Wildcards are useful when you want to discard the result of a computation without declaring a dummy variable.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;_ = f()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this example you cannot just call &lt;code&gt;f&lt;/code&gt; like in C because the Blech compiler will complain that &lt;code&gt;f&lt;/code&gt; is declared to return a value but there is no location to store this value in. The wildcard makes the intention to discard the returned value &lt;em&gt;explicit&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;literals&#34;&gt;Literals&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;        ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;NonZeroDigit&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;BinInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0b&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+
&lt;span style=&#34;color:#000&#34;&gt;OctInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0o&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;7&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+
&lt;span style=&#34;color:#000&#34;&gt;HexInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;f&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;F&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+  
&lt;span style=&#34;color:#000&#34;&gt;DecInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;NonZeroDigit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;Integer&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DecInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;BinInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;OctInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;HexInteger&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;FloatNumber&lt;/span&gt;   ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ExponentFloat&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt;    ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Fraction&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Fraction&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ExponentFloat&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;exponent&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Exponent&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;e&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;E&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Statements</title>
      <link>https://www.blech-lang.org/docs/user-manual/statements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/statements/</guid>
      <description>
        
        
        &lt;p&gt;In its core, Blech is an imperative language.
Blech strictly separates between &lt;em&gt;statements&lt;/em&gt; that govern the flow of control and &lt;em&gt;expressions&lt;/em&gt; that evaluate to a value.
Both, a statement and an expression may have side-effects.&lt;/p&gt;
&lt;h2 id=&#34;activities-and-functions&#34;&gt;Activities and functions&lt;/h2&gt;
&lt;p&gt;Control flow is organised with two kinds of procedures: &lt;em&gt;activities&lt;/em&gt; and &lt;em&gt;functions&lt;/em&gt;.
Functions are used like in any other imperative language.
In Blech they have two parameter lists to support causality analysis.&lt;/p&gt;
&lt;p&gt;See the section on &lt;a href=&#34;../../declarations/#subprograms&#34;&gt;subprogram declarations&lt;/a&gt;
 for more details.&lt;/p&gt;
&lt;p&gt;Functions must terminate within a reaction. Therefore they are said to be instantaneous.&lt;/p&gt;
&lt;p&gt;Activities are called similarly to functions but their execution continues until it reaches a pause to end the current reaction.
In the next reaction they resume from the location they have paused and continue execution until the next pause.
Each reaction of an activity must end after finitely many computation steps.
However the activity itself may perform an unbounded number of reactions and never terminate.
It may also terminate after a finite number of reactions.
In any case, activities must not be instantaneous&amp;mdash;they need to pause at least once before termination.
The values of local variables in activities are stored from one reaction to the next.&lt;/p&gt;
&lt;p&gt;Activities may call other activities or functions.
Functions however can only call other functions.&lt;/p&gt;
&lt;h2 id=&#34;synchronous-statements&#34;&gt;Synchronous statements&lt;/h2&gt;
&lt;p&gt;Here we discuss statements that are specific to the synchronous paradigm of Blech.
These statements control the reactive behaviour of the program and hence may only appear inside activities, not in functions.&lt;/p&gt;
&lt;h3 id=&#34;await&#34;&gt;Await&lt;/h3&gt;
&lt;p&gt;The aforementioned &amp;ldquo;pause&amp;rdquo; is denoted as follows.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Pause&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;await&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;await&lt;/code&gt; statement marks the end of a reaction.
The control flow stops at this statement and the program &amp;ldquo;waits&amp;rdquo; for the next reaction to start.
Once an activity resumes its execution at an &lt;code&gt;await&lt;/code&gt; statement the condition is checked.
If it is true, the control flow proceeds to the next statement.
Otherwise, the reaction ends immediately and the control flow remains at the same location.&lt;/p&gt;
&lt;h4 id=&#34;example-simple-reactive-control-flow&#34;&gt;Example: Simple reactive control flow&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity MyAct (in1: bool, in2: float32) (out1: uint8)
    repeat
        await in1
        out1 = (out1 + 1) % 100 // count from 0 to 99
    until in2 &amp;lt; 0.0 end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Initially, &lt;code&gt;MyAct&lt;/code&gt; is entered and the control flow proceeds to line 3 and stops (regardless of the inputs).
In the next tick, &lt;code&gt;MyAct&lt;/code&gt; resumes its execution at the &lt;code&gt;await&lt;/code&gt; statement in line 3.
It checks the boolean input variable &lt;code&gt;in1&lt;/code&gt;.
If it is false, the reaction ends immediately, the control flow does not advance.
Otherwise, if &lt;code&gt;in1&lt;/code&gt; is true, the calculation is carried out in line 4.
This updates &lt;code&gt;out1&lt;/code&gt; to a new value.
Finally, if input &lt;code&gt;in2&lt;/code&gt; is indeed less than 0 the activity terminates its execution.
Otherwise the control flow loops around from line 5 back to line 2 and finally the reaction ends again in line 3.&lt;/p&gt;
&lt;h4 id=&#34;example-proceed-with-the-next-tick&#34;&gt;Example: Proceed with the next tick&lt;/h4&gt;
&lt;p&gt;For example in time triggered systems we often just want to await the next period and proceed. This is simply expressed by&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;await true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;run&#34;&gt;Run&lt;/h3&gt;
&lt;p&gt;An activity call is given by the following grammar.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ActivityCall&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;run&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Receiver&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Receiver&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Wildcard&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; | &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;var&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;let&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;])&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;()&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;()&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsExpr&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsExpr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; keyword indicates an activity call.
Arguments must be provided that match the callee&amp;rsquo;s declaration in number and type.
If the callee does not declare any outputs the second pair of parentheses may be dropped for readability.
Input arguments must evaluate to a value that matches the declared type.
Output arguments must evaluate to a memory location that the callee can read from and write to.
If the callee is an activity that eventually terminates and declares a return value, this return value must be either received into some variable or ignored using a wildcard. The receiving variable is either a mutable variable declared earlier or can be declared inside the &lt;code&gt;run&lt;/code&gt; statement. In this case it can also be declared as a read-only variable using &lt;code&gt;let&lt;/code&gt;. The receiver may be used in the code sequentially after the &lt;code&gt;run&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;When control flow reaches a &lt;code&gt;run&lt;/code&gt; statement the sub-activity is immediately called and the control flow is handed over to the callee.
It remains within the callee for as many reactions as it runs (but at least one reaction).
In every reaction inputs are passed though to the callee and its outputs are propagated outside.
Should the callee terminate, the control flow returns to the caller and proceeds with the next statement.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;// declaration
activity A (a: [8]int32, b: int32) (c: int32) returns bool
    /* some code */
    ...
end

    /* ... inside another activity ... */
    var result: bool
    var array: [8]int32 = {1, 2, 3, 4, 5, 6, 7, 8}
    var output: int32
    // usage
    run result = A(array, 7)(output)

    // alternative: declare receiver within &amp;#34;run&amp;#34;
    run let result2 = A(array, 7)(output)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;cobegin&#34;&gt;Cobegin&lt;/h3&gt;
&lt;p&gt;Concurrent composition is expressed with the &lt;code&gt;cobegin&lt;/code&gt; statement.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ForkJoin&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;cobegin&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;weak&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;with&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;weak&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+ &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Using &lt;code&gt;cobegin&lt;/code&gt; it is possible to compose arbitrary pieces of code.
The goal is not to parallelise to gain execution speed.
Rather this the language construct to express that two (or more) functionalities should be computed within the same reaction.
As such concurrency is rather a modelling concept in Blech.
The code generator will actually sequentialise the code in a causally correct order.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    In the future there will be the possibility to specify truly parallel executions in Blech which can be carried out independently.

&lt;/div&gt;

&lt;h4 id=&#34;example-concurrent-composition&#34;&gt;Example: Concurrent composition&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity P ()
    var x: int32
    var y: int32
    var z: int32
    cobegin
        run A(x)(z)
    with
        run B(y)(x)
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Assume the activities &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; have already been implemented.
In lines 5 &amp;ndash; 9 they are composed concurrently.
This means the control flow of &lt;code&gt;P&lt;/code&gt; is forked into two control flow points.
One resides in &lt;code&gt;A&lt;/code&gt; (line 6) and one in &lt;code&gt;B&lt;/code&gt; (line 8).
With every tick both, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, will perform one reaction.
When both subprograms terminate, &lt;code&gt;P&lt;/code&gt; regains control in line 9 and, in this example, terminates too.
Of course, more than two branches can be combined using more &lt;code&gt;with&lt;/code&gt; branches.
Note that the reaction of &lt;code&gt;B&lt;/code&gt; will be carried out before the reaction of &lt;code&gt;A&lt;/code&gt; due to causality:
First the unique value of &lt;code&gt;x&lt;/code&gt; needs to be set by writer &lt;code&gt;B&lt;/code&gt; before the reader &lt;code&gt;A&lt;/code&gt; may use it.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;cobegin&lt;/code&gt; statement is a composite statement like a &lt;code&gt;repeat&lt;/code&gt; loop or an &lt;code&gt;if&lt;/code&gt; statement.
Control flow can remain within the &lt;code&gt;cobegin&lt;/code&gt; branches for multiple reactions.
However in general the various branches can perform a different number of reactions, possibly infinitely many.
We therefore need to control the termination of &lt;code&gt;cobegin&lt;/code&gt; as a whole using the &lt;code&gt;weak&lt;/code&gt; qualifiers.&lt;/p&gt;
&lt;p&gt;Formally, a &lt;code&gt;cobegin&lt;/code&gt; statement terminates in the reaction in which all strong branches have terminated.
If all branches are weak, the &lt;code&gt;cobegin&lt;/code&gt; statement terminates in the reaction in which some branch terminates.&lt;/p&gt;
&lt;p&gt;In the above example no branch is &lt;code&gt;weak&lt;/code&gt;.
We say all branches are &amp;ldquo;strong&amp;rdquo;.
This means the &lt;code&gt;cobegin&lt;/code&gt; statement terminates when &lt;em&gt;all&lt;/em&gt; of its branches have terminated.
Branches that finish earlier (have fewer reaction to do) will simply do nothing until the last strong branch has terminated.
The following two examples illustrate the usage of the &lt;code&gt;weak&lt;/code&gt; qualifier.&lt;/p&gt;
&lt;h4 id=&#34;example-weak-and-strong-branches&#34;&gt;Example: Weak and strong branches&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;/* ... inside some activity ... */
var res: nat8
cobegin weak
    // non-terminating branch
    repeat
        await true
        out1 = (out1 + 1) % 100
    end
with
    // terminates once a key is pressed
    res = run ReadKeyStroke()
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The first branch contains an infinite loop in the sense that every iteration ends in a pause but the number of reactions is unbounded.
The loop is placed into a weak branch that allows to terminate the loop at the end of some reaction.
The second branch contains an activity call that is expected to return some value eventually.
In the reaction in which the result is returned the weak branch will be aborted (after it has done one iteration) and the control flow continues with the next statement following the &lt;code&gt;cobegin&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;example-all-branches-weak&#34;&gt;Example: All branches weak&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;cobegin weak
    await isButtonPressed
with weak
    await hasReceivedSignal
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this example there are no strong branches.
The first branch to terminate will abort all others.
In this example it means as soon as &lt;code&gt;isButtonPressed&lt;/code&gt; or &lt;code&gt;hasReceivedSignal&lt;/code&gt; is true (or both are true!) the &lt;code&gt;cobegin&lt;/code&gt; statement terminates and control flow continues with the next statement.&lt;/p&gt;
&lt;h3 id=&#34;prev&#34;&gt;Prev&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;prev&lt;/code&gt; is not a statement but a special operator which is most useful in the context of a &lt;code&gt;cobegin&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;The introductory chapter explained &lt;a href=&#34;../moc/#causality&#34;&gt;causality&lt;/a&gt;
.
In short, this means two concurrent branches may not write the same shared memory and furthermore cyclical read-write dependencies are prohibited as well.
Sometimes however we need to express a quasi-cycle wherein one branch starts off with a value that has already been computed in the previous reaction. This is conveniently expressed using the &lt;code&gt;prev&lt;/code&gt; operator.&lt;/p&gt;
&lt;h4 id=&#34;example-previous-values&#34;&gt;Example: Previous values&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;cobegin 
    run A (prev x)(y)
with 
    run B (y)(x)
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here, in every reaction, the &lt;em&gt;previous&lt;/em&gt; value of &lt;code&gt;x&lt;/code&gt;, i.e. the result of the previous reaction, is given to &lt;code&gt;A&lt;/code&gt; which performs a step and produces a new value for &lt;code&gt;y&lt;/code&gt;. This is then used by &lt;code&gt;B&lt;/code&gt; to produce a new &lt;em&gt;current&lt;/em&gt; value of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prev&lt;/code&gt; can only be used where we expect to read a value. It cannot be used on a left-hand-side of an assignment or in an output argument position. &lt;code&gt;prev&lt;/code&gt; may only be applied to values, identified by a name. It cannot be used on arbitrary expressions.
When used on memory of complex data types, &lt;code&gt;prev&lt;/code&gt; binds to the outermost part. For a structure &lt;code&gt;s&lt;/code&gt; the expression &lt;code&gt;prev s.x&lt;/code&gt; is to be read as &lt;code&gt;(prev s).x&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;abort-and-reset&#34;&gt;Abort and reset&lt;/h3&gt;
&lt;p&gt;There are two kinds of synchronous preemptions built into Blech.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Preemption&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;when&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;abort&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;reset&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When control flow enters a preemption the statements in its body, denoted by &lt;code&gt;StmtBlock&lt;/code&gt; in the grammar, are executed until the reaction ends in an &lt;code&gt;await&lt;/code&gt; or &lt;code&gt;run&lt;/code&gt; statement.
Subsequently, when a reaction resumes execution inside the body, first the &lt;code&gt;when&lt;/code&gt; condition is checked.
If it is false, the execution starts as usual.
Otherwise the body is preempted &lt;em&gt;before&lt;/em&gt; any statement is executed or expression is evaluated inside the body.
There are two variants of preemptions.
&lt;code&gt;abort&lt;/code&gt; means that control flow jumps to the &lt;code&gt;end&lt;/code&gt; of the preemption statement.
&lt;code&gt;reset&lt;/code&gt; means that control flow restarts at the beginning of &lt;code&gt;StmtBlock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;when Condition reset P end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;is syntactic sugar for&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;var hasTerminated = false
repeat
    when Condition abort
        P
        hasTerminated = true
    end
until hasTerminated end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;where &lt;code&gt;hasTerminated&lt;/code&gt; is a fresh boolean variable.&lt;/p&gt;
&lt;p&gt;It is, of course, possible that the body is left instantaneously within one reaction.
In this case the preemption is irrelevant for the flow of control.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;

    The preemption condition is &lt;em&gt;not&lt;/em&gt; checked when the control flow enters the body.
The &lt;code&gt;when&lt;/code&gt; condition is only checked when control flow resumes from within the body.
Wrap the preemption inside an &lt;code&gt;if&lt;/code&gt; statement in case you want to check the condition before entering the body.

&lt;/div&gt;

&lt;h4 id=&#34;example-abort-and-reset&#34;&gt;Example: Abort and Reset&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity A (in1: bool) (out1: uint8)
    // do something ...
    
    when in1 abort
        out1 = 1
        await true
        out1 = 2
        await true
        out1 = 3
    end
    
    // do something else ...
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The statement in line 4 says that &lt;code&gt;when&lt;/code&gt; a reaction &lt;em&gt;starts&lt;/em&gt; in the block lines 5 &amp;ndash; 9, it is checked whether &lt;code&gt;in1&lt;/code&gt; is true and in that case the control flow skips to line 10.
Thus when control flow reaches line 4 it will immediately proceed to line 5, set &lt;code&gt;out1&lt;/code&gt; accordingly and finish this reaction in line 6 (regardless of the value of &lt;code&gt;in1&lt;/code&gt;).
The next reaction starts by checking the abort condition &lt;code&gt;in1&lt;/code&gt;.
If it is true we skip the rest of the block and proceed to line 10.
Otherwise, we check the condition of the &lt;code&gt;await&lt;/code&gt; statement which here is vacuously true and the reaction proceeds to line 7 and finishes in line 8.
The same reasoning applies in line 8: the execution is possibly aborted before setting &lt;code&gt;out1&lt;/code&gt; to 3.
In any case, the block is left in line 10.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;abort&lt;/code&gt; statement is useful whenever we want to skip over a sequence of reactions when we detect some issue at the beginning of a reaction.
Sometimes instead of skipping ahead we would like to restart a sequence of reactions.
For this we may use the &lt;code&gt;reset&lt;/code&gt; statement.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;activity MyAct (in1: bool) (out1: uint8)
    // do something ...
    
    when in1 reset // reset instead of abort
        out1 = 1
        await true
        out1 = 2
        await true
        out1 = 3
    end
    
    // do something else ...
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It behaves just like the &lt;code&gt;abort&lt;/code&gt; statement except it jumps to line 4 if &lt;code&gt;in1&lt;/code&gt; is true.&lt;/p&gt;
&lt;h2 id=&#34;imperative-control-flow&#34;&gt;Imperative control flow&lt;/h2&gt;
&lt;p&gt;All of the following statements are known from mainstream imperative programming languages.
They may be used inside both, activities and functions.&lt;/p&gt;
&lt;h3 id=&#34;assignment&#34;&gt;Assignment&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Assignment&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsExpr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;do-block&#34;&gt;Do block&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;DoBlock&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;do&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;do&lt;/code&gt; block may be used to define local scopes.&lt;/p&gt;
&lt;h4 id=&#34;example-local-scopes&#34;&gt;Example: Local scopes&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;function f ()
    do
        var x: int8 = 5
    end
    // x is out of scope here
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;if&#34;&gt;If&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;IfStmt&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;if&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;then&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;elseif&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;then&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;else&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;while&#34;&gt;While&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;WhileLoop&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;while&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;repeat&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When using a loop in an activity, there must be some pause on every control flow path through the loop body.
This is not necessary for loops inside functions.
Note that using &lt;code&gt;while&lt;/code&gt; loops in activities may lead to unexpected error messages because we deliberately &lt;em&gt;do not&lt;/em&gt; evaluate the condition at compile time even if it is trivially true or false.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;activity Toggle()(out:bool)
    while true repeat
        out = not out
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This program will not compile because the compiler thinks there is a control flow path that does not enter the loop and immediately terminates the activity.
Since activities must not be instantaneous this program is rejected.
Use &lt;code&gt;repeat&lt;/code&gt; loops instead to avoid this spurious control flow paths that possibly skip the loop.&lt;/p&gt;
&lt;h3 id=&#34;repeat&#34;&gt;Repeat&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;RepeatLoop&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;repeat&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;until&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;repeat&lt;/code&gt; loops guarantee that control flow does enter the loop body at least once.
Endless loops (without the &lt;code&gt;until&lt;/code&gt; condition) may only be used in activities.
Again, when using a loop in an activity, there must be some pause on every control flow path through the loop body.
This is not necessary for loops inside functions.&lt;/p&gt;
&lt;h3 id=&#34;return&#34;&gt;Return&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ReturnStmt&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;return&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;return&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ActivityCall&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Void activities and functions can use &lt;code&gt;return&lt;/code&gt; without an expression to terminate at some point before control flow reaches the last statement.&lt;/p&gt;
&lt;h4 id=&#34;example-return-from-void-function&#34;&gt;Example: Return from void function&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;function setSpeed (velocity: float32) ()
    if velocity &amp;lt; 0 then
        return
    end

    if not isMotorReady() then
        return
    end
    
    halSetSpeed(velocity) // call device driver
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This simple example assumes we implement a wrapper for calling a hardware device driver.
In order to avoid an if-then-else cascade &lt;code&gt;setSpeed&lt;/code&gt; tests the prerequisites individually and returns in case some of them is not met.&lt;/p&gt;
&lt;p&gt;Activities and functions that declare a return type must return a value of this type on every control flow path that reaches the end of the program body.&lt;/p&gt;
&lt;p&gt;Activities may only return from their main thread.
In other words &lt;code&gt;return&lt;/code&gt; must not occur inside a branch of a &lt;code&gt;cobegin&lt;/code&gt; statement.
This is a design decision which avoids cases in which multiple branches could return a value and it is not clear which one &amp;ldquo;wins&amp;rdquo; the race. Furthermore, even if only one branch could return, it still would not be clear whether concurrent branches will execute their reactions entirely or not. For the sake of a clear and easy to understand semantics the above restriction is enforced.&lt;/p&gt;
&lt;p&gt;Mind the difference between activity return values and activity output values.
Outputs are set in every reaction of the activity.
A return value is returned precisely once in the reaction that terminates the activity.&lt;/p&gt;
&lt;h4 id=&#34;example-return-from-activity&#34;&gt;Example: Return from activity&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;activity A (in: int32) (out: int32) returns nat8
    var retcode: nat8
    var x: int32
    cobegin weak
        run B(in)(x)
    with
        retcode = run C(x)(out)
    end
    return retcode
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In every reaction &lt;code&gt;in&lt;/code&gt; is propagated to &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; is propagated from &lt;code&gt;C&lt;/code&gt; to the caller.
Only when &lt;code&gt;C&lt;/code&gt; terminates the variable &lt;code&gt;retcode&lt;/code&gt; is updated, the &lt;code&gt;cobegin&lt;/code&gt; statement is terminated and the &lt;code&gt;retcode&lt;/code&gt; is returned to the caller.&lt;/p&gt;
&lt;p&gt;Activities that simply terminate and pass on the value of their callee may use the syntactic sugar&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;return run A()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;instead of the more verbose&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;run let foo = A()
return foo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;function-call&#34;&gt;Function call&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;FunctionCallStmt&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Blech distinguishes between a function call statement and a function call expression.
On the statement level only void functions may be called.&lt;/p&gt;
&lt;p&gt;In summary, a block of statements in Blech is given by the following grammar.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; 
      &lt;span style=&#34;color:#000&#34;&gt;Pause&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;ActivityCall&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;ForkJoin&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Preemption&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Assignment&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;DoBlock&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;IfStmt&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;WhileLoop&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;RepeatLoop&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;ReturnStmt&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;FunctionCallStmt&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Depending on whether statements are used in an activity or a function their use may be restricted or prohibited (see above).
The optional semicolons in the grammar indicate that it is possible to separate statements in a sequence using semicolons.
We suggest to avoid writing any semicolons unless two (or more) statements are written in one line.&lt;/p&gt;
&lt;h3 id=&#34;semicolons-in-blech&#34;&gt;Semicolons in Blech&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;function f()
    var x: int8 = 0; // do not clutter your code with superfluous &amp;#34;;&amp;#34;
    var y: int8 = 1  // preferred semicolon free style

    x = 7; y = y + x // ok, but usually it is better to write two lines
    x = 7 y = y + x  // compiles but is hardly readable, do not do that
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Declarations</title>
      <link>https://www.blech-lang.org/docs/user-manual/declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/declarations/</guid>
      <description>
        
        
        &lt;p&gt;Declarations introduce new names for entities in the program.
Declarable entities include&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activities&lt;/li&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;types&lt;/li&gt;
&lt;li&gt;data storage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the future more of such entities may be added to the language such as clocks and physical units.&lt;/p&gt;
&lt;p&gt;Every declaration exists in a &lt;em&gt;lexical scope&lt;/em&gt;.
Scopes define the visibility of a name.
The top-level or file scope is the most global scope in Blech.
Functions, activities and types are defined here.
Entities in the top-level scope are visible everywhere in the file.
Every block introduces a sub-scope.
For example, a function body is a local scope.
Variables defined in this scope are visible in this function but not outside of it.
Composite statements, such as the &lt;code&gt;repeat&lt;/code&gt; loop introduce their statement-local scope. This allows to introduce a variable that is visible during the iteration through this loop and not outside of it.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    Once we implement a module system for Blech, the mechanisms for controlling visibility will need to be elaborated in more detail.

&lt;/div&gt;

&lt;p&gt;In Blech, declarations not only introduce a name but also &lt;em&gt;define&lt;/em&gt; what this name represents. For example, a function declaration will specify a function body.
That is the block of statements that are executed when this functions is called.
The definition may refer to names that were previously declared.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;

    Declare before use! Even if, for example, functions are defined on the same scope, a function can only call other functions that have been declared before.

&lt;/div&gt;

&lt;p&gt;In the following we discuss the various entities that can be defined in a Blech program.&lt;/p&gt;
&lt;h2 id=&#34;data&#34;&gt;Data&lt;/h2&gt;
&lt;p&gt;Data declarations consist of an access and placement qualifier, an identifier, a data type and an initialisation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;DataDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Init&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A variable declaration:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;var x: int32 = 17
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The type is either a built-in type or a name of a user defined type.
Built-in types are discussed in the &lt;a href=&#34;../types&#34;&gt;Types chapter&lt;/a&gt;
.
Type declarations are discussed &lt;a href=&#34;#user-defined-types&#34;&gt;below&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Initialisers are expressions that evaluate to a value that matches this declaration&amp;rsquo;s data type. Expressions (including literals) are discussed in the &lt;a href=&#34;../expressions&#34;&gt;Expressions chapter&lt;/a&gt;
.&lt;/p&gt;
&lt;h3 id=&#34;qualifiers&#34;&gt;Qualifiers&lt;/h3&gt;
&lt;p&gt;There are four possible qualifiers.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;const&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;param&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;let&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;var&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt; qualified data is relevant for the compilation phase only and does not have any representation in memory at run time. 
Typical use cases for &lt;code&gt;const&lt;/code&gt; are sizes of data structures, addresses in memory, &amp;hellip; 
In C, these are represented by &lt;code&gt;#define&lt;/code&gt; macros, which, too, have no representation after the preprocessor finishes.
Hence &lt;em&gt;using const on arrays (or structs containing arrays), albeit possible, is not advisable&lt;/em&gt; and produces inefficient code because temporary variables have to be created (and filled) at runtime for every (non-constant) access to these arrays.
Instead consider &lt;code&gt;param&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;param&lt;/code&gt; qualified data has a representation in memory at run time but cannot be changed by the running program for its entire lifetime (it can only be reflashed).
Typical use cases for &lt;code&gt;param&lt;/code&gt; are characteristics maps or other immutable lookup data structures.
The name &amp;ldquo;param&amp;rdquo; indicates that such data is a parameter of the final compilation result.
Tools exist to customise such parameters in a binary file directly in order to adapt the given software to a variant of a product.
Like with &lt;code&gt;const&lt;/code&gt; data, the &lt;code&gt;param&lt;/code&gt; value must be initialised with constant expressions.
You cannot write the following&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;function f (input: int32)
   param x: int32 = input // error!
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is because the value of &lt;code&gt;input&lt;/code&gt; is determined at &lt;em&gt;runtime&lt;/em&gt; but &lt;code&gt;x&lt;/code&gt; must be initialised at &lt;em&gt;compile time&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt; and &lt;code&gt;param&lt;/code&gt; data may be declared at top level as well as inside functions or activities.
The other two qualifiers &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; indicate local data and may &lt;em&gt;only&lt;/em&gt; be used inside functions or activities.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; declares immutable data in the control flow of a program.
Finally, &lt;code&gt;var&lt;/code&gt; declares the usual mutable variable.
Initialisation may be omitted for mutable variables. In this case the Blech compiler will automatically initialise the variable with its type&amp;rsquo;s default value.
The type annotation may be omitted if the type can be unambiguously determined from the initialisation expression.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;const LEN: int32 = 8
param lut: [LEN]float64 = {1.0, 0.5, 0.25, 0.125} // LEN is constant and may be used here
                                                  // the array literal will be filled with additional 0&amp;#39;s up to length LEN.
function f()
    let i = LEN - 7 // i is deduced to be int32
    var x = lut[i] // x is deduced to be float64
                   // and equals 0.5 in this case
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    No global variables in Blech!
We deliberately prohibit the use of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; outside subprogram scopes because we believe this leads to better understandable, easier to integrate and unit-testable programs.

&lt;/div&gt;



&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;

    Confusion may arise about the difference between &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;.
They both qualify immutable data in memory.
They could be even stored in the same way which however is a compiler implementation detail and none of the concerns of the programmer.
The crucial difference is that &lt;code&gt;let&lt;/code&gt; takes values at runtime.
It is immutable throughout the scope where it has been declared.
Once the scope is left and re-entered, the value of that &lt;code&gt;let&lt;/code&gt; variable may be re-initialised. (In the literature this is sometimes dramatically referred to as &amp;ldquo;re-incarnation&amp;rdquo;.)
As stated above, &lt;code&gt;param&lt;/code&gt; data cannot be changed by the running program at all, it is completely static.

&lt;/div&gt;



&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;

    The word &amp;ldquo;parameter&amp;rdquo; appears in two notions. One is the &amp;ldquo;formal parameter&amp;rdquo; of a function or activity.
The other is the &amp;ldquo;param&amp;rdquo; qualifier for immutable data.
The first parametrises a function (ar activity), the second parametrises a whole binary.
We try to make clear which one we mean throughout this document. Usually it should be apparent from context however.

&lt;/div&gt;

&lt;h2 id=&#34;user-defined-types&#34;&gt;User defined types&lt;/h2&gt;
&lt;p&gt;The programmer may define a data structure using the &lt;code&gt;struct&lt;/code&gt; keyword.
See the chapter on &lt;a href=&#34;../types/#structure-types&#34;&gt;struct types&lt;/a&gt;
 for more details.


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;

    As the implementation of the compiler progresses there will be more user definable types.

&lt;/div&gt;
&lt;/p&gt;
&lt;h2 id=&#34;subprograms&#34;&gt;Subprograms&lt;/h2&gt;
&lt;p&gt;Blech discerns two type of subprograms: &lt;code&gt;activity&lt;/code&gt; and &lt;code&gt;function&lt;/code&gt;.
Their behaviour is different. Activities must pause at least once whereas functions need to terminate within one reaction. Functions are therefore called &amp;ldquo;instantaneous&amp;rdquo;.
The precise differences will be worked out in the chapter on Blech statements.
From a syntactic declaration point of view there is hardly any difference.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ProgramDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;singleton&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ProgramType&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;returns&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ProgramType&lt;/span&gt;        ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;function&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;activity&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;          ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;()&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt;   ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There are two parameter lists. 
The first lists declares formal parameters that may only be read (like &lt;code&gt;let&lt;/code&gt; variables), the second list declares formal parameters that may be both read and written (like &lt;code&gt;var&lt;/code&gt; variables).
In particular the two lists are useful for activities which, in every reaction, receive a list of read-only &lt;em&gt;inputs&lt;/em&gt;, perform some calculation and set the list of read-write &lt;em&gt;outputs&lt;/em&gt;.
We will therefore often refer to these two parameter lists as &amp;ldquo;input list&amp;rdquo; and &amp;ldquo;output list&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;The programming model is that all variables are passed by reference (even though in reality the compiler will optimise this into by-value for simple value typed inputs).&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;function add (x: int32, y: int32) returns int32
   return x + y
end

@[EntryPoint]
activity A (in: int32)(out: int32)
   repeat
      out = add(in, out)
      await true
   end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The example above is a valid Blech program that sums all inputs over all time steps.
Note that &lt;code&gt;add&lt;/code&gt; omits an output list and &lt;code&gt;A&lt;/code&gt; does not declare any return type.
We call functions or activities that do not return anything &amp;ldquo;void&amp;rdquo; but unlike C we do not have a void type in the language.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;@[EntryPoint]&lt;/code&gt; annotation tells the compiler that &lt;code&gt;A&lt;/code&gt; is the main program. Every Blech program must have precisely one entry point activity. 
Note however, that a Blech program may consist of several files, one program file and several (sub-)modules. See the &lt;a href=&#34;../modules/#compilation-units&#34;&gt;modules chapter&lt;/a&gt;
 for details.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;singleton&lt;/code&gt; keyword is optional and may be used to indicate that there may exist only one instance of this subprogram in a concurrent context. 
For example, this is useful to indicate early on in the development phase that an activity will have some interaction with the external environment.
The caller of a singleton callee automatically becomes a singleton, too.&lt;/p&gt;
&lt;h2 id=&#34;external-declarations&#34;&gt;External Declarations&lt;/h2&gt;
&lt;p&gt;Sometimes it is useful to access global variables or functions of a C program.
This allows for example to make use of existing libraries.
Such variables and functions are &lt;em&gt;external&lt;/em&gt; from the point of view of a Blech program.
Annotations are required to tell the compiler how to code-generate access to these external entities.&lt;/p&gt;
&lt;p&gt;Formally, we have the following syntax.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ExternFunctionDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;extern&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;singleton&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;function&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;returns&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ExternDataDeclaration&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;extern&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Obviously, external functions have no body and external variables cannot be initialised.
As before, external functions may be characterised as &lt;code&gt;singleton&lt;/code&gt; which means such a function may not be called concurrently with another instance of itself. This is useful when the external function to be called is not a pure function because it either returns a volatile value or has some effect on the environment. Invoking multiple instances of such a function concurrently would violate the synchrony assumptions and lead to unexpected results.&lt;/p&gt;
&lt;p&gt;External declarations additionally require annotations which we introduce by example below.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;

    Note that the type-safety and causality guarantees of Blech vanish once you interact with an external C implementation. That means the Blech compiler relies on the assumption that the specified annotations and interfaces are correct. We&amp;rsquo;ll point out a few caveats below.

&lt;/div&gt;

&lt;h3 id=&#34;external-constants&#34;&gt;External constants&lt;/h3&gt;
&lt;p&gt;In C, constant values may be defined using macros or &lt;code&gt;const&lt;/code&gt; variables.
In order to make these values available in Blech, external constants may be declared.
External constant declarations may appear in any scope.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;@[CConst (binding = &amp;#34;PI&amp;#34;, header = &amp;#34;math.h&amp;#34;)]
extern const pi: float64
@[CParam (binding = &amp;#34;characteristics&amp;#34;, header = &amp;#34;magic.h&amp;#34;)]
extern param map: [10]float32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Both Blech qualifiers &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;param&lt;/code&gt; are supported.
They require a &lt;code&gt;CConst&lt;/code&gt; or a &lt;code&gt;CParam&lt;/code&gt; annotation respectively.
However they have more of a documentation character rather than any functional difference.
Both will evaluate whatever expression is given in the binding at runtime.
This is the reason why external constants cannot be used for constant expression evaluation in Blech &amp;ndash; their value is unknown at compile time.
While you can, for example, use a Blech constant to parametrise an array length, you cannot do so using an external constant.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;binding&lt;/code&gt; annotation attribute may contain any string which is a valid right hand side of a C macro. See &lt;a href=&#34;#binding-strings&#34;&gt;below&lt;/a&gt;
 for more details.&lt;/p&gt;
&lt;p&gt;By design, the Blech compiler generates C code that links with other C code but at no point in time does the Blech compiler &amp;ldquo;look into&amp;rdquo; C header or implementation files, nor does it try to evaluate any C-bindings.&lt;/p&gt;
&lt;h3 id=&#34;local-external-variables&#34;&gt;Local external variables&lt;/h3&gt;
&lt;p&gt;The aforementioned constants may be declared in local scopes as well.
Additionally, local Blech variables that link to external global variables may be declared inside activities (but not in functions).&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;

    There is no semantical reason why external variables cannot be declared inside functions. It is simply due to compiler implementation pragmatics that we exclude this possibility as of now.

&lt;/div&gt;

&lt;p&gt;Access to external variables is useful to keep interfaces slim. That is you do not need to pass all data into the entry point activity and down the call chain to the piece of code that actually needs this data and then propagate the results back up this chain to the entry point to communicate the updated values to the environment.
These variables follow the same rules as the usual activity-local variables.&lt;/p&gt;
&lt;p&gt;Read-only external variables are annotated with the &lt;code&gt;CInput&lt;/code&gt; annotation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;@[CInput (binding = &amp;#34;PIN_7&amp;#34;, header = &amp;#34;head.h&amp;#34;)]
extern let isButtonPressed: bool
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This example assumes there is either a C macro or a C variable &lt;code&gt;PIN_7&lt;/code&gt; that returns a volatile boolean value indicating a button press.&lt;/p&gt;
&lt;p&gt;The declaration creates a local variable inside the enclosing activity.
It serves as a copy-in buffer.
When the activity starts a reaction the value of &lt;code&gt;PIN_7&lt;/code&gt; is copied into &lt;code&gt;isButtonPressed&lt;/code&gt;.
Within the Blech program we can only access the buffer &lt;code&gt;isButtonPressed&lt;/code&gt; and thereby have the guarantee that the value does not change during the reaction.
This corresponds to the semantics of activity input parameters.&lt;/p&gt;
&lt;p&gt;An activity that declares an immutable external variable does not become a singleton.
Concurrent instances may exist but they may contain different values for the same external variable if it is volatile.&lt;/p&gt;
&lt;p&gt;Read-write external variables are annotated with the &lt;code&gt;COutput&lt;/code&gt; annotation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;@[COutput (binding = &amp;#34;PIN_7&amp;#34;, header = &amp;#34;head.h&amp;#34;)]
extern var isButtonPressed: bool
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here at the beginning of a reaction the value of &lt;code&gt;PIN_7&lt;/code&gt; is copied in.
During a reaction the variable &lt;code&gt;isButtonPressed&lt;/code&gt; can be modified as usual.
At the end of the reaction the value of &lt;code&gt;isButtonPressed&lt;/code&gt; is copied out to &lt;code&gt;PIN_7&lt;/code&gt;.
This guarantees a stable output behaviour. Intermediate changes to the local variable &lt;code&gt;isButtonPressed&lt;/code&gt; are not observable by the environment.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;prev&lt;/code&gt; operator may be used on external variables.
It returns the value that the variable held at the end of the previous reaction.
This behaviour corresponds to using &lt;code&gt;prev&lt;/code&gt; on normal local variables but there is a subtle difference.
External variables may be changed by the environment.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;@[COutput (binding = &amp;#34;PIN_7&amp;#34;, header = &amp;#34;head.h&amp;#34;)]
extern var isButtonPressed: bool
isButtonPressed = true
await cond // some boolean condition
var x = prev isButtonPressed // is x == true?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If &lt;code&gt;cond&lt;/code&gt; is true immediately in the next reaction then x will be set to &lt;code&gt;true&lt;/code&gt;.
In general, however we do not know how many reaction it will take until &lt;code&gt;cond&lt;/code&gt; becomes true.
Yet in every reaction the copy-in and copy-out mechanisms will update the &lt;code&gt;isButtonPressed&lt;/code&gt; buffer.
If the environment does not change &lt;code&gt;PIN_7&lt;/code&gt; then surely &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;true&lt;/code&gt;.
But, in general, we cannot assume this.&lt;/p&gt;
&lt;p&gt;An activity that declares a mutable external variable automatically becomes a singleton.
Concurrent instances lead to a write-write conflict and compilation is rejected.&lt;/p&gt;
&lt;h3 id=&#34;external-functions&#34;&gt;External functions&lt;/h3&gt;
&lt;p&gt;There are two ways to link to external functions in Blech.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Via direct binding a to function name declared in an .h file&lt;/li&gt;
&lt;li&gt;Via a wrapper to be implemented in some .c file.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the first case we annotate the call to the C function and the file wherein this function is declared. The call must list the parameters using a &lt;code&gt;$i&lt;/code&gt; notation. In this way, we can map the input and output parameters of the Blech prototype to the positions of the C function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;@[CFunction (binding = &amp;#34;ceil($1)&amp;#34;, header = &amp;#34;math.h&amp;#34;)]
extern function ceiling(i: float64) returns float64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Inside the Blech program this function is now available through name &lt;code&gt;ceiling&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the second case we annotate which file we intend to implement the C function in.
Actually this information is irrelevant for the Blech compilation itself.
However, it may become useful in the future once a build system can make sense of these annotations and automatically detect which files are required for the compilation of the whole project.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;@[CFunction (source=&amp;#34;impl.c&amp;#34;)]
extern function myCFunction(i: float64) returns float64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Assume the above declaration is written in a Blech file called &lt;code&gt;MyFile.blc&lt;/code&gt;, then the code generator will produce a header file &lt;code&gt;MyFile.h&lt;/code&gt; with the following code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// extern functions to be implemented in C
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;blc_float64&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_MyFile_myCFunction&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_float64&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is up to the C programmer now to include this header in his implementation file &lt;code&gt;impl.c&lt;/code&gt; and provide an actual definition of this function.&lt;/p&gt;
&lt;h3 id=&#34;remarks-on-caveats-when-interfacing-with-c&#34;&gt;Remarks on caveats when interfacing with C&lt;/h3&gt;
&lt;h4 id=&#34;types&#34;&gt;Types&lt;/h4&gt;
&lt;p&gt;Blech has no representation of C types. It requires that the C implementation matches the Blech types. This is usually straightforward for simple types. If there is no one-to-one correspondence between types then a wrapper has to be implemented in C that marshals the data between Blech and the actual C function to be called.&lt;/p&gt;
&lt;h4 id=&#34;parameter-lists&#34;&gt;Parameter lists&lt;/h4&gt;
&lt;p&gt;In Blech, functions have two parameter lists as explained above. 
The Blech compiler ensures that inputs will only be read. 
However the Blech compiler has no chance to check that the external code adheres to this contract.&lt;/p&gt;
&lt;p&gt;For example, say we have an external function that takes an array of length 10 and sorts it in-place.
The correct binding would look something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;@[CFunction (binding = &amp;#34;sort($1)&amp;#34;, header = &amp;#34;utils.h&amp;#34;)]
extern function sort()(arr: [10]int32)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this way, the Blech compiler knows that &lt;code&gt;sort&lt;/code&gt; will modify the given array. When calling this function in a concurrent context the compiler will prevent write-write conflicts and read-write cycles on the array.&lt;/p&gt;
&lt;p&gt;However, the programmer could erroneously declare the same function as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;@[CFunction (binding = &amp;#34;sort($1)&amp;#34;, header = &amp;#34;utils.h&amp;#34;)]
extern function sort(arr: [10]int32)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The code will compile all the same but the causality guarantees are gone because the Blech compiler relies on the assumption that the array will only be read and not modified. At runtime the program may then exhibit unexpected behaviour.&lt;/p&gt;
&lt;h4 id=&#34;singletons&#34;&gt;Singletons&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;singleton&lt;/code&gt; annotation is a help to the Blech programmer but does not completely prevent concurrent calls to functions with conflicting effects. For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;@[CFunction (binding = &amp;#34;foo&amp;#34;, header = &amp;#34;head.h&amp;#34;)]
extern singleton function doA() 
@[CFunction (binding = &amp;#34;foo&amp;#34;, header = &amp;#34;head.h&amp;#34;)]
extern singleton function doB() 

/* ... somewhere in an activity scope ... */
cobegin
   doA()
with
   doB()
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This example is a valid Blech program because two different singleton functions are called. This is allowed. However the annotation points to the same C function which is obviously a problem. While a linter could in principle check for this &lt;em&gt;particular&lt;/em&gt; mistake there are many more possibilities to specify bindings to functions which will have conflicting effects when called concurrently.
It is up to the programmer to know what are the effects of the external functions to be called and to avoid scenarios such as the one above.&lt;/p&gt;
&lt;h4 id=&#34;binding-strings&#34;&gt;Binding strings&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;binding&lt;/code&gt; part of an annotation may contain any C code which is a valid right hand side of a macro definition.
The binding may be given as a single-line string (enclosed in &lt;code&gt;&amp;quot;&lt;/code&gt;) or as a multi-line string (enclosed in &lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;).
When indenting multi-line strings make sure the indentation is consistent for all lines of the string. This means a two line string where the first line is indented by four spaces and a tab and the second line is indented by a tab and four spaces may &lt;em&gt;look&lt;/em&gt; indented properly in your editor but the compiler will complain about being unable to determine the correct indentation. If you use any tabs at all, make sure all tabs appear before any other character (including whitespace) in every line.
Strings may contain escape sequences &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\v&lt;/code&gt;, &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\&#39;&lt;/code&gt;, &lt;code&gt;\&amp;quot;&lt;/code&gt;.
Furthermore unicode characters may be used given by &lt;code&gt;\u{codepoint}&lt;/code&gt; where &lt;code&gt;codepoint&lt;/code&gt; is a hexadecimal number.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Types</title>
      <link>https://www.blech-lang.org/docs/user-manual/types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/types/</guid>
      <description>
        
        
        &lt;p&gt;A &lt;em&gt;type&lt;/em&gt; defines a &lt;em&gt;domain&lt;/em&gt; &amp;ndash; a set of &lt;em&gt;values&lt;/em&gt; &amp;ndash; a &lt;em&gt;representation&lt;/em&gt; for those values and a set of &lt;em&gt;operations&lt;/em&gt; on those values.&lt;/p&gt;
&lt;p&gt;Often the domains overlap between types.
Also operations may be overloaded for multiple types.
This provides the programmer with some versatility:&lt;/p&gt;
&lt;p&gt;For example, signed integers and unsigned integers share some interval in which calculations may be carried out and interpreted as either one.
Another example is that operations such as addition may have different implementations depending on type (and machine architecture): addition of 16-bit unsigned integers on a 16-bit machine invokes a different set of machine instructions than addition of 32-bit unsigned integers on that same machine.
Yet the same symbol &lt;code&gt;+&lt;/code&gt; denotes both computations in program text.
The same operator also covers additions of numbers for a completely different domain such as floats.&lt;/p&gt;
&lt;p&gt;This versatility comes at a price: the programmer has to pay attention to value ranges, make representation changes explicit and make sure that a unique implementation of an operation (such as &lt;code&gt;+&lt;/code&gt;) can be selected by the compiler.&lt;/p&gt;
&lt;p&gt;Blech is a type safe language which assists the programmer with a powerful type checker that prevents most type related errors at compile time.
It enforces type annotations and explicit casts whenever the type of an expression is not obvious or when a representation needs to be changed before the expression fits the context of an operation.&lt;/p&gt;
&lt;p&gt;The following sections precisely describe which types exist, what their domains and representations are, which operations they define and which types may be combined or transformed into one another.&lt;/p&gt;
&lt;h2 id=&#34;boolean-type&#34;&gt;Boolean type&lt;/h2&gt;
&lt;p&gt;Blech distinguishes a &lt;code&gt;bool&lt;/code&gt; type with two values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.
Boolean values may be combined using the binary &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators.
A Boolean value is inverted by the unary &lt;code&gt;not&lt;/code&gt; operator.
All comparisons are admissible.
Expressions which evaluate to a Boolean value are called &lt;em&gt;conditions&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In Blech, it is required that conditions that determine the control flow must be side-effect free.
For example, the statements &lt;code&gt;await&lt;/code&gt;, &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;repeat..until&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt; all require side-effect free conditions.
The reason is that the evaluation of a condition should not change the program&amp;rsquo;s state.
It would contradict the synchronous semantics if a program&amp;rsquo;s state changed although no reaction was performed in case an &lt;code&gt;await&lt;/code&gt; condition evaluated to &lt;code&gt;false&lt;/code&gt;.
The same reasoning applies to other synchronous control flow statements such as &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;.
Other imperative control flow statements such as loops or the &lt;code&gt;if&lt;/code&gt; statement follow the same logic for consistency and clarity of the program text.&lt;/p&gt;
&lt;h2 id=&#34;integer-types&#34;&gt;Integer types&lt;/h2&gt;
&lt;p&gt;Integer types are divided into three categories: natural numbers, signed integer numbers and &amp;ldquo;bits&amp;rdquo;.
Each one exist in four sizes that indicate the number of bits needed in a machine to represent a value of this type: 8, 16, 32, 64.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Integer types&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nat8&lt;/code&gt;, &lt;code&gt;nat16&lt;/code&gt;, &lt;code&gt;nat32&lt;/code&gt;, &lt;code&gt;nat64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Natural numbers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Signed integer numbers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bits8&lt;/code&gt;, &lt;code&gt;bits16&lt;/code&gt;, &lt;code&gt;bits32&lt;/code&gt;, &lt;code&gt;bits64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bits&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The distinction of three integral types has the following motivation.
As usual, we would like to distinguish non-negative numbers of the length &lt;code&gt;N&lt;/code&gt; with a range of &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;2^N -1&lt;/code&gt; from integer numbers centred around 0 with a range of &lt;code&gt;2^(N-1)&lt;/code&gt; to &lt;code&gt;2^(N-1) -1&lt;/code&gt;.
However, by design, the operations on both kinds of numbers prohibit overflows.
Computations must stay within the representable domain. 
&lt;em&gt;In a future implementation an overflow either causes the program to crash or to mitigate it using saturation arithmetic depending on the build mode.&lt;/em&gt;
In order to allow writing algorithms that do rely on overflowing non-negative integers as in C, as well as bit-masking and bit-shifting the &lt;code&gt;bitsX&lt;/code&gt; type is introduced.
The bits types of length &lt;code&gt;N&lt;/code&gt; have the same value range as the natural numbers of the same length.&lt;/p&gt;
&lt;p&gt;It is possible to cast between all three types without information loss so long as the size remains unchanged.&lt;/p&gt;
&lt;p&gt;All integral types types admit all arithmetic and comparison operators.
The &lt;code&gt;bitsX&lt;/code&gt; types additionally admit bitwise operations.&lt;/p&gt;
&lt;h2 id=&#34;floating-point-types&#34;&gt;Floating-point types&lt;/h2&gt;
&lt;p&gt;Blech provides the two most commonly used floating point types &lt;code&gt;float32&lt;/code&gt; and &lt;code&gt;float64&lt;/code&gt;.
The language assumes an implementation of these according to IEEE standards.
In the generated code they are mapped to C&amp;rsquo;s &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; respectively (see section on &lt;a href=&#34;#blechconfh&#34;&gt;blechconf.h&lt;/a&gt;
 below).&lt;/p&gt;
&lt;p&gt;Note that the C standard does not guarantee an IEEE compliant implementation of its floating point types nor does it require that &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; are distinct types at all.
It is the system integrators responsibility to ensure that the C compiler at hand does fulfil Blech&amp;rsquo;s assumptions.&lt;/p&gt;
&lt;p&gt;Floating point types admit all arithmetic and comparison operators.&lt;/p&gt;
&lt;h2 id=&#34;array-types&#34;&gt;Array types&lt;/h2&gt;
&lt;p&gt;The array data type is parametrised by a fixed &amp;ldquo;shape&amp;rdquo; and a payload data type.
The shape of an array is its dimensionality and length in each dimension.
It is not possible to declare an array data type with an unspecified length.&lt;/p&gt;
&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;function f(a: [4][5]float32)
    /* ... */
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The function &lt;code&gt;f&lt;/code&gt; expects one read-only argument &lt;code&gt;a&lt;/code&gt;.
It is a two dimensional array (a table) with 4 rows and 5 columns.
Each cell contains a &lt;code&gt;float32&lt;/code&gt; number.&lt;/p&gt;
&lt;p&gt;Unlike C, in Blech the lengths appear before the payload type in the type declaration.&lt;/p&gt;
&lt;p&gt;Elements of an array are accessed using a subscription operation &lt;code&gt;[]&lt;/code&gt;.
The first element has index &lt;code&gt;0&lt;/code&gt;.
If an array dimension has &lt;code&gt;N&lt;/code&gt; values, the last index is &lt;code&gt;N-1&lt;/code&gt;.
The index argument must be an integer number within array bounds.&lt;/p&gt;
&lt;p&gt;The contents of one array may be copied to another using assignment provided their shape and payload data type are the same.&lt;/p&gt;
&lt;h3 id=&#34;array-operations&#34;&gt;Array operations&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;// Initialise the following matrix
//      cols
// rows 0.0  0.0
//      1.2  3.4
//      0.0  0.0
var a: [3][2]float32 = {[1]={1.2, 3.4}}

let r: [2]float32 = a[1] // copy 2nd row of a into r

let x = a[1][1]          // copy 3.4 to x
                         // x is deduced to have type float32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;structure-types&#34;&gt;Structure types&lt;/h2&gt;
&lt;p&gt;A structure declaration introduces a new type identifier.
A structure contains a fixed number of &lt;em&gt;fields&lt;/em&gt;.
Each field has an access capability (&lt;code&gt;let&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt;), a name, some data type and possibly a default value initialiser.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StructDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;struct&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Field&lt;/span&gt;+ &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Field&lt;/span&gt;            ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;var&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;let&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If an initialiser is given for a field this value is taken as the default value when constructing a new instance of this structure.
The initialisation expression must be a compile time value.
Of course, this default value may be overruled by the initialiser given at the instantiation.&lt;/p&gt;
&lt;h3 id=&#34;mutable-and-immutable-structures&#34;&gt;Mutable and immutable structures&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;struct S
   var a: int32 = 7
   var b: int32
end

/* ... somewhere in a local scope ... */
var s1: S    // s1 == {a = 7, b = 0}
s1.b = 17    // ok, now s1 == {a = 7, b = 17}
s1.a = 42    // ok, now s1 == {a = 42, b = 17}
s1 = {}      // ok, reset to default, now s1 == {a = 7, b = 0}

let s2: S = {a = -10, b = 10} // s2 == {a = -10, b = 10}
s2.b = 17                     // error! Cannot change the read-only variable s2
s2 = {}                       // error! Cannot change the read-only variable s2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Structure &lt;code&gt;s1&lt;/code&gt; is declared using a &lt;code&gt;var&lt;/code&gt; access qualifier.
The fields may be overwritten as well as the structure as a whole.
By contrast, &lt;code&gt;s2&lt;/code&gt; is declared using &lt;code&gt;let&lt;/code&gt;.
It cannot be changed after initialisation in any way.&lt;/p&gt;
&lt;p&gt;The above example illustrates all operations available on structures.
The dot &lt;code&gt;.&lt;/code&gt; is used to access a field value inside a structure.
If the value of a field again is a structure it may be further &amp;ldquo;dotted into&amp;rdquo;.
Structures may be assigned using a struct literal or a name of another struct of the same type.
Assigning the empty literal &lt;code&gt;{}&lt;/code&gt; means that all default values are restored.&lt;/p&gt;
&lt;h3 id=&#34;immutable-fields-in-structures&#34;&gt;Immutable fields in structures&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; fields cannot be changed once the structure is instantiated.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;struct T
    let a: int32
    var b: int32
end

struct S
    var x: T
    var y: int32
end

/* usage in local scope */
var s: S = {x.a = 7} // ok, s == {x = {a = 7, b = 0}, y = 0}
s.x.b = 42           // ok, s == {x = {a = 7, b = 42}, y = 0}
s.x.a = 8            // error! read-only field s.x.a cannot be changed after initialisation
s.x = {}               // ok, s.x is reset as a whole, now s == {x = {a = 0, b = 0}, y = 0}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that in the example above the field &lt;code&gt;a&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; is protected against mutation after initialisation.
However the struct &lt;code&gt;s&lt;/code&gt; that holds an instance of &lt;code&gt;T&lt;/code&gt; in its mutable field &lt;code&gt;x&lt;/code&gt; may replace the value of that field.&lt;/p&gt;
&lt;h2 id=&#34;blechconfh&#34;&gt;blechconf.h&lt;/h2&gt;
&lt;p&gt;Blech compiles to C.
Hence code generation has to map Blech types to C types.
The file &lt;code&gt;blechconf.h&lt;/code&gt; specifies this mapping.
It is automatically included (via &lt;code&gt;blech.h&lt;/code&gt;) in every generated C source file.
The Blech compiler guarantees type safety and correct operational behaviour so long as Blech types are mapped onto C types that fit above representation sizes.
It is up to the system integrator to ensure that this mapping is valid for the C compiler and hardware platform at hand.&lt;/p&gt;
&lt;p&gt;A default mapping that makes sense in most cases is shipped with the compiler:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_VOID void 
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BOOL int 
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT8 signed char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT16 signed short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT32 signed long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT64 signed long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_NAT8 unsigned char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_NAT16 unsigned short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_NAT32 unsigned long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_NAT64 unsigned long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS8 unsigned char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS16 unsigned short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS32 unsigned long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS64 unsigned long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_FLOAT32 float
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_FLOAT64 double
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;However compilers before the C99 standard may not support &lt;code&gt;unsigned long long&lt;/code&gt;, for example.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Expressions</title>
      <link>https://www.blech-lang.org/docs/user-manual/expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/expressions/</guid>
      <description>
        
        
        &lt;p&gt;The nomenclature in Blech is similar to that in C.
There are typed memory locations (objects), left hand side expressions (lvalues) and right hand side expressions (rvalues).
Blech does not allow to create function references and thus we have no designators.&lt;/p&gt;
&lt;h2 id=&#34;operator-precedence&#34;&gt;Operator precedence&lt;/h2&gt;
&lt;p&gt;The expression grammar below will not specify the precedence of operators.
This allows for a concise presentation.
Therefore this section specifies the precedence separately.&lt;/p&gt;
&lt;p&gt;All operators are left associative in Blech.
The following table summarizes the operator precedence in Blech, from lowest precedence (least binding) to highest precedence (most binding). Operators in the same box have the same precedence. Unless the syntax is explicitly given, operators are binary.&lt;/p&gt;
&lt;p&gt;Operator precedence low to high:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operators&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;as!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Type annotation and type cast&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean disjunction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;and&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean conjunction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Comparisons&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`&lt;/td&gt;
&lt;td&gt;`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise XOR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise AND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Shifts, rotations and signed right shift&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Addition and subtraction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Multiplication, division and remainder&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;not&lt;/code&gt; x, &lt;code&gt;-&lt;/code&gt;x, &lt;code&gt;~&lt;/code&gt;x&lt;/td&gt;
&lt;td&gt;Negation, unary minus, bit inversion&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;atoms&#34;&gt;Atoms&lt;/h2&gt;
&lt;p&gt;Atoms are the building blocks of expressions.
They are composed using operators.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Atom&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Literal&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{}&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ArrayLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;StructLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ParenthForm&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that the term &amp;ldquo;atom&amp;rdquo; is not to be taken too literally because array and structure literals may contain arbitrary expressions themselves.&lt;/p&gt;
&lt;h3 id=&#34;identifiers&#34;&gt;Identifiers&lt;/h3&gt;
&lt;p&gt;An identifier occurring as an atom is a name. See section &lt;a href=&#34;../lexical/#identifiers&#34;&gt;Identifiers&lt;/a&gt;
 for a lexical definition.&lt;/p&gt;
&lt;h3 id=&#34;literals&#34;&gt;Literals&lt;/h3&gt;
&lt;p&gt;Blech supports various numeric literals:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Literal&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;BoolLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Integer&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;FloatNumber&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Evaluation of a literal yields an object of the given type (bytes, natural number, signed integer, floating point number) with the given value.
The value may be approximated in the case of floating point literals.&lt;/p&gt;
&lt;p&gt;Numeric literals are untyped on their own.
This makes their use more flexible and permits writing more generic code.
Of course, before code generation every expression (and thus every literal) must be assigned a type which is the task of the type checker.
This section explains how to use literals and what type errors may happen.&lt;/p&gt;
&lt;p&gt;Literals are assigned a type either explicitly using a &lt;em&gt;type annotation&lt;/em&gt; expression or implicitly when a unique type can be deduced from the context.&lt;/p&gt;
&lt;h4 id=&#34;annotated-literals&#34;&gt;Annotated literals&lt;/h4&gt;
&lt;p&gt;For example, the literal &lt;code&gt;1&lt;/code&gt; could represent a natural number, a signed integer or a byte word of some size. It could even be a floating point number.
It can be explicitly annotated using a type annotation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;1: nat16    // 2 bytes long natural number
1: int8     // 1 byte signed integer
1: bits32   // 4 bytes long word
1: float32  // single precision floating point number
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The lexical analysis of &lt;code&gt;Literal&lt;/code&gt; above suggests there are three kinds of literals.
In fact, we distinguish two kinds of integers.
Binary, octal and hexadecimal integer literals form the group of &lt;em&gt;bits literals&lt;/em&gt;.
They may be interpreted as a byte word of some length or as a natural number of some length.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;0xFF: nat32    // 4 byte natural number with value 255
0b101: bit8    // 1 byte word with value 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a name=&#34;bitsandints&#34;&gt;&lt;/a&gt;
They cannot be treated as a signed integer because depending on the length and the machine&amp;rsquo;s representation of negative numbers they might yield a negative or positive value.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;0xFF: int8    // error! Would be -1 if represented in two&amp;#39;s complement
0xFF: int16   // error! Would be 255 in a two byte word
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Also, bits literals cannot be interpreted as floating point numbers.
&lt;em&gt;For the exact specification of floating point numbers a hexadecimal float literal will be introduced.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Decimal integers&lt;/em&gt; may be interpreted as any kind of numeric type as long as the value fits the domain. The example above shows the straightforward use case with the literal &lt;code&gt;1&lt;/code&gt;. Below some corner cases are exemplified:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;-2: nat16     // error! Outside range of natural numbers
-200: int8    // error! Outside range [-128..127]
-2: bits8     // 1 byte word with value 254
-200: float32 // single precision floating point number
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Float literals may only be interpreted as either single or double precision floating point numbers even if their fraction part is zero as in &lt;code&gt;10.0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In summary: annotations may only be used where they do not change the value of the expression and the value fits into the domain of the type.&lt;/p&gt;
&lt;h4 id=&#34;type-deduction-for-literals&#34;&gt;Type deduction for literals&lt;/h4&gt;
&lt;p&gt;When a literal occurs as part of a binary expression where one side is already fully typed, the literal&amp;rsquo;s type may be automatically deduced.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;var a: int32 = 9
let b = a + 17    
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In line 1, the 9 is deduced to have type &lt;code&gt;int32&lt;/code&gt; because the left hand side is already typed.
Note that a bits literal cannot be used to initialise an integer for reasons explained &lt;a href=&#34;#bitsandints&#34;&gt;above&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;In line 2, the literal &lt;code&gt;17&lt;/code&gt; is deduced to be &lt;code&gt;int32&lt;/code&gt;, then a signed 32-bit addition is performed and &lt;code&gt;b&lt;/code&gt; is also deduced to be an &lt;code&gt;int32&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;complex-literals&#34;&gt;Complex literals&lt;/h3&gt;
&lt;h4 id=&#34;reset-literal&#34;&gt;Reset literal&lt;/h4&gt;
&lt;p&gt;Empty braces &lt;code&gt;{}&lt;/code&gt; have a special meaning.
They represent the default value for any struct or literal.
Using the reset literal in a declaration has the same effect as leaving out the initialisation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;var x: [8]float32 = {}
var y: [8]float32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will be initialised with zeros in all cells.
The reset literal, as the name suggests, is most useful to set a modified data structure back to its default values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;var x: [8]float32 = {1, 2, 3, 4, 5, 6, 7, 8}
x = {}    // now x == {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The reset literal cannot be assigned to a structure that contains immutable fields (or, recursively, substructures with immutable fields).
The same is true for arrays with struct payloads.
See the section on &lt;a href=&#34;../types/#structure-types&#34;&gt;Structure types&lt;/a&gt;
 for more details.&lt;/p&gt;
&lt;h4 id=&#34;array-literals&#34;&gt;Array literals&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ArrayLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IndexExpr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;IndexExpr&lt;/span&gt;    ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;[&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The array literal has to fit the shape of the array it is assigned to.
That is, the &lt;code&gt;Expr&lt;/code&gt; in &lt;code&gt;IndexExpr&lt;/code&gt; must evaluate to a non-negative number within array bounds.
It is however permitted to specify fewer values than the number given by the array dimensions.
The missing values are implicitly set to the data type&amp;rsquo;s default value.
It is possible to set specific array cells by also specifying an index for a value.
Subsequent unindexed values will be set for the next array cells in order.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Expr&lt;/code&gt; in &lt;code&gt;CellInit&lt;/code&gt; must match the array&amp;rsquo;s data type.&lt;/p&gt;
&lt;h5 id=&#34;example-setting-array-values&#34;&gt;Example: Setting array values&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;var x: [2][3]nat8 = {{1, 2, 3},{4, 5, 6}} // all explicit
// x is
// 1  2  3
// 4  5  6

x[1] = {7, 8}                             // third value implicitly 0
// x is
// 1  2  3
// 7  8  0

x[1] = {[1] = 9, 10}                      // first value implicitly 0
// x is                                   // the index of `10` implicitly is 2
// 1  2  3
// 0  9  10

x = {{[1] = 11},{[0] = 12, [2] = 13}}
// x is
// 0  11  0
// 12  0  13

x = { {[2]=14} }                          // second row implicitly zeroed out
// x is
// 0  0  14
// 0  0  0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;struct-literals&#34;&gt;Struct literals&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StructLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The identifiers must match the field names of the struct to be assigned.
The &lt;code&gt;Expr&lt;/code&gt; must match the corresponding field&amp;rsquo;s data type.
Immutable (&lt;code&gt;let&lt;/code&gt; declared) fields may only be set in the initialisation of the structure.
Fields that are not specified in the literal are implicitly set to their data type&amp;rsquo;s default value.&lt;/p&gt;
&lt;h5 id=&#34;example-setting-struct-values&#34;&gt;Example: Setting struct values&lt;/h5&gt;
&lt;p&gt;Assume the following declarations:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;struct S
    var a: int8
    var b: int8
end

struct T
    let x: bool
    var y: S
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The following code may be written (in some local scope):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;var t: T = {x = true, y = {a = 1, b = 2}}
// t is
// t.x == true
// t.y.a == 1
// t.y.b == 2

t = {y = {a = 7}} // error! Cannot assign immutable field t.x

t.y = {a = 7}     // implicitly b = 0
// t is
// t.x == true
// t.y.a == 7
// t.y.b == 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;parenthesised-form&#34;&gt;Parenthesised form&lt;/h2&gt;
&lt;p&gt;A parenthesised form is an expression enclosed in parentheses:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ParenthForm&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A parenthesised expression yields whatever that expression yields.&lt;/p&gt;
&lt;h2 id=&#34;primaries&#34;&gt;Primaries&lt;/h2&gt;
&lt;p&gt;Primaries represent the most tightly bound operations of the language. Their syntax is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Atom&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Selection&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Subscription&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;FunctionCallExpr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;field-selection&#34;&gt;Field selection&lt;/h2&gt;
&lt;p&gt;A field selection is a primary expression followed by a period and a name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Selection&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Primary&lt;/code&gt; must evaluate to a struct instance that contains a field with the name given by &lt;code&gt;Identifier&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;subscriptions&#34;&gt;Subscriptions&lt;/h2&gt;
&lt;p&gt;A subscripting expression selects an item of an array:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Subscription&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;[&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expression&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The index expression must return a value that is non-negative and smaller than the array length.
Otherwise the program will crash in debug build mode and saturate to array index bounds in release mode.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;

    The current implementation relies on C semantics and has no build modes. It will not necessarily crash, since C may read any addressable memory.

&lt;/div&gt;

&lt;h2 id=&#34;calls&#34;&gt;Calls&lt;/h2&gt;
&lt;p&gt;A call calls a function with a possibly empty series of arguments:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;FunctionCallExpr&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;all-computation-expressions&#34;&gt;All computation expressions&lt;/h2&gt;
&lt;p&gt;All expressions above are concerned with retrieving a single value from some data structure. (With the exception of function calls).
Now all expressions are presented which take a value (or two) and produce a new value from it (those).
The following rule gives an overview of the remaining expression syntax.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt;                                            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;highest&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;precedence&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; 
    | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;~&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;not&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;%&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;lt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;lt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;amp;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;^&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;|&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;==&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;!=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;and&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;or&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;as&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;as!&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;lowest&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;precedence&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Operator precedence has been discussed &lt;a href=&#34;#operator-precedence&#34;&gt;above&lt;/a&gt;
.&lt;/p&gt;
&lt;h3 id=&#34;unary-operations&#34;&gt;Unary operations&lt;/h3&gt;
&lt;p&gt;The unary &lt;code&gt;-&lt;/code&gt; (minus) operator yields the negation of its numeric argument.
If the argument is a literal without an annotation, it may not be a binary, octal or hexadecimal number because these are supposed to be some &lt;code&gt;bitX&lt;/code&gt; type without a known length (yet) and the result of a minus cannot be defined.&lt;/p&gt;
&lt;p&gt;The unary &lt;code&gt;~&lt;/code&gt; (invert) operator yields the bitwise inversion of its &lt;code&gt;bitsX&lt;/code&gt; argument.
It cannot be applied to a literal without a type annotation.&lt;/p&gt;
&lt;p&gt;The unary &lt;code&gt;not&lt;/code&gt; operator yields the opposite of its Boolean argument.&lt;/p&gt;
&lt;h3 id=&#34;binary-arithmetic-operations&#34;&gt;Binary arithmetic operations&lt;/h3&gt;
&lt;p&gt;The binary arithmetic operations require that the arguments are of some numeric type.&lt;/p&gt;
&lt;p&gt;The arithmetic operations work as expected on all arithmetic types.
See the sections on &lt;a href=&#34;../types/#integer-types&#34;&gt;arithmetic types&lt;/a&gt;
 for details regarding overflow handling.&lt;/p&gt;
&lt;p&gt;The arguments&#39; types may differ only in size.
When they differ, the smaller size value is lifted implicitly to the larger size.
The operation is then carried out on (possibly lifted) arguments of the same type.&lt;/p&gt;
&lt;h4 id=&#34;lifting-types&#34;&gt;Lifting types&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;var x: int8 = 7
var y: int16 = 300
var z = x + y
var u = x + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both signed integers but have different sizes.
In the context of the addition in line 3, the smaller type is lifted to the larger, effectively making &lt;code&gt;x&lt;/code&gt; an &lt;code&gt;int16&lt;/code&gt;.
Then, 16-bit signed addition is carried out producing an &lt;code&gt;int16&lt;/code&gt; typed result.
This result is stored into &lt;code&gt;z&lt;/code&gt; making it a &lt;code&gt;int16&lt;/code&gt; variable, too.&lt;/p&gt;
&lt;p&gt;In line 4, the literal &lt;code&gt;1&lt;/code&gt; is deduced to be of type &lt;code&gt;int8&lt;/code&gt; in the context of this expression (cf. paragraph on &lt;a href=&#34;#type-deduction-for-literals&#34;&gt;type deduction&lt;/a&gt;
 for literals).
Then, 8-bit signed addition is carried out producing an &lt;code&gt;int8&lt;/code&gt; typed result.
This result is stored into &lt;code&gt;u&lt;/code&gt; making it a &lt;code&gt;int8&lt;/code&gt; variable, too.&lt;/p&gt;
&lt;p&gt;The following snippet shows typical caveats.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;var x: int32 = 49 - 7    // error! Cannot determine type of &amp;#39;49&amp;#39; and &amp;#39;7&amp;#39;

var y: int8 = (49: int8) - 128 // error 128 does not fit into int8

var a: bits8 = 0x1
var b: nat8 = 2
var c = a + b            // error! Type mismatch
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In line 1, the context of &lt;code&gt;49&lt;/code&gt; is &lt;code&gt;7&lt;/code&gt; and vice versa.
Both do not have a concrete type.
It is therefore not clear which implementation of &lt;code&gt;-&lt;/code&gt; should be invoked.
The code only specifies that the result will be stored in an &lt;code&gt;int32&lt;/code&gt; memory location but several different types (&lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;) would fit in there.&lt;/p&gt;
&lt;p&gt;In line 3, the previous issue was resolved by specifying that &lt;code&gt;49&lt;/code&gt; should be treated as an &lt;code&gt;int8&lt;/code&gt;.
Thus the other operand must be an &lt;code&gt;int8&lt;/code&gt; as well but the given literal is outside the &lt;code&gt;int8&lt;/code&gt; domain.
(In this particular case, writing &lt;code&gt;(49: int8) + (-128)&lt;/code&gt; would solve the problem due to the asymmetry of signed integers.)&lt;/p&gt;
&lt;p&gt;The last line shows an operation on different types (of the same size).
Addition for natural numbers must not overflow while addition for bits will wrap around.
It is not clear which one should be used here.
Either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; need to be explicitly cast using the &lt;code&gt;as&lt;/code&gt; operator to resolve this issue.&lt;/p&gt;
&lt;h3 id=&#34;bitwise-operations&#34;&gt;Bitwise operations&lt;/h3&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;


    // TODO

&lt;/div&gt;

&lt;h3 id=&#34;comparison-operations&#34;&gt;Comparison operations&lt;/h3&gt;
&lt;p&gt;Unlike C, in Blech equality and inequality have the same priority as the ordering operators.
Furthermore the precedence of comparison operators is lower than that of any arithmetic, shifting or bitwise operation.&lt;/p&gt;
&lt;p&gt;Note that all operators are left associative.
Hence chaining comparisons is possible syntactically but makes little sense.&lt;/p&gt;
&lt;h4 id=&#34;comparison-chaining&#34;&gt;Comparison chaining&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;var b = 4 &amp;lt; 5 &amp;lt;= false // evaluates to true &amp;lt;= false which is false
var c = 4 &amp;lt; 5 &amp;lt;= 6 // type error: cannot compare true &amp;lt;= 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is different to C because in Blech Booleans and numbers are incomparable.&lt;/p&gt;
&lt;h4 id=&#34;comparison-lifting&#34;&gt;Comparison lifting&lt;/h4&gt;
&lt;p&gt;Comparison operators lift their arguments to a common sized type like arithmetic operators do (see above).
Additionally, comparisons permit using literals that would require a larger domain.
This allows writing (in)equalities without cluttering the code with trivial type casts.&lt;/p&gt;
&lt;h5 id=&#34;example-comparison-with-literals-outside-the-domain&#34;&gt;Example: Comparison with literals outside the domain&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;var x: int8 = 7
var y = x &amp;lt; 1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The literal &lt;code&gt;1000&lt;/code&gt; is a (signed) integral number and would fit into an &lt;code&gt;int16&lt;/code&gt;.
Therefore we allow to implicitly lift &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;int16&lt;/code&gt; and carry out the comparison.
This makes sense because the result of all comparison operators is always a Boolean value.
There are no &amp;ldquo;surprises&amp;rdquo; about the outcome.&lt;/p&gt;
&lt;h3 id=&#34;logical-operators&#34;&gt;Logical operators&lt;/h3&gt;
&lt;p&gt;The operators &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; may only be applied to Boolean typed arguments.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;a and b&lt;/code&gt; is true if and only if &lt;code&gt;a&lt;/code&gt; is true and &lt;code&gt;b&lt;/code&gt; is true.
The evaluation is performed lazily: first &lt;code&gt;a&lt;/code&gt; is evaluated. If it is false, the expression returns &lt;code&gt;false&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;a or b&lt;/code&gt; is true unless both &lt;code&gt;a&lt;/code&gt; is false and &lt;code&gt;b&lt;/code&gt; is false.
The evaluation is performed lazily: first &lt;code&gt;a&lt;/code&gt; is evaluated. If it is true, the expression returns &lt;code&gt;true&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;representation-annotation-and-change&#34;&gt;Representation annotation and change&lt;/h3&gt;
&lt;p&gt;Type annotations specify a concrete type for a literal which may represent values from different types.&lt;/p&gt;
&lt;p&gt;Type casts &lt;em&gt;change&lt;/em&gt; the type of an already typed expression.
Casts are only permitted where the (machine) representation of a value will not change and casts assume that the value fits into the target type&amp;rsquo;s domain.&lt;/p&gt;
&lt;h4 id=&#34;safe-casts&#34;&gt;Safe casts&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;var x: int16 = 100
let y = x as nat8    // ok, y == 100 of type nat8

x = x * 3
let z = x as nat8    // runtime error: 300 outside nat8 domain 0..255

x = -256             // assuming 2&amp;#39;s complement on the machine:
                     // x == 0xb_1111_1111_0000_0000
let u = x as bits8   // runtime error
let v = x as bits16  // ok, v == 65280

let f: float32 = 1
x = f as int16       // error! impossible to cast floating point to integral types
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The restrictions on the casts do not rule out runtime errors.
At the same time they prevent some manipulations that are possible in C.
For example, it is not possible to interpret a floating point as a bits type and change individual bits.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;


    // TODO is the description of &lt;code&gt;as&lt;/code&gt; correct? Are there restrictions, bugs, features?

&lt;/div&gt;

&lt;h3 id=&#34;evaluation-order&#34;&gt;Evaluation order&lt;/h3&gt;
&lt;p&gt;Undefined at the moment. Evaluated by the C compiler.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Modules</title>
      <link>https://www.blech-lang.org/docs/user-manual/modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.blech-lang.org/docs/user-manual/modules/</guid>
      <description>
        
        
        &lt;h2 id=&#34;compilation-units&#34;&gt;Compilation units&lt;/h2&gt;
&lt;p&gt;A Blech program may be split into multiple files: a program file and so-called &lt;em&gt;module&lt;/em&gt; files.
The purpose of modules is to encapsulate the implementation of a certain aspect (functionality) in a given software project.&lt;/p&gt;
&lt;p&gt;Both a program file and a module file have the &lt;code&gt;.blc&lt;/code&gt; extension.
However a file representing the program must contain an &lt;a href=&#34;../declarations/#subprograms&#34;&gt;entry point activity&lt;/a&gt;
.
There must not be a &lt;a href=&#34;#modules&#34;&gt;module declaration&lt;/a&gt;
 in a program file.&lt;/p&gt;
&lt;p&gt;Vice versa, a module file will declare a module (see below) and must not contain an entry point.&lt;/p&gt;
&lt;p&gt;This difference is best understood when looking at the compilation results.
The compilation of the &lt;em&gt;program file&lt;/em&gt; produces C code with an &lt;em&gt;init&lt;/em&gt; and a &lt;em&gt;tick&lt;/em&gt; function which form the API towards the environment.
Additionally, the compilation result of a Blech program will also contain a &lt;em&gt;context&lt;/em&gt; data structure which contains all program counters and local variables of that program.&lt;/p&gt;
&lt;p&gt;A Blech module, by contrast, is supposed to be &lt;em&gt;used&lt;/em&gt; by some Blech program or another module.
Therefore all its activities reply on context information passed on from the caller.&lt;/p&gt;
&lt;h2 id=&#34;modules&#34;&gt;Modules&lt;/h2&gt;
&lt;p&gt;A Blech module is a &lt;code&gt;.blc&lt;/code&gt; file.
Modules cannot span several files nor can a file contain several modules.
A module constitutes a name space within which various &lt;a href=&#34;../declarations&#34;&gt;declarations&lt;/a&gt;
 may appear.
All declarations &lt;em&gt;within&lt;/em&gt; a module are visible.
In particular, implementations details such as the fields of a structure are visible.&lt;/p&gt;
&lt;p&gt;By contrast, no declaration is visible &lt;em&gt;outside&lt;/em&gt; the module unless it is explicitly &lt;em&gt;exposed&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Thus modules are a mechanism to encapsulate code, provide an API for it and hide implementation details from client code.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Module&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;module&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;exposes&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;IdentifierList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DeclarationList&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;IdentifierList&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;IdentifierList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;DeclarationList&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;StructDeclaration&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;DataDeclaration&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ProgramDeclaration&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that the module itself has no identifier. Client code which uses this module will &lt;em&gt;find&lt;/em&gt; it by its file name and &lt;em&gt;give&lt;/em&gt; it some local name when &lt;a href=&#34;#Imports&#34;&gt;importing&lt;/a&gt;
 the module.&lt;/p&gt;
&lt;p&gt;Also, remember that the &lt;a href=&#34;../declarations/#qualifiers&#34;&gt;qualifiers&lt;/a&gt;
 &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; must not appear on the top-level scope - no globals in Blech.&lt;/p&gt;
&lt;p&gt;Example of a module:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;module exposes initialise, push, average

const Size: nat8 = 10

struct RingBuffer
    var buffer: [Size]nat32
    var nextIndex: nat8
    var count: nat8
end

/// returns an initialisation value for a ring buffer
function initialise () returns RingBuffer
    return { nextIndex = 0, count = 0 }
end

/// pushes a new value to the ring buffer
/// displaces the &amp;#34;oldest&amp;#34; value if the ring buffer is full
function push (value: nat32) (rb: RingBuffer)
    rb.buffer[rb.nextIndex] = value
    rb.nextIndex = rb.nextIndex + 1
    if rb.count == Size then // ringbuffer is completely filled
        rb.nextIndex = rb.nextIndex % Size
    else
        rb.count = rb.count + 1
    end
end

/// calculates the average value of all values stored in the ring buffer
function average (rb: RingBuffer) returns nat32
    var idx: nat8 = 0
    var avg: nat32 = 0
    while idx &amp;lt; rb.count repeat
        avg = avg + rb.buffer[idx]
    end
    return avg / rb.count
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This module encapsulates the implementation of a ring buffer.
The ring buffer is represented by the &lt;code&gt;RingBuffer&lt;/code&gt; structure that holds a buffer of fixed size.
Three functions are implemented to initialise the buffer, add values to it, and calculate the average over all values currently stored in the ring buffer.
The module exposes the functions &lt;code&gt;initialise&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;average&lt;/code&gt; to client code that will use this module.
However it hides the size of the buffer and the details of its data structure because &lt;code&gt;Size&lt;/code&gt; and &lt;code&gt;RingBuffer&lt;/code&gt; do not appear in the list of exposed names.
The name &lt;code&gt;RingBuffer&lt;/code&gt; is implicitly visible outside as the name of an opaque type, see below.&lt;/p&gt;
&lt;h2 id=&#34;signatures&#34;&gt;Signatures&lt;/h2&gt;
&lt;p&gt;The compiler translates a Blech module into C code.
But it also automatically generates a &lt;em&gt;signature&lt;/em&gt; which is saved under the same name but with a &lt;code&gt;.blh&lt;/code&gt; extension.
Signatures are never manually written by the software developer.&lt;/p&gt;
&lt;p&gt;A signature describes the API of the module.
It contains the explicitly exposed constants, types and procedure prototypes.
Furthermore implicitly exported names of types, singletons or procedures are listed.
Finally, imports that are necessary to use the exposed procedures also appear in the signature.&lt;/p&gt;
&lt;p&gt;Signatures are used by the compiler when compiling client code.
The compiler in principle does not need to have the sources of imported sub-modules, instead all semantic checks can be done using the signatures only.
In the future, this allows to pre-compile modules into object files for a target platform and ship those object files together with the signature files to the customer.
Since Blech programs cannot be imported in other &lt;code&gt;.blc&lt;/code&gt; files, no signatures are generated for them.&lt;/p&gt;
&lt;p&gt;Types which are not explicitly exposed by a module but are used by some exposed function or activity appear in the signature as &lt;em&gt;opaque&lt;/em&gt; (or &lt;em&gt;abstract&lt;/em&gt;) types.
Opaque types only have a name but do not reveal their inner implementation details. 
The declaration of the name is required by the client code so that it can &amp;ldquo;pass around&amp;rdquo; values of the opaque types between procedures even though the content cannot be accessed directly.&lt;/p&gt;
&lt;p&gt;Here is an example of the generated signature for the module in the previous section.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;signature

@[StructType]
type RingBuffer

/// returns an initialisation value for a ring buffer
function initialise () returns RingBuffer

/// pushes a new value to the ring buffer
/// displaces the &amp;#34;oldest&amp;#34; value if the ring buffer is full
function push (value: nat32) (rb: RingBuffer)

/// calculates the average value of all values stored in the ring buffer
function average (rb: RingBuffer) returns nat32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The type &lt;code&gt;RingBuffer&lt;/code&gt; was not exposed by the module but it is used by the exposed functions. For instance, it is the return type of the exposed function &lt;code&gt;initialise&lt;/code&gt;.
Therefore the type name &lt;code&gt;RingBuffer&lt;/code&gt; appears in the signature.
The annotation &lt;code&gt;@[StructType]&lt;/code&gt; is not part of the Blech language but merely a hint to the C code generator.&lt;/p&gt;
&lt;p&gt;Furthermore, signatures contain import declarations (see &lt;a href=&#34;#Imports&#34;&gt;below&lt;/a&gt;
) that are necessary to use this module.
This is the case when, for example, an exposed function uses a type from an imported module.
Then, in order to declare a prototype of this function in the signature, an import is required to access the type name.&lt;/p&gt;
&lt;p&gt;Finally, signatures also declare &lt;em&gt;opaque singletons&lt;/em&gt;.
These are the names of procedures which are singletons themselves, not explicitly exposed, but used in exposed procedures.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;module exposes f

singleton x
@[CFunction (binding = &amp;#34;foo()&amp;#34;, header = &amp;#34;bar.h&amp;#34;)]
extern singleton function y ()

singleton [x] function f()
    y()
    //...
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Accordingly, the signature contains an opaque singleton &lt;code&gt;y&lt;/code&gt; without specifying that it was an (external) function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;signature

singleton x

@[CFunction(binding = &amp;#34;foo()&amp;#34;, header = &amp;#34;bar.h&amp;#34;)]
singleton y

singleton [x, y] function f ()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Also note, how the declaration of &lt;code&gt;f&lt;/code&gt; contains the &lt;em&gt;full&lt;/em&gt; list of singletons that it depends on.&lt;/p&gt;
&lt;h2 id=&#34;imports&#34;&gt;Imports&lt;/h2&gt;
&lt;p&gt;A module needs to be imported by the down stream client code if the latter want to use the exposed members.&lt;/p&gt;
&lt;p&gt;Following our previous ring buffer example, its usage might look like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import rb &amp;#34;/data_structures/ringbuffer&amp;#34;

module exposes SlidingAverage 

param Threshold: nat32 = 10000 // Application parameter

/// Calculates the average of the latest values in every tick
/// Values outside a fixed threshold are ignored.
activity SlidingAverage (value: nat32) (average: nat32)
    var buf: rb.RingBuffer = rb.initialise() 
    repeat
        if value &amp;lt;= Threshold then
            rb.push(value)(buf)
        end
        average = rb.average(buf)
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here we assume that in the root &lt;code&gt;/&lt;/code&gt; of the current project there is a &lt;code&gt;data_structures&lt;/code&gt; folder which contains a &lt;code&gt;ringbuffer.blc&lt;/code&gt; module file. (The extension is omitted on purpose).
In order to use its exposed members the local name &lt;code&gt;rb&lt;/code&gt; is introduced.
Now we can refer to the opaque data type &lt;code&gt;rb.RingBuffer&lt;/code&gt; or the functions &lt;code&gt;rb.initialise&lt;/code&gt; etc&amp;hellip;&lt;/p&gt;
&lt;p&gt;Formally, the import declaration is as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Import&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;import&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;internal&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;QUOTE&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ImportPath&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;QUOTE&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;exposes&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;IdentifierList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; 
&lt;span style=&#34;color:#000&#34;&gt;ImportPath&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;../&amp;#34;&lt;/span&gt;+&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Path&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Path&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;import-paths&#34;&gt;Import paths&lt;/h3&gt;
&lt;p&gt;There are three kinds of import paths according to this grammar:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the path starts with an identifier&lt;/li&gt;
&lt;li&gt;the path starts with ../&lt;/li&gt;
&lt;li&gt;the path starts with /&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the example above we have see case 3. 
The slash indicates the root of the project. 
It is set by the &lt;code&gt;--project-dir&lt;/code&gt; compiler flag.&lt;/p&gt;
&lt;p&gt;Case 1 is a path that starts in the same directory as the file that contains this code.&lt;/p&gt;
&lt;p&gt;Case 2 refers to a module which is a parent or sibling in the file system. Note that the path may start several levels above the current file &lt;code&gt;&amp;quot;../&amp;quot;+&lt;/code&gt; but must not leave the project directory.&lt;/p&gt;
&lt;p&gt;In the future there will be a possibility to import (pre-compiled) packages. Ideas can be found in our &lt;a href=&#34;https://www.blech-lang.org/blog/2020/11/23/a-module-system-for-blech/&#34; target=&#34;_blank&#34;&gt;blog&lt;/a&gt;
.
&lt;strong&gt;Note: the current IDE implementation assumes that the open file being edited is located in the project root. This is a simplification that will be corrected in the future. This means that the IDE does not support ../ paths.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;exposing-imported-names&#34;&gt;Exposing imported names&lt;/h3&gt;
&lt;p&gt;The import statement may &lt;em&gt;expose&lt;/em&gt; some names directly to the client code. This makes those names available in the same namespace as the client code without using the given local name prefix.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;import Math &amp;#34;libs/utils/math&amp;#34; exposes pi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Assuming &lt;code&gt;pi&lt;/code&gt; is a name declared in the referenced module, the client code can access this name not only as &lt;code&gt;Math.pi&lt;/code&gt; but also as &lt;code&gt;pi&lt;/code&gt; directly.&lt;/p&gt;
&lt;h3 id=&#34;whitebox-imports&#34;&gt;Whitebox imports&lt;/h3&gt;
&lt;p&gt;Finally, an import can be declared as &lt;code&gt;internal&lt;/code&gt;.
Internal imports behave as if all declarations were exposed by the imported module. Of course, this only works if the original Blech source code is available.
This breaks the information hiding mechanisms and should not be used to circumvent them. Instead this feature is useful for writing unit tests that rely on implementation details not visible outside the tested module. Internal imports allow to separate test code from production code without the need to expose implementation details merely for testing purposes.&lt;/p&gt;
&lt;p&gt;All import statements adhere to three simple rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no self import&lt;/li&gt;
&lt;li&gt;no circular import&lt;/li&gt;
&lt;li&gt;no double import&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
