---
date: 2020-11-14
title: "The Blech module system"
linkTitle: "Module system"
description: >
    This article explains the Blech module system
author: Franz-Josef Grosch
---



> Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains [...] only one aspect of the desired functionality. 

Blech supports this design technique by grouping code into modules.


## Module implementation

To keep things simple, every Blech file can be compiled separately and is either a program or a module.
A module file groups closely related Blech entities - constants, types, functions, activities, etc. - into a compilation unit, that can be used (imported) by other modules or programs.
The keyword `module` classifies the content of a Blech file as a module.
Different to modules, a program file requires an `@[EntryPoint]` activity which serves as the main activity of a Blech program. 
A program file cannot be imported by other modules or programs.

Assume the following module implementation in file `ringbuffer.blc`.
In order to make an entity accessible it needs to be exposed.
Here, functions `initialise`, `push`, and `average` are exposed for usage, in any importing module or program.

```blech
module exposes initialise, push, average

const Size: nat8 = 10

struct RingBuffer
    var buffer: [Size]nat32
    var nextIndex: nat8
    var count: nat8
end

/// returns an initialisation value for a ring buffer
function initialise () returns RingBuffer
    return { nextIndex = 0, count = 0 }
end

/// pushes a new value to the ring buffer
/// displaces the "oldest" value if the ring buffer is full
function push (value: nat32) (rb: RingBuffer)
    rb.buffer[rb.nextIndex] = value
    rb.nextIndex = rb.nextIndex + 1
    if rb.count = Size then // ringbuffer ist completely filled
        rb.nextIndex = rb.nextIndex % Size
    else
        rb.count = rb.count + 1
    end
end

/// calculates the average value of all values stored in the ring buffer
function average (rb: RingBuffer) returns nat32
    var idx: nat8 = 0
    var avg: nat32 = 0
    while idx < rb.count do
        avg = avg + rb.buffer[idx]
    end
    return avg / rb.count
end
```

## Module interface

> A module interface expresses the elements that are provided and required by the module. The elements defined in the interface are detectable by other modules. The implementation contains the working code that corresponds to the elements declared in the interface. 

A module interface in Blech is called a `signature`.
The signature is generated by the compiler from the module implementation and the `exposes` declaration.
A Blech programmer never writes a signature file.
After compilation of file `ringbuffer.blc` you will find the following module interface in file `ringbuffer.blh`.

```blech
signature

type RingBuffer

/// returns an initialisation value for a ring buffer
function initialise () returns RingBuffer

/// pushes a new value to the ring buffer
/// displaces the "oldest" value if the ring buffer is full
function push (value: nat32) (rb: RingBuffer)

/// calculates the average value of all values stored in the ring buffer
function average (rb: RingBuffer) returns nat32
```

The exposed functions additionally need the type `RingBuffer`.

Since `struct RingBuffer` is not exposed in the module it is made available as an abstract `type RingBuffer` in the signature.
While the implementation remains hidden, the type can be used to define variables and assign values of this type.
This allows to change the internal representation, while any code the uses the module remains unchanged. 
Abstract types are sometimes also called opaque types, and are a very simple form of the theoretical concept of existential types.


Signatures carry all information necessary to compile any code that uses this module. 
This enables to package Blech modules into libraries. 
There is no need to deliver module implementations.
It is enough to deliver compiled libraries with:
* signatures, .h- and .c-files, using the Blech compiler or
* signatures, .h-files and target-specific object files, additionally using the target's C compiler.


## Using modules

In order to use a module it gets imported by another module or program.
Assume the following use of the `ringbuffer` module from a module implementation in file `slidingaverage.blc`.

```blech
import rb "ringbuffer"

module exposes SlidingAverage 

/// Calculates the average of the latest values in every tick
activity SlidingAverage (value: nat32) (average: nat32)
    var buf: rb.RingBuffer = rb.initialise() 
    repeat
        rb.push(value)(buf)
        average = rb.average(buf)
        await true
    end
end
```

This module imports a module from file `ringbuffer.blc` with the local name `rb`.
It implements and exposes a single activity `SlidingAverage`, with a local variable of type `rb.RingBuffer`.
The module completely hides its internal implementation, which uses the abstract type `RingBuffer` and functions `initialise`, `push` and `average` from module `rb`.

The generated signature is very simple. 
The implementations details are completely hidden.

``` blech
signature

/// Calculates the average of the latest values in every tick
activity SlidingAverage (value: nat32) (average: nat32)
```

Using this module in a Blech program file `main.blc` is straight forward.

```blech
import sa "slidingaverage"

@[EntryPoint]
activity SlidingAverage (sensor: nat32) (sensorAverage: nat32)
    run sa.SlidingAverage(sensor)(sensorAverage)    
end
```

## Compiling a program

> Often modules form a directed acyclic graph (DAG); in this case a cyclic dependency between modules is seen as indicating that these should be a single module. In the case where modules do form a DAG they can be arranged as a hierarchy, where the lowest-level modules are independent, depending on no other modules, and higher-level modules depend on lower-level ones. 

In Blech, programs as top-level compilation units and imported modules form a directed acyclic graph.
This enables automatic dependency management in the compiler. 

In the above example, the compilation of program file `main.blc` automatically compiles imported module `slidingaverage` which in turn compiles imported module `ringbuffer`.
Any cycle in the import dependencies will be flagged as an error. 

In general the compilation of any program and any module triggers the compilation of imported modules, if necessary.
A layered module hierarchy is always guaranteed. 

## Testing a module

## Organizing Blech files

## Software qualities

High cohesion, low coupling, independent layers, separate compilation, separate testability, information hiding, API orientation

## Steinbruch


> Often modules form a directed acyclic graph (DAG); in this case a cyclic dependency between modules is seen as indicating that these should be a single module. In the case where modules do form a DAG they can be arranged as a hierarchy, where the lowest-level modules are independent, depending on no other modules, and higher-level modules depend on lower-level ones. A particular program or library is a top-level module of its own hierarchy, but can in turn be seen as a lower-level module of a higher-level program, library, or system. 

```blech
module exposes initialise, push, average

const Size: nat8 = 10

struct RingBuffer
    var buffer: [Size]nat32
    var nextIndex: nat8
    var count: nat8
end

function initialise () returns RingBuffer
    return { nextIndex = 0, count = 0 }
end

function push (value: nat32) (rb: RingBuffer)
    rb.buffer[rb.nextIndex] = value
    rb.nextIndex = rb.nextIndex + 1
    if rb.count = Size then // ringbuffer ist completely filled
        rb.nextIndex = rb.nextIndex % Size
    else
        rb.count = rb.count + 1
    end
end

function average (rb: RingBuffer) returns nat32
    var idx: nat8 = 0
    var avg: nat32 = 0
    while idx < rb.count do
        avg = avg + rb.buffer[idx]
    end
    return avg / rb.count
end
```

```blech
signature

type RingBuffer

function initialise () returns RingBuffer
function push (value: nat32) (rb: RingBuffer)
function average (rb: RingBuffer) returns nat32
```


```blech
import rb "ringbuffer"

module exposes SlidingAverage 

activity SlidingAverage (value: nat32) (average: nat32)
    var buf: rb.RingBuffer = rb.initialise() 
    repeat
        rb.push(value)(buf)
        average = rb.average(buf)
        await true
    end
end
```

``` blech
signature

activity SlidingAverage (value: nat32) (average: nat32)
```

```blech
import sa "slidingaverage"

@[EntryPoint]
activity SlidingAverage (sensor: nat32) (sensorAverage: nat32)
    run sa.SlidingAverage(sensor)(sensorAverage)    
end
```


Bad design.

``` blech
import rb "ringbuffer"

module exposes SlidingAverage 

activity SlidingAverage (value: nat32) 
                        (ringbuffer: rb.RingBuffer, average: nat32)
    repeat
        rb.push(value)(ringBuffer)
        average = rb.average(ringBuffer)
        await true
    end
end
```

``` blech
import rb "ringbuffer"

signature

activity SlidingAverage (value: nat32) 
                        (ringbuffer: rb.RingBuffer, average: nat32)
```

```blech
import r "ringbuffer"
import s "slidingaverage"

@[EntryPoint]
activity SlidingAverage (sensor: nat32) (sensorAverage: nat32)
    var ringBuffer: r.RingBuffer = r.initialise()
    run s.SlidingAverage(sensor)(ringBuffer, sensorAverage)    
end
```